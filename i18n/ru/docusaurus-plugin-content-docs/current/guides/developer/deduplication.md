---
slug: /guides/developer/deduplication
sidebar_label: 'Стратегии дедупликации'
sidebar_position: 3
description: 'Используйте дедупликацию, когда необходимо выполнять частые upsert операции, обновления и удаления.'
title: 'Стратегии дедупликации'
---

import deduplication from '@site/static/images/guides/developer/de_duplication.png';
import Image from '@theme/IdealImage';


# Стратегии дедупликации

**Дедупликация** относится к процессу ***удаления дублирующихся строк в наборе данных***. В OLTP базе данных это делается легко, поскольку каждая строка имеет уникальный первичный ключ, но это выполняется за счет более медленных вставок. Каждая вставленная строка сначала должна быть найдена, и, если она найдена, её нужно заменить.

ClickHouse разработан для высокой скорости при вставке данных. Файлы хранения неизменяемы, и ClickHouse не проверяет существующий первичный ключ перед вставкой строки, поэтому дедупликация требует немного больше усилий. Это также означает, что дедупликация не является моментальной – она **будет выполнена в будущем**, что имеет несколько побочных эффектов:

- В любой момент времени в вашей таблице все еще могут быть дубликаты (строки с одинаковым ключом сортировки)
- Фактическое удаление дублирующихся строк происходит во время слияния частей
- Ваши запросы должны допускать возможность наличия дубликатов

<div class='transparent-table'>

|||
|------|----|
|<Image img={deduplication}  alt="Логотип дедупликации" size="sm"/>|ClickHouse предлагает бесплатное обучение по дедупликации и многим другим темам. Модуль обучения по [Удалению и обновлению данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs) - хорошее место для старта.|

</div>

## Опции для дедупликации {#options-for-deduplication}

Дедупликация реализуется в ClickHouse с использованием следующих движков таблиц:

1. Движок таблиц `ReplacingMergeTree`: с этим движком дублирующие строки с одинаковым ключом сортировки удаляются во время слияний. `ReplacingMergeTree` является хорошим вариантом для имитации поведения upsert (когда вы хотите, чтобы запросы возвращали последнюю вставленную строку).

2. Схлопывание строк: движки таблиц `CollapsingMergeTree` и `VersionedCollapsingMergeTree` используют логику, при которой существующая строка "отменяется", а новая строка вставляется. Они сложнее в реализации, чем `ReplacingMergeTree`, но ваши запросы и агрегаты могут быть проще для написания, не беспокоясь о том, произошла ли агрегация данных. Эти два движка таблиц полезны, когда вам нужно часто обновлять данные.

Мы рассмотрим обе эти техники ниже. Для получения более подробной информации ознакомьтесь с нашим бесплатным модулем обучения [Удаление и обновление данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs).

## Использование ReplacingMergeTree для Upserts {#using-replacingmergetree-for-upserts}

Рассмотрим простой пример, где таблица содержит комментарии Hacker News с колонкой views, представляющей количество раз, которое комментарий был просмотрен. Допустим, мы вставляем новую строку, когда статья публикуется, и обновляем новую строку раз в день с общим количеством просмотров, если значение увеличивается:

```sql
CREATE TABLE hackernews_rmt (
    id UInt32,
    author String,
    comment String,
    views UInt64
)
ENGINE = ReplacingMergeTree
PRIMARY KEY (author, id)
```

Давайте вставим две строки:

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'Это пост #1', 0),
   (2, 'ch_fan', 'Это пост #2', 0)
```

Чтобы обновить колонку `views`, вставляем новую строку с тем же первичным ключом (обратите внимание на новые значения в колонке `views`):

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'Это пост #1', 100),
   (2, 'ch_fan', 'Это пост #2', 200)
```

Теперь в таблице 4 строки:

```sql
SELECT *
FROM hackernews_rmt
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │     0 │
│  1 │ ricardo │ Это пост #1     │     0 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   200 │
│  1 │ ricardo │ Это пост #1     │   100 │
└────┴─────────┴─────────────────┴───────┘
```

Отдельные блоки выше в выводе показывают две части, которые происходят за кадром – эти данные еще не были объединены, поэтому дублирующиеся строки еще не были удалены. Давайте используем ключевое слово `FINAL` в запросе `SELECT`, что приведет к логическому объединению результата запроса:

```sql
SELECT *
FROM hackernews_rmt
FINAL
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   200 │
│  1 │ ricardo │ Это пост #1     │   100 │
└────┴─────────┴─────────────────┴───────┘
```

Результат содержит только 2 строки, и возвращается последняя вставленная строка.

:::note
Использование `FINAL` нормально, если у вас небольшой объем данных. Если вы имеете дело с большим объемом данных, использование `FINAL` вероятно, не лучший вариант. Давайте обсудим лучший вариант для получения последнего значения столбца...
:::

### Избегание FINAL {#avoiding-final}

Давайте снова обновим колонку `views` для обеих уникальных строк:

```sql
INSERT INTO hackernews_rmt VALUES
   (1, 'ricardo', 'Это пост #1', 150),
   (2, 'ch_fan', 'Это пост #2', 250)
```

В таблице теперь 6 строк, потому что фактическое слияние еще не произошло (только слияние во время запроса, когда мы использовали `FINAL`).

```sql
SELECT *
FROM hackernews_rmt
```

```response
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   200 │
│  1 │ ricardo │ Это пост #1     │   100 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │     0 │
│  1 │ ricardo │ Это пост #1     │     0 │
└────┴─────────┴─────────────────┴───────┘
┌─id─┬─author──┬─comment─────────┬─views─┐
│  2 │ ch_fan  │ Это пост #2     │   250 │
│  1 │ ricardo │ Это пост #1     │   150 │
└────┴─────────┴─────────────────┴───────┘
```

Вместо использования `FINAL`, давайте применим некоторую бизнес-логику - мы знаем, что колонка `views` всегда увеличивается, поэтому мы можем выбрать строку с наибольшим значением, используя функцию `max` после группировки по нужным колонкам:

```sql
SELECT
    id,
    author,
    comment,
    max(views)
FROM hackernews_rmt
GROUP BY (id, author, comment)
```

```response
┌─id─┬─author──┬─comment─────────┬─max(views)─┐
│  2 │ ch_fan  │ Это пост #2     │        250 │
│  1 │ ricardo │ Это пост #1     │        150 │
└────┴─────────┴─────────────────┴────────────┘
```

Группировка, представленная в запросе выше, может быть даже более эффективной (с точки зрения производительности запросов), чем использование ключевого слова `FINAL`.

Наш [модуль обучения по удалению и обновлению данных](https://learn.clickhouse.com/visitor_catalog_class/show/1328954/?utm_source=clickhouse&utm_medium=docs) расширяет этот пример, включая то, как использовать колонку `version` с `ReplacingMergeTree`.

## Использование CollapsingMergeTree для Частого Обновления Колонок {#using-collapsingmergetree-for-updating-columns-frequently}

Обновление колонки предполагает удаление существующей строки и замену её новыми значениями. Как вы уже видели, данный тип мутации в ClickHouse происходит _в будущем_ - во время слияний. Если вам нужно обновить множество строк, может быть более эффективно избежать `ALTER TABLE..UPDATE` и вместо этого просто вставить новые данные рядом с существующими данными. Мы могли бы добавить колонку, указывающую, является ли данные устаревшими или новыми... и на самом деле существует движок таблиц, который уже реализует это поведение очень хорошо, особенно учитывая, что он автоматически удаляет устаревшие данные за вас. Давайте посмотрим, как это работает.

Допустим, мы отслеживаем количество просмотров комментария Hacker News с использованием внешней системы, и каждые несколько часов мы загружаем данные в ClickHouse. Мы хотим, чтобы старые строки были удалены, а новые строки представляли новое состояние каждого комментария Hacker News. Мы можем использовать `CollapsingMergeTree` для реализации этого поведения.

Давайте определим таблицу для хранения количества просмотров:

```sql
CREATE TABLE hackernews_views (
    id UInt32,
    author String,
    views UInt64,
    sign Int8
)
ENGINE = CollapsingMergeTree(sign)
PRIMARY KEY (id, author)
```

Обратите внимание, что в таблице `hackernews_views` есть колонка `Int8` с названием sign, которая обозначается как **колонка знака**. Имя колонки знака произвольное, но тип данных должен быть `Int8`, и обратите внимание, что имя колонки было передано в конструктор движка `CollapsingMergeTree`.

Что такое колонка знака в таблице `CollapsingMergeTree`? Она представляет _состояние_ строки, и колонка знака может быть только 1 или -1. Вот как это работает:

- Если две строки имеют одинаковый первичный ключ (или порядок сортировки, если он отличается от первичного ключа), но разные значения колонок знака, то последняя вставленная строка с +1 становится строкой состояния, а другие строки отменяют друг друга
- Строки, которые отменяют друг друга, удаляются во время слияний
- Строки, для которых нет соответствующей пары, сохраняются

Давайте добавим строку в таблицу `hackernews_views`. Поскольку это единственная строка для этого первичного ключа, мы устанавливаем её состояние в 1:

```sql
INSERT INTO hackernews_views VALUES
   (123, 'ricardo', 0, 1)
```

Теперь предположим, что мы хотим изменить колонку просмотров. Вы вставляете две строки: одну, которая отменяет существующую строку, и одну, которая содержит новое состояние строки:

```sql
INSERT INTO hackernews_views VALUES
   (123, 'ricardo', 0, -1),
   (123, 'ricardo', 150, 1)
```

Теперь в таблице 3 строки с первичным ключом `(123, 'ricardo')`:

```sql
SELECT *
FROM hackernews_views
```

```response
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │     0 │   -1 │
│ 123 │ ricardo │   150 │    1 │
└─────┴─────────┴───────┴──────┘
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │     0 │    1 │
└─────┴─────────┴───────┴──────┘
```

Обратите внимание, что добавление `FINAL` возвращает текущую строку состояния:

```sql
SELECT *
FROM hackernews_views
FINAL
```

```response
┌──id─┬─author──┬─views─┬─sign─┐
│ 123 │ ricardo │   150 │    1 │
└─────┴─────────┴───────┴──────┘
```

Но, конечно, использование `FINAL` не рекомендуется для больших таблиц.

:::note
Значение, которое передается в колонку `views` в нашем примере, на самом деле не требуется, и оно не должно совпадать с текущим значением `views` старой строки. На самом деле, вы можете отменить строку только с помощью первичного ключа и -1:

```sql
INSERT INTO hackernews_views(id, author, sign) VALUES
   (123, 'ricardo', -1)
```
:::

## Обновления в реальном времени из нескольких потоков {#real-time-updates-from-multiple-threads}

С таблицей `CollapsingMergeTree` строки отменяют друг друга, используя колонку знака, и состояние строки определяется последней вставленной строкой. Но это может быть проблематично, если вы вставляете строки из разных потоков, когда строки могут быть вставлены в неправильном порядке. Использование "последней" строки не работает в этой ситуации.

Здесь на помощь приходит `VersionedCollapsingMergeTree` - он схлопывает строки так же, как `CollapsingMergeTree`, но вместо того, чтобы сохранять последнюю вставленную строку, он сохраняет строку с наивысшим значением указанных вами версии.

Рассмотрим пример. Предположим, мы хотим отслеживать количество просмотров комментариев Hacker News, и данные обновляются часто. Мы хотим, чтобы отчеты использовали последние значения без принуждения или ожидания слияний. Мы начинаем с таблицы, аналогичной `CollapsedMergeTree`, за исключением того, что добавляем колонку для хранения версии состояния строки:

```sql
CREATE TABLE hackernews_views_vcmt (
    id UInt32,
    author String,
    views UInt64,
    sign Int8,
    version UInt32
)
ENGINE = VersionedCollapsingMergeTree(sign, version)
PRIMARY KEY (id, author)
```

Обратите внимание, что таблица использует `VersionsedCollapsingMergeTree` в качестве движка и передает **колонку знака** и **колонку версии**. Вот как работает таблица:

- Она удаляет каждую пару строк, которые имеют одинаковый первичный ключ и версию и разные знаки
- Порядок вставки строк не имеет значения
- Обратите внимание, что если колонка версии не является частью первичного ключа, ClickHouse добавляет её в первичный ключ неявно в качестве последнего поля

Вы используете ту же логику при написании запросов - группируете по первичному ключу и используете логику, чтобы избежать строк, которые были отменены, но ещё не удалены. Давайте добавим несколько строк в таблицу `hackernews_views_vcmt`:

```sql
INSERT INTO hackernews_views_vcmt VALUES
   (1, 'ricardo', 0, 1, 1),
   (2, 'ch_fan', 0, 1, 1),
   (3, 'kenny', 0, 1, 1)
```

Теперь мы обновляем две строки и удаляем одну из них. Чтобы отменить строку, обязательно указывайте предыдущее значение версии (поскольку оно является частью первичного ключа):

```sql
INSERT INTO hackernews_views_vcmt VALUES
   (1, 'ricardo', 0, -1, 1),
   (1, 'ricardo', 50, 1, 2),
   (2, 'ch_fan', 0, -1, 1),
   (3, 'kenny', 0, -1, 1),
   (3, 'kenny', 1000, 1, 2)
```

Мы выполним тот же запрос, что и раньше, который ловко добавляет и вычитает значения на основании колонки знака:

```sql
SELECT
    id,
    author,
    sum(views * sign)
FROM hackernews_views_vcmt
GROUP BY (id, author)
HAVING sum(sign) > 0
ORDER BY id ASC
```

Результат – две строки:

```response
┌─id─┬─author──┬─sum(multiply(views, sign))─┐
│  1 │ ricardo │                         50 │
│  3 │ kenny   │                       1000 │
└────┴─────────┴────────────────────────────┘
```

Давайте принудительно проведем слияние таблицы:

```sql
OPTIMIZE TABLE hackernews_views_vcmt
```

В результате должно быть всего две строки:

```sql
SELECT *
FROM hackernews_views_vcmt
```

```response
┌─id─┬─author──┬─views─┬─sign─┬─version─┐
│  1 │ ricardo │    50 │    1 │       2 │
│  3 │ kenny   │  1000 │    1 │       2 │
└────┴─────────┴───────┴──────┴─────────┘
```

Таблица `VersionedCollapsingMergeTree` очень полезна, когда вы хотите реализовать дедупликацию, вставляя строки из нескольких клиентов и/или потоков.

## Почему мои строки не дедуплицируются? {#why-arent-my-rows-being-deduplicated}

Одной из причин, по которой вставленные строки могут не дедуплицироваться, является использование функции или выражения, не обладающих идемпотентностью, в вашем выражении `INSERT`. Например, если вы вставляете строки со столбцом `createdAt DateTime64(3) DEFAULT now()`, ваши строки гарантированно будут уникальными, поскольку каждая строка будет иметь уникальное значение по умолчанию для столбца `createdAt`. Движок таблиц MergeTree / ReplicatedMergeTree не будет знать о необходимости дедупликации строк, так как каждая вставленная строка будет генерировать уникальную контрольную сумму.

В этом случае вы можете указать свой собственный `insert_deduplication_token` для каждой партии строк, чтобы гарантировать, что множественные вставки одной и той же партии не приведут к повторной вставке одних и тех же строк. Пожалуйста, ознакомьтесь с [документацией по `insert_deduplication_token`](/operations/settings/settings#insert_deduplication_token) для получения дополнительной информации о том, как использовать эту настройку.
