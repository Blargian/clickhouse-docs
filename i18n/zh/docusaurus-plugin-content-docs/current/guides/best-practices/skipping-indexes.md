import simple_skip from '@site/static/images/guides/best-practices/simple_skip.png';
import bad_skip from '@site/static/images/guides/best-practices/bad_skip.png';
import Image from '@theme/IdealImage';

# 理解 ClickHouse 数据跳过索引

## 介绍 {#introduction}

许多因素影响 ClickHouse 查询性能。大多数情况下，关键元素是 ClickHouse 是否能够在评估查询的 WHERE 子句条件时使用主键。因此，为最常见的查询模式选择一个适用的主键对有效的表设计至关重要。

然而，无论主键调优得多么仔细，仍然会不可避免地出现无法有效使用主键的查询用例。用户通常依赖 ClickHouse 处理时间序列类型数据，但他们通常希望根据其他业务维度（例如客户 ID、网站 URL 或产品编号）分析这些数据。在这种情况下，查询性能可能会大幅降低，因为可能需要对每个列值进行全扫描以应用 WHERE 子句条件。尽管在这些情况下 ClickHouse 仍然相对快速，但对数百万或数十亿个单独值的评估将导致“非索引”查询的执行速度比基于主键的查询慢得多。

在传统关系数据库中，解决此问题的一种方法是向表中附加一个或多个“二级”索引。这是一种 b 树结构，允许数据库以 O(log(n)) 的时间找到所有匹配的磁盘行，而不是 O(n) 时间（即表扫描），其中 n 是行数。然而，这种类型的二级索引在 ClickHouse（或其他列式数据库）中无法使用，因为磁盘上没有单独的行可以添加到索引中。

相反，ClickHouse 提供了一种不同类型的索引，在特定情况下可以显著提高查询速度。这些结构被称为“跳过”索引，因为它们使 ClickHouse 能够跳过读取保证没有匹配值的大量数据块。

## 基本操作 {#basic-operation}

用户只能在 MergeTree 家族的表上使用数据跳过索引。每个数据跳过索引有四个主要参数：

- 索引名称。索引名称用于在每个分区中创建索引文件。同时，在删除或物化索引时也需要作为参数使用。
- 索引表达式。索引表达式用于计算存储在索引中的值集。它可以是列、简单操作符和/或由索引类型确定的一组函数的组合。
- TYPE。索引的类型控制确定是否可以跳过读取和评估每个索引块的计算。
- GRANULARITY。每个索引块由 GRANULARITY 个粒度组成。例如，如果主表索引的粒度为 8192 行，而索引粒度为 4，则每个索引块将包含 32768 行。

当用户创建数据跳过索引时，每个数据部分目录中将有两个额外的文件。

- `skp_idx_{index_name}.idx`，包含有序的表达式值
- `skp_idx_{index_name}.mrk2`，包含相应的数据列文件中的偏移量。

如果在执行查询并读取相关列文件时，WHERE 子句过滤条件的某部分与跳过索引表达式匹配，ClickHouse 将使用索引文件数据来确定是否必须处理每个相关数据块，或者可以跳过（假设该块尚未通过应用主键排除）。为了使用一个非常简化的示例，考虑以下加载了可预测数据的表。

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

在执行一个不使用主键的简单查询时，将扫描 `my_value` 列中的全部 1 亿个条目：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.079 sec. Processed 100.00 million rows, 800.10 MB (1.26 billion rows/s., 10.10 GB/s.
```

现在添加一个非常基本的跳过索引：

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

通常，跳过索引仅应用于新插入的数据，因此仅添加索引不会影响上述查询。

要对已经存在的数据进行索引，请使用以下语句：

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

使用新创建的索引重新运行查询：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.051 sec. Processed 32.77 thousand rows, 360.45 KB (643.75 thousand rows/s., 7.08 MB/s.)
```

ClickHouse 只读取和分析了 32768 行的 360 千字节，而不是处理 800 兆字节的 1 亿行——四个各包含 8192 行的粒度。

以更直观的形式，这就是如何读取和选择 `my_value` 为 125 的 4096 行，以及如何跳过读取的后续行而不从磁盘读取：

<Image img={simple_skip} size="md" alt="Simple Skip"/>

用户可以通过在执行查询时启用跟踪来访问关于跳过索引使用的详细信息。从 clickhouse-client 设置 `send_logs_level`：

```sql
SET send_logs_level='trace';
```
这将提供在尝试调整查询 SQL 和表索引时有用的调试信息。在上述示例中，调试日志显示跳过索引丢弃了所有但两个粒度：

```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Index `vix` has dropped 6102/6104 granules.
```
## 跳过索引类型 {#skip-index-types}

### minmax {#minmax}

这种轻量级索引类型不需要参数。它为每个块存储索引表达式的最小值和最大值（如果表达式是元组，它会为元组的每个元素单独存储值）。这种类型非常适合那些值排序较松散的列。此索引类型通常在查询处理期间应用的成本最低。

这种类型的索引仅适用于标量或元组表达式——索引将永远不会应用于返回数组或映射数据类型的表达式。

### set {#set}

这种轻量级索引类型接受一个参数，即每个块的值集合的 max_size（0 允许无限数量的离散值）。该集合包含块中的所有值（如果值的数量超过 max_size 则为空）。这种索引类型在每个粒度集合中具有低基数的列上运行良好（本质上，“聚在一起”），但总体上具有更高的基数。

该索引的成本、性能和效果取决于块内的基数。如果每个块包含大量唯一值，则根据大索引集评估查询条件将非常昂贵，或者索引将无法应用，因为索引因超过 max_size 而为空。

### 布隆过滤器类型 {#bloom-filter-types}

*布隆过滤器*是一种数据结构，它以空间效率进行集合成员资格测试，代价是轻微的假阳性概率。在跳过索引的情况下，假阳性并不是一个重大问题，因为唯一的缺点是读取一些不必要的块。然而，假阳性的潜在可能意味着应该预期索引表达式为真，否则可能会跳过有效数据。

因为布隆过滤器能够更有效地处理对大量离散值的测试，它们可以适用于生成更多值以进行测试的条件表达式。特别是，布隆过滤器索引可以应用于数组，其中数组的每个值都被测试，并且可以通过使用 mapKeys 或 mapValues 函数将键或值转换为数组来应用于映射。

基于布隆过滤器有三种数据跳过索引类型：

* 基本的 **bloom_filter**，它接受一个可选参数，表示允许的“假阳性”率，在 0 和 1 之间（如果未指定，则使用 .025）。

* 专用的 **tokenbf_v1**。它接受三个参数，均与调优使用的布隆过滤器有关：（1）过滤器的大小（以字节为单位）（较大的过滤器假阳性较少，存储成本较高），（2）应用的哈希函数数量（同样，更多哈希过滤器减少假阳性），以及（3）布隆过滤器哈希函数的种子。有关这些参数如何影响布隆过滤器功能的更多细节，请参见计算器 [这里](https://hur.st/bloomfilter/)。
该索引仅适用于 String, FixedString 和 Map 数据类型。输入表达式被拆分为由非字母数字字符分隔的字符序列。例如，列值 `This is a candidate for a "full text" search` 将包含标记 `This` `is` `a` `candidate` `for` `full` `text` `search`。它旨在用于 LIKE, EQUALS, IN, hasToken() 等类似搜索，以查找较长字符串中的单词和其他值。例如，可能的一个用法可能是在自由格式应用日志行的列中搜索少量类名或行号。

* 专用的 **ngrambf_v1**。该索引的功能与 token 索引相同。在布隆过滤器设置之前，它接受一个额外的参数，指定要索引的 ngrams 的大小。ngram 是长度为 `n` 的字符字符串，包含任何字符，因此字符串 `A short string` 的 ngram 大小为 4 将被索引为：
```text
'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
```
该索引对于文本搜索也很有用，特别是对于没有单词间隔的语言，如中文。

## 跳过索引功能 {#skip-index-functions}

数据跳过索引的核心目的是限制热门查询分析的数据量。考虑到 ClickHouse 数据的分析性质，这些查询的模式在大多数情况下包括函数表达式。因此，跳过索引必须与常见函数正确交互以提高效率。这可以在以下情况下发生：
* 数据插入并且索引定义为功能表达式（表达式的结果存储在索引文件中），或
* 查询被处理，表达式应用于存储的索引值以确定是否排除该块。

每种类型的跳过索引在适合所列索引实现的 ClickHouse 函数的子集上工作 [这里](/engines/table-engines/mergetree-family/mergetree/#functions-support)。通常，set 索引和基于布隆过滤器的索引（另一种类型的 set 索引）都是无序的，因此不适用于范围。相比之下，minmax 索引对于范围的工作特别好，因为确定范围是否相交是非常快速的。部分匹配函数 LIKE、startsWith、endsWith 和 hasToken 的有效性取决于所使用的索引类型、索引表达式和数据的具体形状。

## 跳过索引设置 {#skip-index-settings}

有两个适用于跳过索引的可用设置。

* **use_skip_indexes** （0 或 1，默认 1）。并非所有查询都能有效地使用跳过索引。如果特定的过滤条件可能包含大多数粒度，则应用数据跳过索引会产生不必要的，有时是显著的成本。对不太可能从任何跳过索引中受益的查询，将值设置为 0。
* **force_data_skipping_indices** （用逗号分隔的索引名称列表）。该设置可用于防止某些种类的低效查询。在查询表过于昂贵，除非使用跳过索引的情况下，使用此设置并列出一个或多个索引名称将对任何不使用列出的索引的查询返回异常。这将防止书写不当的查询消耗服务器资源。

## 跳过最佳实践 {#skip-best-practices}

跳过索引并不直观，特别是对于习惯于传统关系数据库管理系统区域的基于行的二级索引或文档存储中的反向索引的用户。为了获得任何好处，应用 ClickHouse 数据跳过索引必须避免读入足够多的粒度，以抵消计算索引的成本。至关重要的是，如果某个值在索引块中出现即使只有一次，这意味着整个块必须读入内存并进行评估，而索引成本也因此无谓地产生。

考虑以下数据分布：

<Image img={bad_skip} size="md" alt="Bad Skip"/>

假设主键/顺序键为 `timestamp`，并且在 `visitor_id` 上有一个索引。考虑以下查询：

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001`
```

在这种数据分布下，传统的二级索引将非常有利。索引将只包括五个行位置，而不是读取全部 32768 行以找到请求的 visitor_id 的 5 行。 ClickHouse 数据跳过索引的情况正好相反。无论跳过索引的类型如何，`visitor_id` 列中的所有 32768 个值都将被测试。

因此，试图通过简单地将索引添加到关键列来加速 ClickHouse 查询的自然冲动往往是不正确的。这种高级功能应仅在调查其他替代方案后使用，例如修改主键（参见 [如何选择主键](../best-practices/sparse-primary-indexes.md)）、使用投影或使用物化视图。即使在适合使用数据跳过索引的情况下，仍然通常需要对索引和表进行仔细调整。

在大多数情况下，有用的跳过索引要求主键与目标的非主列/表达式之间存在强相关性。如果没有相关性（如上图所示），则在数千个值的块中至少有一行满足过滤条件的可能性很高，因此很少块会被跳过。相反，如果主键值（如一天中的时间）的范围与潜在索引列中的值（如电视观众年龄）强相关，则 minmax 类型的索引可能会有利。请注意，在插入数据时，通过在排序/ORDER BY 键中包含其他列，或者以将与主键相关的值组合在一起的方式批量插入，可能会提高这种相关性。例如，特定 site_id 的所有事件可以通过摄取过程组合并一起插入，即使主键是包含来自大量站点事件的时间戳。这将导致许多粒度只包含少数几个 site_id，因此在通过特定 site_id 值搜索时可以跳过许多块。

跳过索引的另一个好候选项是适用于高基数表达式，其中任何一个值在数据中相对稀疏。例如，某个观测平台跟踪 API 请求中的错误代码。某些错误代码虽然在数据中较少见，但对于搜索可能特别重要。对 error_code 列进行的集合跳过索引将允许绕过绝大多数不包含错误的块，因此显著提高专注于错误的查询。

最后，关键的最佳实践是测试、测试、再测试。同样，与用于搜索文档的 b 树二级索引或反向索引不同，数据跳过索引的行为并不容易预测。将它们添加到表中在数据摄取和因其他原因无法从索引中受益的查询上都产生了显著成本。它们应始终在真实环境的数据上进行测试，测试应包括类型、粒度大小和其他参数的变化。测试通常会揭示出仅凭思维实验并不明显的模式和陷阱。
