---
slug: /optimize/skipping-indexes
sidebar_label: 'データスキッピングインデックス'
sidebar_position: 2
description: 'スキップインデックスにより、ClickHouseは一致する値がないことが保証された大規模なデータの読み込みをスキップできます。'
title: 'ClickHouseデータスキッピングインデックスの理解'
---

import simple_skip from '@site/static/images/guides/best-practices/simple_skip.png';
import bad_skip from '@site/static/images/guides/best-practices/bad_skip.png';
import Image from '@theme/IdealImage';


# ClickHouseデータスキッピングインデックスの理解

## はじめに {#introduction}

多くの要因がClickHouseのクエリパフォーマンスに影響を与えます。ほとんどのシナリオにおいて重要な要素は、ClickHouseがクエリのWHERE句条件を評価する際に主キーを利用できるかどうかです。したがって、最も一般的なクエリパターンに適用される主キーを選択することは、効果的なテーブル設計において重要です。

それにもかかわらず、どんなに注意深く調整された主キーでも、効率的に利用できないクエリのユースケースは必然的に存在します。ユーザーは一般的にClickHouseを時系列データに依存していますが、同じデータを顧客ID、ウェブサイトのURL、製品番号など、他のビジネスディメンションに基づいて分析したいと考えることがよくあります。その場合、WHERE句条件を適用するために各カラム値の完全なスキャンが必要となることが多いため、クエリパフォーマンスはかなり悪化します。ClickHouseは依然としてこれらの状況では比較的速いものの、何百万、何十億もの個別の値を評価することは「非インデックス化された」クエリが主キーに基づくクエリよりもはるかに遅く実行される原因となります。

従来のリレーショナルデータベースにおいて、この問題に対する一つのアプローチは、テーブルに一つまたは複数の「セカンダリ」インデックスを追加することです。これはb-tree構造であり、データベースがディスク上で一致する行をO(log(n))の時間で見つけることを可能にします（ここでnは行数です）。しかし、このタイプのセカンダリインデックスは、ClickHouse（または他の列指向データベース）では機能しません。なぜなら、ディスク上のインデックスに追加する個別の行が存在しないためです。

代わりに、ClickHouseは特定の状況下でクエリ速度を大幅に改善する異なるタイプのインデックスを提供します。これらの構造は「スキップ」インデックスと呼ばれ、ClickHouseが一致する値がないことが保証された大規模なデータの読み込みをスキップできるようにします。

## 基本操作 {#basic-operation}

ユーザーはデータスキッピングインデックスをMergeTreeファミリーのテーブルでのみ使用できます。各データスキッピングには4つの主要な引数があります：

- インデックス名。インデックス名は各パーティションにインデックスファイルを作成するために使用されます。また、インデックスを削除またはマテリアライズする際に必要です。
- インデックス式。インデックス式はインデックスに保存される値のセットを計算するために使用されます。カラムの組み合わせ、単純な演算子、およびインデックスタイプによって決定される関数のサブセットで構成できます。
- TYPE。インデックスのタイプは、各インデックスブロックの読み込みと評価をスキップできるかどうかを決定する計算を制御します。
- GRANULARITY。各インデックス化されたブロックはGRANULARITYのグラニュールで構成されます。たとえば、主テーブルインデックスの粒度が8192行で、インデックス粒度が4の場合、各インデックス化された「ブロック」は32768行になります。

ユーザーがデータスキッピングインデックスを作成すると、テーブルの各データパーツディレクトリに2つの追加ファイルが作成されます。

- `skp_idx_{index_name}.idx`、このファイルには順序付けられた式の値が含まれます
- `skp_idx_{index_name}.mrk2`、このファイルには対応するデータカラムファイルへのオフセットが含まれます。

WHERE句フィルタリング条件の一部がクエリを実行し、関連するカラムファイルを読み込むときにスキップインデックス式に一致する場合、ClickHouseはインデックスファイルデータを使用して、関連するデータブロックを処理する必要があるかどうかを決定します（ブロックが主キーを適用して既に除外されていないと仮定します）。非常に単純化された例を考えてみましょう。以下は予測可能なデータで読み込まれたテーブルです。

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

主キーを使用しないシンプルなクエリを実行すると、`my_value`カラムの1億件のエントリがスキャンされます：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.079 sec. Processed 100.00 million rows, 800.10 MB (1.26 billion rows/s., 10.10 GB/s.)
```

次に、非常に基本的なスキップインデックスを追加します：

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

通常、スキップインデックスは新たに挿入されたデータにのみ適用されるため、単にインデックスを追加するだけでは上記のクエリに影響を与えません。

既存のデータにインデックスを付けるには、以下の文を使用します：

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

新しく作成されたインデックスでクエリを再実行します：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.051 sec. Processed 32.77 thousand rows, 360.45 KB (643.75 thousand rows/s., 7.08 MB/s.)
```

ClickHouseは800メガバイトの100百万行を処理する代わりに、わずか32768行の360キロバイトを読み取り、分析しました -- それぞれ8192行の4つのグラニュールです。

視覚的に言うと、以下のように`my_value`が125の4096行が読み取られ、次の行がディスクから読み込まずにスキップされました：

<Image img={simple_skip} size="md" alt="Simple Skip"/>

ユーザーは、クエリを実行する際にトレースを有効にすることで、スキップインデックスの使用に関する詳細情報にアクセスできます。clickhouse-clientから、`send_logs_level`を設定します：

```sql
SET send_logs_level='trace';
```
これにより、クエリSQLとテーブルインデックスを調整する際に役立つデバッグ情報が得られます。上記の例から、デバッグログはスキップインデックスが6102/6104のグラニュールを削除したことを示しています：

```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Index `vix` has dropped 6102/6104 granules.
```

## スキップインデックスタイプ {#skip-index-types}

### minmax {#minmax}

この軽量インデックスタイプにはパラメータは不要です。各ブロックのインデックス式の最小値と最大値を保存します（式がタプルである場合、タプルの各メンバーの値を個別に保存します）。このタイプは、値によって緩やかにソートされる傾向があるカラムに理想的です。このインデックスタイプは、クエリ処理中に適用するコストが最も低いことが一般的です。

このタイプのインデックスは、スカラ式またはタプル式でのみ正しく機能します -- 配列やマップデータ型を返す式には決して適用されません。

### set {#set}

この軽量インデックスタイプは、各ブロックごとの値のセットの最大サイズの単一パラメータを受け入れます（0は無制限の離散値を許可します）。このセットはブロック内のすべての値を含みます（または、値の数がmax_sizeを超える場合は空になります）。このインデックスタイプは、各グラニュール内の低い基本数のカラムでよく機能します（本質的には「まとまっている」）が、全体としては高い基本数である場合に適しています。

このインデックスのコスト、パフォーマンス、効果は、ブロック内の基本数に依存します。各ブロックに多くのユニークな値が含まれている場合、クエリ条件を大きなインデックスセットに対して評価するコストが非常に高くなるか、max_sizeを超えたためインデックスが空になって適用されないかのいずれかになります。

### ブルームフィルタタイプ {#bloom-filter-types}

*ブルームフィルタ*は、わずかな確率で誤陽性を伴うセットのメンバーシップを空間効率よくテストできるデータ構造です。誤陽性は、スキップインデックスの場合はあまり重要ではない問題です。なぜなら、唯一の欠点は、いくつかの不要なブロックを読み込むことだからです。しかし、誤陽性の可能性があるため、インデックス化された式が真であることが期待されるべきです。そうでなければ、正当なデータがスキップされる可能性があります。

ブルームフィルタは、多くの離散値のテストをより効率的に処理できるため、より多くの値をテストする条件式に適している場合があります。特に、ブルームフィルタインデックスは、配列に適用でき、その配列のすべての値をテストし、マップに対してはmapKeysまたはmapValues関数を使用してキーまたは値を配列に変換することで適用できます。

ブルームフィルタに基づいたデータスキッピングインデックスタイプは3つあります：

* 基本的な**bloom_filter**は、許可される「誤陽性」率の単一のオプションのパラメータを受け取ります（指定しない場合は0.025が使用されます）。

* 専用の**tokenbf_v1**。これは、ブルームフィルタをチューニングするために関連する3つのパラメータを受け取ります：(1)フィルタのサイズ（バイト単位）（大きなフィルタは、ストレージのコストがかかるが、誤陽性が少なくなります）、(2)適用されるハッシュ関数の数（より多くのハッシュフィルタは誤陽性を減少させます）、および(3)ブルームフィルタハッシュ関数のシード。このパラメータがブルームフィルタ機能に与える影響についての詳細は、[こちら](https://hur.st/bloomfilter/)を参照してください。このインデックスは、String、FixedString、およびMapデータ型でのみ機能します。入力式は、非英数字の文字で区切られた文字列シーケンスに分解されます。たとえば、`This is a candidate for a "full text" search`というカラム値は、トークン`This` `is` `a` `candidate` `for` `full` `text` `search`を含みます。LIKE、EQUALS、IN、hasToken()のような単語や他の値を長い文字列の中で検索するためなどに使用することを予定しています。たとえば、特定の少数のクラス名や行番号をフリーフォームのアプリケーションログ行のカラムで検索する場合などです。

* 専用の**ngrambf_v1**。このインデックスは、トークンインデックスと同様に機能します。ブルームフィルタ設定の前にインデックス化するngramのサイズという追加のパラメータを1つ受け取ります。ngramは、任意の文字の長さ`n`の文字列です。たとえば、`A short string`という文字列は、ngramサイズ4で以下のようにインデックス化されます：
  ```text
  'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
  ```
このインデックスは、特に単語の区切りがない言語（例えば中国語）のテキスト検索に有用です。

## スキップインデックス関数 {#skip-index-functions}

データスキッピングインデックスの主目的は、一般的なクエリによって分析されるデータ量を制限することです。ClickHouseデータの解析的な性質を考慮すると、ほとんどの場合、これらのクエリのパターンには機能式が含まれています。したがって、スキップインデックスは、次のいずれかの条件を満たす場合に、一般的な関数と正しく相互作用する必要があります：
* データが挿入され、インデックスが機能式として定義されている場合（式の結果がインデックスファイルに保存されます）、または
* クエリが処理され、式が保存されたインデックス値に適用されてブロックを除外するかどうかを決定する場合。

各タイプのスキップインデックスは、インデックス実装に適した利用可能なClickHouse関数のサブセット上で機能します。一般的に、セットインデックスおよびブルームフィルタに基づくインデックス（別のセットインデックスのタイプ）は、いずれも順不同であるため、範囲には機能しません。対照的に、minmaxインデックスは範囲での判定が非常に速いため、特によく機能します。部分一致関数LIKE、startsWith、endsWith、hasTokenの有効性は、使用されるインデックスタイプ、インデックス式、およびデータの特定の形状に依存します。

## スキップインデックス設定 {#skip-index-settings}

スキップインデックスに適用される2つの設定があります。

* **use_skip_indexes**  (0または1、デフォルトは1)。すべてのクエリがスキップインデックスを効率的に使用できるわけではありません。特定のフィルタリング条件がほとんどのグラニュールを含む可能性が高い場合、データスキッピングインデックスを適用することは、不必要なコストを伴う場合があります。そのため、スキップインデックスの恩恵を受ける可能性が低いクエリには、値を0に設定してください。
* **force_data_skipping_indices** (コンマ区切りのインデックス名のリスト)。この設定は、ある種の非効率なクエリを防ぐために使用されます。スキップインデックスを使用しない場合、テーブルに対するクエリが高コストになる状況では、この設定を1つまたは複数のインデックス名と共に使用することで、指定されたインデックスを使用しないクエリに対して例外を返します。これにより、適切に書かれていないクエリがサーバーリソースを消費するのを防ぎます。

## スキップのベストプラクティス {#skip-best-practices}

スキップインデックスは直感的ではなく、特にRDMSのセカンダリ行ベースインデックスやドキュメントストアの反転インデックスに慣れているユーザーにとっては難しいです。利益を得るためには、ClickHouseデータスキッピングインデックスを適用することは、インデックス計算のコストをオフセットするために十分なグラニュールの読み取りを避けなければなりません。重要なことは、インデックスが適用されたブロック内の値が1回でも発生する場合、ブロック全体をメモリに読み込み評価する必要があり、インデックスコストが無駄に発生してしまうことです。

以下のデータ分布を考えてみましょう：

<Image img={bad_skip} size="md" alt="Bad Skip"/>

主/オーダーキーが`timestamp`であり、`visitor_id`にインデックスがあると仮定します。次のクエリを考察します：

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001
```

このデータ分布では、従来のセカンダリインデックスが非常に有利です。要求されたvisitor_idを持つ5行を見つけるために32768行全てを読み込む代わりに、セカンダリインデックスはわずか5つの行位置を含むことになります。したがって、ディスクからはその5行のみが読み込まれます。ClickHouseデータスキッピングインデックスの場合は正反対です。スキップインデックスのタイプに関係なく、`visitor_id`カラムのすべての32768値がテストされます。

そのため、主キーのカラムにインデックスを単純に追加してClickHouseクエリを高速化しようとする自然な衝動は、しばしば誤りです。この高度な機能は、主キーを変更することや、プロジェクションの使用、マテリアライズドビューの使用など、他の代替案を調査した後にのみ使用すべきです。データスキッピングインデックスが適切であっても、インデックスとテーブルの両方の慎重な調整がしばしば必要です。

ほとんどの場合、有益なスキップインデックスは主キーと対象の非主キーのカラム/式との間に強い相関関係を必要とします。相関関係がない場合（上図のように）、フィルタリング条件がブロック内の数千の値で少なくとも1つの行に満たされる可能性が高く、ほとんどのブロックがスキップされません。対照的に、主キーの値の範囲（例えば、一日の時間）が潜在的なインデックスカラム（テレビ視聴者の年齢など）の値と強く関連している場合、minmaxタイプのインデックスは有益である可能性があります。この相関関係は、データの挿入時に、ソートキーに追加のカラムを含めるか、主キーに関連する値をグループ化して挿入することで増加させることができるかもしれません。たとえば、特定のsite_idのすべてのイベントが、主キーが多くのサイトからのイベントを含んでいる場合でも、インジェストプロセスによってグループ化して一緒に挿入される可能性があります。これにより、特定のsite_id値を検索する際に、多くのブロックをスキップできるようになります。

スキップインデックスにとってもう1つの良い候補は、高い基本数の式です。この場合、1つの値がデータに対して比較的スパースです。1つの例は、APIリクエストのエラーコードを追跡する監視プラットフォームです。特定のエラーコードは、データ内では稀であるものの、特に検索で重要かもしれません。エラーコードカラムに対するセットスキップインデックスを作成することにより、エラーが含まれない大部分のブロックをバイパスし、したがってエラーを焦点としたクエリを大幅に改善できます。

最終的な重要なベストプラクティスは、テストを繰り返すことです。b-treeセカンダリインデックスや文書検索用の反転インデックスとは異なり、データスキッピングインデックスの動作は容易には予測できません。これらをテーブルに追加することは、データの取り込みや、いかなる理由でインデックスから利益を得ないクエリに対して、有意義なコストを伴います。それらは常に実世界のデータタイプでテストされるべきであり、テストにはタイプ、粒度サイズ、他のパラメータの変化が含まれるべきです。テストは、思考実験だけでは明らかでないパターンや落とし穴を明らかにすることがしばしばあります。
