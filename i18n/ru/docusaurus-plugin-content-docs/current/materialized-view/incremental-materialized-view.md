---
slug: /materialized-view/incremental-materialized-view
title: 'Инкрементное Материализованное Представление'
description: 'Как использовать инкрементные материализованные представления для ускорения запросов'
keywords: ['инкрементные материализованные представления', 'ускорение запросов', 'оптимизация запросов']
score: 10000
---

import materializedViewDiagram from '@site/static/images/materialized-view/materialized-view-diagram.png';
import Image from '@theme/IdealImage';


# Инкрементные Материализованные Представления

Инкрементные Материализованные Представления (Materialized Views) позволяют пользователям перенести стоимость вычислений с времени запроса на время вставки, что приводит к более быстрому выполнению запросов `SELECT`.

В отличие от транзакционных баз данных, таких как Postgres, материализованное представление в ClickHouse является просто триггером, который выполняет запрос к блокам данных по мере их вставки в таблицу. Результат этого запроса вставляется во вторую "целевую" таблицу. Если будут вставлены дополнительные строки, результаты снова будут отправлены в целевую таблицу, где промежуточные результаты будут обновлены и объединены. Этот объединенный результат эквивалентен выполнению запроса над всеми исходными данными.

Основная мотивация для материализованных представлений заключается в том, что результаты, вставляемые в целевую таблицу, представляют собой результаты агрегации, фильтрации или преобразования строк. Эти результаты часто будут меньшим представлением исходных данных (частичная выборка в случае агрегации). Это, наряду с тем, что конечный запрос для чтения результатов из целевой таблицы является простым, гарантирует время выполнения запросов быстрее, чем если бы те же вычисления выполнялись над исходными данными, переносит вычисления (а вместе с ними и задержку запросов) с времени запроса на время вставки.

Материализованные представления в ClickHouse обновляются в реальном времени по мере поступления данных в таблицу, на которой они основаны, функционируя больше как постоянно обновляемые индексы. Это в контрасте с другими базами данных, где материализованные представления обычно являются статичными снимками запроса, которые должны быть обновлены (похожие на [обновляемые материализованные представления](/sql-reference/statements/create/view#refreshable-materialized-view) ClickHouse).

<Image img={materializedViewDiagram} size="md" alt="Диаграмма материализованного представления"/>

## Пример {#example}

Предположим, мы хотим получить количество голосов "за" и "против" в день для поста.

```sql
CREATE TABLE votes
(
    `Id` UInt32,
    `PostId` Int32,
    `VoteTypeId` UInt8,
    `CreationDate` DateTime64(3, 'UTC'),
    `UserId` Int32,
    `BountyAmount` UInt8
)
ENGINE = MergeTree
ORDER BY (VoteTypeId, CreationDate, PostId)

INSERT INTO votes SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/votes/*.parquet')

0 rows in set. Elapsed: 29.359 sec. Processed 238.98 million rows, 2.13 GB (8.14 million rows/s., 72.45 MB/s.)
```

Этот запрос достаточно прост в ClickHouse благодаря функции [`toStartOfDay`](/sql-reference/functions/date-time-functions#tostartofday):

```sql
SELECT toStartOfDay(CreationDate) AS day,
       countIf(VoteTypeId = 2) AS UpVotes,
       countIf(VoteTypeId = 3) AS DownVotes
FROM votes
GROUP BY day
ORDER BY day ASC
LIMIT 10

┌─────────────────day─┬─UpVotes─┬─DownVotes─┐
│ 2008-07-31 00:00:00 │       6 │         0 │
│ 2008-08-01 00:00:00 │     182 │        50 │
│ 2008-08-02 00:00:00 │     436 │       107 │
│ 2008-08-03 00:00:00 │     564 │       100 │
│ 2008-08-04 00:00:00 │    1306 │       259 │
│ 2008-08-05 00:00:00 │    1368 │       269 │
│ 2008-08-06 00:00:00 │    1701 │       211 │
│ 2008-08-07 00:00:00 │    1544 │       211 │
│ 2008-08-08 00:00:00 │    1241 │       212 │
│ 2008-08-09 00:00:00 │     576 │        46 │
└─────────────────────┴─────────┴───────────┘

10 rows in set. Elapsed: 0.133 sec. Processed 238.98 million rows, 2.15 GB (1.79 billion rows/s., 16.14 GB/s.)
Peak memory usage: 363.22 MiB.
```

Этот запрос уже быстрый благодаря ClickHouse, но можем ли мы сделать лучше?

Если мы хотим вычислить это время вставки с помощью материализованного представления, нам нужна таблица для получения результатов. Эта таблица должна хранить только 1 строку на день. Если поступает обновление для существующего дня, другие столбцы должны быть объединены с существующей строкой того дня. Для того чтобы произошло это объединение инкрементальных состояний, частичные состояния должны храниться для других столбцов.

Это требует специального типа движка в ClickHouse: [SummingMergeTree](/engines/table-engines/mergetree-family/summingmergetree). Он заменяет все строки с одинаковым ключом сортировки одной строкой, которая содержит сумма значений для числовых столбцов. Следующая таблица объединит любые строки с одной и той же датой, суммируя любые числовые столбцы:

```sql
CREATE TABLE up_down_votes_per_day
(
  `Day` Date,
  `UpVotes` UInt32,
  `DownVotes` UInt32
)
ENGINE = SummingMergeTree
ORDER BY Day
```

Чтобы продемонстрировать наше материализованное представление, предположим, что наша таблица голосов пуста и еще не получила никаких данных. Наше материализованное представление выполняет вышеуказанный `SELECT` на данных, вставленных в `votes`, и результаты отправляются в `up_down_votes_per_day`:

```sql
CREATE MATERIALIZED VIEW up_down_votes_per_day_mv TO up_down_votes_per_day AS
SELECT toStartOfDay(CreationDate)::Date AS Day,
       countIf(VoteTypeId = 2) AS UpVotes,
       countIf(VoteTypeId = 3) AS DownVotes
FROM votes
GROUP BY Day
```

Клаузula `TO` здесь имеет ключевое значение, указывая, куда будут отправлены результаты, т.е. в `up_down_votes_per_day`.

Мы можем восстановить нашу таблицу голосов из нашей предыдущей вставки:

```sql
INSERT INTO votes SELECT toUInt32(Id) AS Id, toInt32(PostId) AS PostId, VoteTypeId, CreationDate, UserId, BountyAmount
FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/votes/*.parquet')

0 rows in set. Elapsed: 111.964 sec. Processed 477.97 million rows, 3.89 GB (4.27 million rows/s., 34.71 MB/s.)
Peak memory usage: 283.49 MiB.
```

По завершении мы можем подтвердить размер нашего `up_down_votes_per_day` - у нас должна быть 1 строка на день:

```sql
SELECT count()
FROM up_down_votes_per_day
FINAL

┌─count()─┐
│    5723 │
└─────────┘
```

Мы эффективно снизили количество строк здесь с 238 миллионов (в `votes`) до 5000, храня результат нашего запроса. Ключевым здесь, однако, является то, что если новые голоса будут вставлены в таблицу `votes`, новые значения будут отправлены в `up_down_votes_per_day` за их соответствующий день, где они будут автоматически объединены асинхронно в фоновом режиме - сохраняя только одну строку на день. Таким образом, `up_down_votes_per_day` всегда будет как малым, так и актуальным.

Поскольку процесс объединения строк является асинхронным, может быть больше одного голоса на день, когда пользователь выполняет запрос. Чтобы гарантировать, что любые ожидающие строки будут объединены во время выполнения запроса, у нас есть два варианта:

- Использовать модификатор `FINAL` в имени таблицы. Мы сделали это для запроса количества выше.
- Агрегировать по ключу сортировки, используемому в нашей целевой таблице, т.е. `CreationDate` и суммировать метрики. Обычно это более эффективно и гибко (таблица может использоваться для других целей), но первый вариант может быть проще для некоторых запросов. Мы показываем оба ниже:

```sql
SELECT
        Day,
        UpVotes,
        DownVotes
FROM up_down_votes_per_day
FINAL
ORDER BY Day ASC
LIMIT 10

10 rows in set. Elapsed: 0.004 sec. Processed 8.97 thousand rows, 89.68 KB (2.09 million rows/s., 20.89 MB/s.)
Peak memory usage: 289.75 KiB.

SELECT Day, sum(UpVotes) AS UpVotes, sum(DownVotes) AS DownVotes
FROM up_down_votes_per_day
GROUP BY Day
ORDER BY Day ASC
LIMIT 10
┌────────Day─┬─UpVotes─┬─DownVotes─┐
│ 2008-07-31 │       6 │         0 │
│ 2008-08-01 │     182 │        50 │
│ 2008-08-02 │     436 │       107 │
│ 2008-08-03 │     564 │       100 │
│ 2008-08-04 │    1306 │       259 │
│ 2008-08-05 │    1368 │       269 │
│ 2008-08-06 │    1701 │       211 │
│ 2008-08-07 │    1544 │       211 │
│ 2008-08-08 │    1241 │       212 │
│ 2008-08-09 │     576 │        46 │
└────────────┴─────────┴───────────┘

10 rows in set. Elapsed: 0.010 sec. Processed 8.97 thousand rows, 89.68 KB (907.32 thousand rows/s., 9.07 MB/s.)
Peak memory usage: 567.61 KiB.
```

Это ускорило наш запрос с 0.133с до 0.004с — более чем на 25 раз!

:::important Важно: `ORDER BY` = `GROUP BY`
В большинстве случаев столбцы, используемые в клаузуле `GROUP BY` преобразования материализованных представлений, должны совпадать с теми, которые используются в клаузуле `ORDER BY` целевой таблицы, если используются движки таблиц `SummingMergeTree` или `AggregatingMergeTree`. Эти движки полагаются на столбцы `ORDER BY` для объединения строк с одинаковыми значениями во время фоновых операций объединения. Несогласованность между столбцами `GROUP BY` и `ORDER BY` может привести к неэффективному выполнению запросов, плохим объединениям или даже несоответствию данных.
:::

### Более сложный пример {#a-more-complex-example}

В приведенном выше примере используются материализованные представления для вычисления и поддержания двух сумм на день. Суммы представляют собой самую простую форму агрегации для поддержания частичных состояний — мы можем просто добавлять новые значения к существующим, когда они поступают. Однако материализованные представления ClickHouse могут использоваться для любого типа агрегации.

Предположим, мы желаем вычислить некоторые статистические данные для постов за каждый день: 99,9-й процентиль для `Score` и среднее значение `CommentCount`. Запрос для вычисления этого может выглядеть следующим образом:

```sql
SELECT
        toStartOfDay(CreationDate) AS Day,
        quantile(0.999)(Score) AS Score_99th,
        avg(CommentCount) AS AvgCommentCount
FROM posts
GROUP BY Day
ORDER BY Day DESC
LIMIT 10

    ┌─────────────────Day─┬────────Score_99th─┬────AvgCommentCount─┐
 1. │ 2024-03-31 00:00:00 │  5.23700000000008 │ 1.3429811866859624 │
 2. │ 2024-03-30 00:00:00 │                 5 │ 1.3097158891616976 │
 3. │ 2024-03-29 00:00:00 │  5.78899999999976 │ 1.2827635327635327 │
 4. │ 2024-03-28 00:00:00 │                 7 │  1.277746158224246 │
 5. │ 2024-03-27 00:00:00 │ 5.738999999999578 │ 1.2113264918282023 │
 6. │ 2024-03-26 00:00:00 │                 6 │ 1.3097536945812809 │
 7. │ 2024-03-25 00:00:00 │                 6 │ 1.2836721018539201 │
 8. │ 2024-03-24 00:00:00 │ 5.278999999999996 │ 1.2931667891256429 │
 9. │ 2024-03-23 00:00:00 │ 6.253000000000156 │  1.334061135371179 │
10. │ 2024-03-22 00:00:00 │ 9.310999999999694 │ 1.2388059701492538 │
    └─────────────────────┴───────────────────┴────────────────────┘

10 rows in set. Elapsed: 0.113 sec. Processed 59.82 million rows, 777.65 MB (528.48 million rows/s., 6.87 GB/s.)
Peak memory usage: 658.84 MiB.
```

Как и ранее, мы можем создать материализованное представление, которое выполняет вышеуказанный запрос по мере вставки новых постов в нашу таблицу `posts`.

В целях примера и чтобы избежать загрузки данных постов из S3, мы создадим дубликат таблицы `posts_null` с той же схемой, что и `posts`. Однако эта таблица не будет хранить никаких данных и будет использоваться только материализованным представлением, когда строки вставляются. Чтобы предотвратить хранение данных, мы можем использовать тип движка таблицы [`Null`](/engines/table-engines/special/null).

```sql
CREATE TABLE posts_null AS posts ENGINE = Null
```

Движок таблицы Null является мощной оптимизацией - думайте об этом как о `/dev/null`. Наше материализованное представление будет вычислять и хранить наши сводные статистические данные, когда в таблицу `posts_null` поступают строки во время вставки - это просто триггер. Однако исходные данные не будут храниться. Хотя в нашем случае, вероятно, мы все же хотим хранить оригинальные посты, этот подход может быть использован для вычисления агрегатов, избегая затрат на хранение исходных данных.

Таким образом, материализованное представление становится следующим:

```sql
CREATE MATERIALIZED VIEW post_stats_mv TO post_stats_per_day AS
       SELECT toStartOfDay(CreationDate) AS Day,
       quantileState(0.999)(Score) AS Score_quantiles,
       avgState(CommentCount) AS AvgCommentCount
FROM posts_null
GROUP BY Day
```

Обратите внимание, как мы добавляем суффикс `State` в конец наших агрегатных функций. Это обеспечивает возврат агрегированного состояния функции, а не итогового результата. Это будет содержать дополнительную информацию, чтобы позволить этому частичному состоянию объединяться с другими состояниями. Например, в случае средней величины это будет включать количество и сумму столбца.

> Частичные состояния агрегации необходимы для вычисления правильных результатов. Например, для вычисления среднего арифметического просто усреднение средних арифметических поддиапазонов дает некорректные результаты.

Теперь мы создадим целевую таблицу для этого представления `post_stats_per_day`, которая хранит эти частичные агрегированные состояния:

```sql
CREATE TABLE post_stats_per_day
(
  `Day` Date,
  `Score_quantiles` AggregateFunction(quantile(0.999), Int32),
  `AvgCommentCount` AggregateFunction(avg, UInt8)
)
ENGINE = AggregatingMergeTree
ORDER BY Day
```

В то время как ранее `SummingMergeTree` был достаточен для хранения счетчиков, нам требуется более продвинутый тип движка для других функций: [`AggregatingMergeTree`](/engines/table-engines/mergetree-family/aggregatingmergetree).
Чтобы обеспечить ClickHouse знанием о том, что будут храниться агрегированные состояния, мы определяем `Score_quantiles` и `AvgCommentCount` как тип `AggregateFunction`, указывая функцию источника частичных состояний и тип их исходных столбцов. Как и в случае с `SummingMergeTree`, строки с одинаковым значением ключа `ORDER BY` будут объединены (в приведенном выше примере — `Day`).

Чтобы заполнить нашу `post_stats_per_day` с помощью нашего материализованного представления, мы можем просто вставить все строки из `posts` в `posts_null`:

```sql
INSERT INTO posts_null SELECT * FROM posts

0 rows in set. Elapsed: 13.329 sec. Processed 119.64 million rows, 76.99 GB (8.98 million rows/s., 5.78 GB/s.)
```

> На практике вы, вероятно, прикрепите материализованное представление к таблице `posts`. Мы использовали `posts_null` здесь, чтобы продемонстрировать нулевую таблицу.

Наш окончательный запрос должен использовать суффикс `Merge` для наших функций (так как столбцы хранят частичные состояния агрегации):

```sql
SELECT
        Day,
        quantileMerge(0.999)(Score_quantiles),
        avgMerge(AvgCommentCount)
FROM post_stats_per_day
GROUP BY Day
ORDER BY Day DESC
LIMIT 10
```

Обратите внимание, что мы используем `GROUP BY` здесь вместо использования `FINAL`.

## Использование исходной таблицы в фильтрах и соединениях в материализованных представлениях {#using-source-table-in-filters-and-joins-in-materialized-views}

При работе с материализованными представлениями в ClickHouse важно понимать, как исходная таблица обрабатывается во время выполнения запроса материализованного представления. В частности, исходная таблица в запросе материализованного представления заменяется вставленным блоком данных. Это поведение может привести к некоторым неожиданным результатам, если его неправильно понять.

### Пример сценария {#example-scenario}

Рассмотрим следующую настройку:

```sql
CREATE TABLE t0 (`c0` Int) ENGINE = Memory;
CREATE TABLE mvw1_inner (`c0` Int) ENGINE = Memory;
CREATE TABLE mvw2_inner (`c0` Int) ENGINE = Memory;

CREATE VIEW vt0 AS SELECT * FROM t0;

CREATE MATERIALIZED VIEW mvw1 TO mvw1_inner
AS SELECT count(*) AS c0
    FROM t0
    LEFT JOIN ( SELECT * FROM t0 ) AS x ON t0.c0 = x.c0;


CREATE MATERIALIZED VIEW mvw2 TO mvw2_inner
AS SELECT count(*) AS c0
    FROM t0
    LEFT JOIN vt0 ON t0.c0 = vt0.c0;

INSERT INTO t0 VALUES (1),(2),(3);

INSERT INTO t0 VALUES (1),(2),(3),(4),(5);

SELECT * FROM mvw1;
   ┌─c0─┐
1. │  3 │
2. │  5 │
   └────┘

SELECT * FROM mvw2;
   ┌─c0─┐
1. │  3 │
2. │  8 │
   └────┘
```

### Объяснение {#explanation}

В приведенном выше примере у нас есть два материализованных представления `mvw1` и `mvw2`, которые выполняют похожие операции, но с небольшим отличием в том, как они ссылаются на исходную таблицу `t0`.

В `mvw1` таблица `t0` напрямую ссылается внутри подзапроса `(SELECT * FROM t0)` с правой стороны соединения. Когда данные вставляются в `t0`, запрос материализованного представления выполняется с вставленным блоком данных, заменяющим `t0`. Это означает, что операция соединения выполняется только над вновь вставленными строками, а не над всей таблицей.

Во втором случае с объединением `vt0` представление читает все данные из `t0`. Это гарантирует, что операция соединения учитывает все строки в `t0`, а не только вновь вставленный блок.

### Почему это работает именно так {#why-this-works-like-that}

Ключевое отличие заключается в том, как ClickHouse обрабатывает исходную таблицу в запросе материализованного представления. Когда материализованное представление активируется вставкой, исходная таблица (`t0` в этом случае) заменяется вставленным блоком данных. Это поведение можно использовать для оптимизации запросов, но также требует тщательного внимания, чтобы избежать неожиданных результатов.

### Сценарии использования и предостережения {#use-cases-and-caveats}

На практике вы можете использовать это поведение для оптимизации материализованных представлений, которым нужно обрабатывать только подмножество данных исходной таблицы. Например, вы можете использовать подзапрос для фильтрации исходной таблицы перед объединением с другими таблицами. Это может помочь уменьшить объем данных, обрабатываемых материализованным представлением, и улучшить производительность.

```sql
CREATE TABLE t0 (id UInt32, value String) ENGINE = MergeTree() ORDER BY id;
CREATE TABLE t1 (id UInt32, description String) ENGINE = MergeTree() ORDER BY id;
INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');

CREATE TABLE mvw1_target_table (id UInt32, value String, description String) ENGINE = MergeTree() ORDER BY id;

CREATE MATERIALIZED VIEW mvw1 TO mvw1_target_table AS
SELECT t0.id, t0.value, t1.description
FROM t0
JOIN (SELECT * FROM t1 WHERE t1.id IN (SELECT id FROM t0)) AS t1
ON t0.id = t1.id;
```

В этом примере набор, создаваемый из подзапроса `IN (SELECT id FROM t0)`, имеет только вновь вставленные строки, что может помочь отфильтровать `t1` по этому критерию.

## Другие применения {#other-applications}

Вышеописанное в основном сосредоточено на использовании материализованных представлений для инкрементного обновления частичных агрегатов данных, таким образом перемещая вычисления с времени запроса на время вставки. За пределами этого общего случая использования, материализованные представления имеют ряд других применений.

### Фильтрация и преобразование {#filtering-and-transformation}

В некоторых ситуациях мы можем пожелать вставлять только подмножество строк и столбцов при вставке. В этом случае наша таблица `posts_null` могла бы принимать вставки, с запросом `SELECT`, отфильтровывающим строки перед вставкой в таблицу `posts`. Например, предположим, что мы желаем преобразовать столбец `Tags` в нашей таблице `posts`. Он содержит список имен тегов, разделённых трубой. Преобразовав их в массив, мы можем легче агрегировать по отдельным значениям тегов.

> Мы могли бы выполнить это преобразование при выполнении операции `INSERT INTO SELECT`. Материализованное представление позволяет нам инкапсулировать эту логику в DDL ClickHouse и упростить наш `INSERT`, применяя преобразование к любым новым строкам.

Наше материализованное представление для этого преобразования показано ниже:

```sql
CREATE MATERIALIZED VIEW posts_mv TO posts AS
        SELECT * EXCEPT Tags, arrayFilter(t -> (t != ''), splitByChar('|', Tags)) as Tags FROM posts_null
```

### Таблица справки {#lookup-table}

Пользователи должны учитывать свои модели доступа при выборе ключа сортировки ClickHouse, используя столбцы, которые часто используются в фильтрах и агрегациях. Это может быть ограничивающим фактором для сценариев, когда у пользователей есть более разнообразные модели доступа, которые нельзя закодировать в одном наборе столбцов. Например, рассмотрим следующую таблицу `comments`:

```sql
CREATE TABLE comments
(
        `Id` UInt32,
        `PostId` UInt32,
        `Score` UInt16,
        `Text` String,
        `CreationDate` DateTime64(3, 'UTC'),
        `UserId` Int32,
        `UserDisplayName` LowCardinality(String)
)
ENGINE = MergeTree
ORDER BY PostId

0 rows in set. Elapsed: 46.357 sec. Processed 90.38 million rows, 11.14 GB (1.95 million rows/s., 240.22 MB/s.)
```

Ключ сортировки здесь оптимизирует таблицу для запросов, фильтрующих по `PostId`.

Предположим, пользователь хочет отфильтровать по конкретному `UserId` и вычислить их средний `Score`:

```sql
SELECT avg(Score)
FROM comments
WHERE UserId = 8592047

   ┌──────────avg(Score)─┐
1. │ 0.18181818181818182 │
   └─────────────────────┘

1 row in set. Elapsed: 0.778 sec. Processed 90.38 million rows, 361.59 MB (116.16 million rows/s., 464.74 MB/s.)
Peak memory usage: 217.08 MiB.
```

Хотя это быстро (данные малы для ClickHouse), мы можем понять, что это требует полной проверки таблицы, исходя из числа обработанных строк - 90.38 миллионов. Для более крупных наборов данных мы можем использовать материализованное представление, чтобы получить значения ключа сортировки `PostId` для фильтрации по столбцу `UserId`. Эти значения затем могут быть использованы для выполнения эффективного поиска.

В этом примере наше материализованное представление может быть очень простым, выбирая только `PostId` и `UserId` из `comments` при вставке. Эти результаты отправляются в таблицу `comments_posts_users`, которая упорядочена по `UserId`. Мы создаем нулевую версию таблицы `Comments` ниже и используем её, чтобы заполнить наше представление и таблицу `comments_posts_users`:

```sql
CREATE TABLE comments_posts_users (
  PostId UInt32,
  UserId Int32
) ENGINE = MergeTree ORDER BY UserId


CREATE TABLE comments_null AS comments
ENGINE = Null

CREATE MATERIALIZED VIEW comments_posts_users_mv TO comments_posts_users AS
SELECT PostId, UserId FROM comments_null

INSERT INTO comments_null SELECT * FROM comments

0 rows in set. Elapsed: 5.163 sec. Processed 90.38 million rows, 17.25 GB (17.51 million rows/s., 3.34 GB/s.)
```

Теперь мы можем использовать это представление в подзапросе, чтобы ускорить наш предыдущий запрос:

```sql
SELECT avg(Score)
FROM comments
WHERE PostId IN (
        SELECT PostId
        FROM comments_posts_users
        WHERE UserId = 8592047
) AND UserId = 8592047


   ┌──────────avg(Score)─┐
1. │ 0.18181818181818182 │
   └─────────────────────┘

1 row in set. Elapsed: 0.012 sec. Processed 88.61 thousand rows, 771.37 KB (7.09 million rows/s., 61.73 MB/s.)
```

### Цепочки {#chaining}

Материализованные представления могут быть соединены в цепочки, позволяя установить сложные рабочие процессы. Для практического примера мы рекомендуем этот [блог](https://clickhouse.com/blog/chaining-materialized-views).
