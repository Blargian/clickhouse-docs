---
slug: /development/style
sidebar_position: 70
sidebar_label: C++ スタイルガイド
---

# C++ スタイルガイド

## 一般的な推奨事項 {#general-recommendations}

以下は推奨事項であり、必須事項ではありません。
コードを編集する際には、既存のコードのフォーマットに従うことが理にかなっています。
コードスタイルは一貫性のために必要です。一貫性があることで、コードを読みやすくし、検索もしやすくなります。
多くのルールには論理的な理由がない場合があります。それらは確立された慣行によって定められています。

## フォーマット {#formatting}

**1.** 大半のフォーマットは `clang-format` によって自動的に行われます。

**2.** インデントは4スペースです。タブを押すと4スペースが追加されるように開発環境を設定してください。

**3.** 開始および終了の中括弧は別の行に配置してください。

``` cpp
inline void readBoolText(bool & x, ReadBuffer & buf)
{
    char tmp = '0';
    readChar(tmp, buf);
    x = tmp != '0';
}
```

**4.** 関数の本体が単一の `statement` であれば、それを1行に配置できます。中括弧の周りにはスペースを入れてください（行末のスペースを除く）。

``` cpp
inline size_t mask() const                { return buf_size() - 1; }
inline size_t place(HashValue x) const    { return x & mask(); }
```

**5.** 関数の場合、括弧の周りにスペースを入れないでください。

``` cpp
void reinsert(const Value & x)
```

``` cpp
memcpy(&buf[place_value], &x, sizeof(x));
```

**6.** `if`、`for`、`while` およびその他の式では、開括弧の前にスペースを入れます（関数呼び出しとは異なります）。

``` cpp
for (size_t i = 0; i < rows; i += storage.index_granularity)
```

**7.** 二項演算子（`+`, `-`, `*`, `/`, `%`, ...）および三項演算子 `?:` の周りにはスペースを追加してください。

``` cpp
UInt16 year = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
UInt8 month = (s[5] - '0') * 10 + (s[6] - '0');
UInt8 day = (s[8] - '0') * 10 + (s[9] - '0');
```

**8.** 行送りがある場合、演算子を新しい行に置き、インデントを増やしてください。

``` cpp
if (elapsed_ns)
    message << " ("
        << rows_read_on_server * 1000000000 / elapsed_ns << " rows/s., "
        << bytes_read_on_server * 1000.0 / elapsed_ns << " MB/s.) ";
```

**9.** 必要に応じて、行内の整列にスペースを使用できます。

``` cpp
dst.ClickLogID         = click.LogID;
dst.ClickEventID       = click.EventID;
dst.ClickGoodEvent     = click.GoodEvent;
```

**10.** 演算子 `.`, `->` の周囲にスペースを使用しないでください。

必要な場合は、演算子を次の行にラップできます。この場合、その前のオフセットが増加します。

**11.** 単項演算子（`--`, `++`, `*`, `&`, ...）と引数の間にスペースを使用しないでください。

**12.** カンマの後にはスペースを入れますが、前には入れません。`for` 式の内部におけるセミコロンにも同じルールが適用されます。

**13.** `[]` 演算子の周りにスペースを使用しないでください。

**14.** `template <...>` 式では、`template` と `<` の間にスペースを入れ、`<` の後や `>` の前にはスペースを入れないでください。

``` cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
{}
```

**15.** クラスおよび構造体では、`public`、`private`、および `protected` を `class/struct` と同じレベルで書き、残りのコードをインデントします。

``` cpp
template <typename T>
class MultiVersion
{
public:
    /// 使用のためのオブジェクトのバージョン。shared_ptr はバージョンのライフタイムを管理します。
    using Version = std::shared_ptr<const T>;
    ...
}
```

**16.** ファイル全体で同じ `namespace` を使用する場合、特に他に重要なものがない限り、`namespace` 内ではオフセットは必要ありません。

**17.** `if`、`for`、`while` などの式のブロックが単一の `statement` である場合、中括弧は省略可能です。代わりに `statement` を別の行に配置してください。このルールはネストされた `if`、`for`、`while` にも適用されます。

しかし、内側の `statement` に中括弧や `else` が含まれている場合、外側のブロックは中括弧で書く必要があります。

``` cpp
/// 書き込みを完了します。
for (auto & stream : streams)
    stream.second->finalize();
```

**18.** 行末にスペースがあってはいけません。

**19.** ソースファイルはUTF-8でエンコードされています。

**20.** 文字列リテラルには非ASCII文字を使用できます。

``` cpp
<< ", " << (timer.elapsed() / chunks_stats.hits) << " μsec/hit.";
```

**21.** 1行で複数の式を書くことは避けてください。

**22.** 関数内のコードセクションをグループ化し、それらの間は空行を1行か2行挿入してください。

**23.** 関数、クラスなどを1行または2行の空行で区切ること。

**24.** 値に関連する `const` は型名の前に書かなければなりません。

``` cpp
//正しい
const char * pos
const std::string & s
//間違った
char const * pos
```

**25.** ポインタや参照を宣言する際には、`*` および `&` 記号の両側にスペースを入れるべきです。

``` cpp
//正しい
const char * pos
//間違った
const char* pos
const char *pos
```

**26.** テンプレート型を使用する際は、基本的に `using` キーワードでエイリアスを付けるべきです（最も単純なケースを除く）。

言い換えれば、テンプレートパラメータは `using` の中でのみ指定され、コード内で繰り返されるべきではありません。

`using` はローカルに宣言できます（関数の内部など）。

``` cpp
//正しい
using FileStreams = std::map<std::string, std::shared_ptr<Stream>>;
FileStreams streams;
//間違った
std::map<std::string, std::shared_ptr<Stream>> streams;
```

**27.** 異なる型の変数を1つの文で宣言してはいけません。

``` cpp
//間違った
int x, *y;
```

**28.** Cスタイルのキャストを使用しないでください。

``` cpp
//間違った
std::cerr << (int)c <<; std::endl;
//正しい
std::cerr << static_cast<int>(c) << std::endl;
```

**29.** クラスと構造体では、メンバーと関数をそれぞれの可視性スコープ内部で個別にグループ化します。

**30.** 小さなクラスや構造体の場合、メソッドの宣言と実装を分ける必要はありません。

他のクラスや構造体の小さなメソッドにも同様のことが言えます。

テンプレートクラスおよび構造体の場合、メソッドの宣言と実装を分けないでください（そうしないと、同じ翻訳ユニットで定義する必要があります）。

**31.** 行は140文字で折り返すことができます（80文字ではなく）。

**32.** postfix が必要でない場合は、常にプレフィックスのインクリメント/デクリメント演算子を使用してください。

``` cpp
for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)
```

## コメント {#comments}

**1.** 非自明なコードのすべての部分にはコメントを追加してください。

これは非常に重要です。コメントを書くことで、コードが不要であるか、不適切に設計されていることを認識する助けになることがあります。

``` cpp
/** メモリの一部で、使用可能です。
  * たとえば、internal_buffer が1MBで、ファイルから読み込むためにバッファに読み込まれたのがわずか10バイトだった場合、
  * working_buffer のサイズはわずか10バイトになります。
  * (working_buffer.end() は、10バイトの後の位置を指します。)
  */
```

**2.** コメントは必要に応じて詳細に書いても構いません。

**3.** コードを説明するコメントは、そのコードの前に配置してください。稀に、コメントがコードの後、同じ行に来ることもあります。

``` cpp
/** クエリを解析し、実行します。
*/
void executeQuery(
    ReadBuffer & istr, /// クエリを読み込む場所（および INSERT 用のデータ）
    WriteBuffer & ostr, /// 結果を書き込む場所
    Context & context, /// DB、テーブル、データ型、エンジン、関数、集計関数...
    BlockInputStreamPtr & query_plan, /// ここにクエリ実行方法の説明を書くことができます
    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// SELECT クエリの処理を行う段階
    )
```

**4.** コメントは英語のみで記述するべきです。

**5.** ライブラリを書いている場合、主なヘッダーファイルに詳細なコメントを含めてください。

**6.** 追加情報を提供しないコメントを加えないでください。特に、以下のような空のコメントを残さないでください。

``` cpp
/*
* 手続き名：
* 元の手続き名：
* 著者：
* 作成日：
* 修正日：
* 修正者：
* 元のファイル名：
* 目的：
* 意図：
* 指示：
* 使用されているクラス：
* 定数：
* ローカル変数：
* パラメータ：
* 作成日：
* 目的：
*/
```

この例は、http://home.tamk.fi/~jaalto/course/coding-style/doc/unmaintainable-code/ から借用されたものです。

**7.** 各ファイルの先頭に無意味なコメント（著者、作成日など）を書く必要はありません。

**8.** 一行コメントは `///` で始まり、多行コメントは `/**` で始まります。これらのコメントは「ドキュメント」と見なされます。

注：これらのコメントからドキュメントを生成するためにDoxygenを使用できます。ただし、Doxygenは一般的に使用されていません。なぜなら、IDEでコードをナビゲートする方が便利だからです。

**9.** 多行コメントの開始と終了には空行を入れてはいけません（多行コメントを閉じる行を除いて）。

**10.** コードをコメントアウトするために、基本的なコメントを使用し、「ドキュメント」コメントを使用しないでください。

**11.** コードのコメントアウト部分をコミットする前に削除してください。

**12.** コメントやコードにおいて、下品な表現を使用しないでください。

**13.** 大文字を使用しないでください。過剰な句読点を使用しないでください。

``` cpp
/// なんでこれがうまくいかないの？？？
```

**14.** コメントを区切りとして使用しないでください。

``` cpp
///******************************************************
```

**15.** コメント内で議論を始めないでください。

``` cpp
/// どうしてこんなことをしたの？
```

**16.** ブロックの終わりに何についてだったかを説明するコメントを書く必要はありません。

``` cpp
/// for
```

## 名前 {#names}

**1.** 変数やクラスメンバーの名前には小文字のアルファベットとアンダースコアを使用してください。

``` cpp
size_t max_block_size;
```

**2.** 関数（メソッド）の名前には小文字から始まるキャメルケースを使用してください。

``` cpp
std::string getName() const override { return "Memory"; }
```

**3.** クラス（構造体）の名前には大文字で始まるキャメルケースを使用してください。他のプレフィックスはインターフェース以外では使用しません。

``` cpp
class StorageMemory : public IStorage
```

**4.** `using` の名前はクラスと同じように名付けます。

**5.** テンプレート型引数の名前は：単純な場合は `T`、`T`、`U`；`T1`、`T2` を使用します。

より複雑な場合は、クラス名に関するルールに従うか、`T` のプレフィックスを追加します。

``` cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
```

**6.** テンプレート定数引数の名前は：変数名のルールに従うか、単純な場合は `N` を使用します。

``` cpp
template <bool without_www>
struct ExtractDomain
```

**7.** 抽象クラス（インターフェース）には `I` プレフィックスを追加できます。

``` cpp
class IProcessor
```

**8.** 変数をローカルに使用する場合、短い名前を使用できます。

他のすべての場合には、意味を説明する名前を使用してください。

``` cpp
bool info_successfully_loaded = false;
```

**9.** `define` やグローバル定数の名前には ALL_CAPS を使用し、アンダースコアを含めます。

``` cpp
#define MAX_SRC_TABLE_NAMES_TO_STORE 1000
```

**10.** ファイル名はその内容と同じスタイルを使用するべきです。

ファイルが単一のクラスを含む場合、そのファイル名はクラス名と同じにします（キャメルケース）。

ファイルが単一の関数を含む場合、そのファイル名は関数名と同じにします（キャメルケース）。

**11.** 名前に略語が含まれている場合：

- 変数名には小文字の略語を使用します `mysql_connection` （`mySQL_connection` ではなく）。
- クラス名や関数名には略語の大文字を保持します `MySQLConnection` （`MySqlConnection` ではなく）。

**12.** クラスメンバーを初期化するためだけに使用されるコンストラクター引数は、クラスメンバーと同じ名前で名付けますが、末尾にアンダースコアを付けます。

``` cpp
FileQueueProcessor(
    const std::string & path_,
    const std::string & prefix_,
    std::shared_ptr<FileHandler> handler_)
    : path(path_),
    prefix(prefix_),
    handler(handler_),
    log(&Logger::get("FileQueueProcessor"))
{
}
```

アンダースコアの接尾辞は、引数がコンストラクタの本体で使用されない場合には省略できます。

**13.** ローカル変数とクラスメンバーの名前に違いはありません（プレフィックスは必要ありません）。

``` cpp
timer (m_timer ではない)
```

**14.** `enum` の定数には、単語の先頭が大文字であるキャメルケースを使用します。ALL_CAPS も許可されます。`enum` が非ローカルの場合は、`enum class` を使用します。

``` cpp
enum class CompressionMethod
{
    QuickLZ = 0,
    LZ4     = 1,
};
```

**15.** すべての名前は英語で記述するべきです。ヘブライ語の単語の音訳は禁止されています。

    not T_PAAMAYIM_NEKUDOTAYIM

**16.** 略語は一般的に知られている場合は使用を許可します（略語の意味をWikipediaや検索エンジンで簡単に見つけることができる場合）。

    `AST`, `SQL`.

    `NVDH` （無意味な文字列）は使用を避けてください。

不完全な単語は、短縮形が一般的な使用の場合に許可されます。

コメントでフルネームをその横に含める場合に限り、略語を使用することもできます。

**17.** C++ ソースコードのファイル名には `.cpp` 拡張子を付ける必要があります。ヘッダーファイルには `.h` 拡張子を付けなければなりません。

## コードの記述方法 {#how-to-write-code}

**1.** メモリ管理。

手動メモリ解放（`delete`）はライブラリコードでのみ使用できます。

ライブラリコードでは、`delete` 演算子はデストラクタでのみ使用できます。

アプリケーションコードでは、メモリはそれを所有するオブジェクトによって解放されなければなりません。

例：

- 最も簡単なのは、スタック上にオブジェクトを置くか、他のクラスのメンバーにすることです。
- 多くの小さなオブジェクトの場合は、コンテナを使用します。
- ヒープ内に存在する小さなオブジェクトの自動解放には、`shared_ptr/unique_ptr` を使用します。

**2.** リソース管理。

`RAII` を使用し、上記を参照してください。

**3.** エラーハンドリング。

例外を使用します。ほとんどのケースでは、例外をスローするだけで、キャッチする必要はありません（`RAII` のため）。

オフラインデータ処理アプリケーションでは、例外をキャッチしないことが許容されることが多いです。

ユーザーリクエストを処理するサーバーでは、通常、接続ハンドラーのトップレベルで例外をキャッチするだけで十分です。

スレッド関数では、すべての例外をキャッチして保持し、`join` の後にメインスレッドで再スローします。

``` cpp
/// まだ計算が行われていない場合、同期的に最初のブロックを計算します
if (!started)
{
    calculate();
    started = true;
}
else /// 計算が進行中であれば、結果を待機します
    pool.wait();

if (exception)
    exception->rethrow();
```

例外を処理することなく隠すことは決してしないでください。すべての例外を単に盲目的にログに入れることは避けてください。

``` cpp
//正しくない
catch (...) {}
```

いくつかの例外を無視する必要がある場合は、特定のものに対してのみ行い、残りは再スローしてください。

``` cpp
catch (const DB::Exception & e)
{
    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)
        return nullptr;
    else
        throw;
}
```

応答コードや `errno` を持つ関数を使用する際は、常に結果を確認し、エラーが発生した場合は例外をスローしてください。

``` cpp
if (0 != close(fd))
    throw ErrnoException(ErrorCodes::CANNOT_CLOSE_FILE, "Cannot close file {}", file_name);
```

コード内の不変条件を確認するために assert を使用できます。

**4.** 例外タイプ。

アプリケーションコードでは複雑な例外階層を使用する必要はありません。例外メッセージは、システム管理者にとって理解しやすいものであるべきです。

**5.** デストラクタからの例外スロー。

これは推奨されませんが許可されています。

次のオプションを使用してください：

- 例外を引き起こす可能性のあるすべての作業を事前に行う関数（`done()` または `finalize()`）を作成します。その関数が呼ばれた場合、後でデストラクタ内で例外が発生するべきではありません。
- ネットワークを介してメッセージを送信するなどの複雑すぎるタスクは、クラスの利用者が破棄の前に呼び出す必要のある別のメソッドに入れることができます。
- デストラクタ内で例外が発生した場合、隠すよりもログに記録する方が良いです（ロガーが利用可能な場合）。
- 簡単なアプリケーションでは、例外を処理するために `std::terminate` に依存することが許可されます（C++11 ではデフォルトで `noexcept` の場合）。

**6.** 匿名コードブロック。

変数をローカルにするために、単一の関数内に別のコードブロックを作成し、ブロックを出る際にデストラクタが呼び出されるようにすることができます。

``` cpp
Block block = data.in->read();

{
    std::lock_guard<std::mutex> lock(mutex);
    data.ready = true;
    data.block = block;
}

ready_any.set();
```

**7.** マルチスレッド。

オフラインデータ処理プログラムでは：

- 可能な限り単一のCPUコアで最高の性能を得るように努めてください。その後、必要に応じてコードを並列化できます。

サーバーアプリケーションでは：

- リクエストを処理するためにスレッドプールを使用します。この時点では、ユーザースペースのコンテキストスイッチを必要とするタスクはありません。

フォークは並列化に使用されません。

**8.** スレッドの同期。

異なるスレッドが異なるメモリセル（さらに良いことに、異なるキャッシュライン）を使用するようにし、スレッドの同期を使用しないことがしばしば可能です（`joinAll` を除く）。

同期が必要な場合、多くの場合、`lock_guard`の下でミューテックスを使用するだけで十分です。

他の場合には、システム同期プリミティブを使用します。ビジーウェイトは使用しないでください。

原子的操作は最も単純な場合にのみ使用するべきです。

ロックフリーのデータ構造を実装しようとしないでください。それがあなたの専門分野でない限り。

**9.** ポインタ対参照。

ほとんどの場合、参照を優先してください。

**10.** `const`。

定数参照、定数ポインタ、`const_iterator`、および `const` メソッドを使用してください。

`const` をデフォルトとして考え、必要な場合にのみ非 `const` を使用してください。

値で変数を渡す際、`const` を使用する意味は通常ありません。

**11.** unsigned。

必要に応じて `unsigned` を使用してください。

**12.** 数値型。

`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、および `Int64` の型、および `size_t`、`ssize_t`、`ptrdiff_t` を使用してください。

これらの型で数値を使用しないでください： `signed/unsigned long`、`long long`、`short`、`signed/unsigned char`、`char`。

**13.** 引数の渡し方。

複雑な値は値として渡し、移動される場合に `std::move` を使用し、ループ内で値を更新したい場合は参照で渡してください。

ヒープ内に作成されたオブジェクトの所有権を関数が取得する場合、引数の型を `shared_ptr` または `unique_ptr` にします。

**14.** 戻り値。

ほとんどのケースでは、単に `return` を使用します。`return std::move(res)` と書かないでください。

関数がヒープにオブジェクトを割り当ててそれを返す場合、`shared_ptr` または `unique_ptr` を使用します。

稀なケース（ループ内の値の更新）では、引数を通じて値を返す必要がある場合があります。この場合、引数は参照であるべきです。

``` cpp
using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;

/** 名前から集計関数を作成できるクラス。
  */
class AggregateFunctionFactory
{
public:
    AggregateFunctionFactory();
    AggregateFunctionPtr get(const String & name, const DataTypes & argument_types) const;
```

**15.** `namespace`。

アプリケーションコードに対しては別の `namespace` を使用する必要はありません。

小さなライブラリにもこれが必要ありません。

中規模から大規模のライブラリでは、すべてを `namespace` に入れます。

ライブラリの `.h` ファイルでは、アプリケーションコードに必要のない実装の詳細を隠すために `namespace detail` を使用できます。

`.cpp` ファイルでは、シンボルを隠すために `static` または匿名の `namespace` を使用できます。

また、名前が外部の `namespace` に入らないようにするために `enum` 用に `namespace` を使用することもできます（ただし、`enum class` を使用する方が良いです）。

**16.** 遅延初期化。

初期化に引数が必要な場合、通常はデフォルトコンストラクタを書くべきではありません。

後で初期化を遅らせる必要がある場合、無効なオブジェクトを作成するデフォルトコンストラクタを追加できます。また、小数のオブジェクトに対しては `shared_ptr/unique_ptr` を使用することもできます。

``` cpp
Loader(DB::Connection * connection_, const std::string & query, size_t max_block_size_);

/// 遅延初期化用
Loader() {}
```

**17.** 仮想関数。

クラスが多態的な使用を意図していない場合、関数を仮想にする必要はありません。これにデストラクタも含まれます。

**18.** エンコーディング。

どこでもUTF-8を使用します。`std::string` と `char *` を使用してください。`std::wstring` や `wchar_t` を使用しないでください。

**19.** ロギング。

コード内の例を参照してください。

コミットの前に、無意味なロギングやデバッグロギング、他のタイプのデバッグ出力をすべて削除してください。

サイクル内でのロギングは避けるべきであり、トレースレベルでも同様です。

すべてのロギングレベルでログは読みやすいものでなければなりません。

ロギングは主にアプリケーションコード内でのみ使用されるべきです。

ログメッセージは英語で書かれるべきです。

ログは可能であればシステム管理者に理解可能であるべきです。

ログ内で下品な表現を使用しないでください。

ログにUTF-8エンコーディングを使用してください。非ASCII文字をログに使用するのは稀なケースです。

**20.** 入出力。

アプリケーションのパフォーマンスに critical な内部ループでは `iostreams` を使用しないでください（`stringstream` も使用しないでください）。

代わりに `DB/IO` ライブラリを使用してください。

**21.** 日付と時刻。

`DateLUT` ライブラリを参照してください。

**22.** include。

常にインクルードガードの代わりに `#pragma once` を使用してください。

**23.** using。

`using namespace` は使用しません。特定のものには `using` を使用できます。ただし、クラスや関数内でローカルにしてください。

**24.** 必要ならば関数に対して `trailing return type` を使用しないでください。

``` cpp
auto f() -> void
```

**25.** 変数の宣言と初期化。

``` cpp
//正しい方法
std::string s = "Hello";
std::string s{"Hello"};

//間違った方法
auto s = std::string{"Hello"};
```

**26.** 仮想関数については、基底クラスで `virtual` を書きますが、子孫クラスでは `virtual` の代わりに `override` を書きます。

## C++ の未使用機能 {#unused-features-of-c}

**1.** 仮想継承は使用されません。

**2.** 現代のC++には便利な構文糖がある構造、例えば：

```cpp
// 構文糖なしの従来の方法
template <typename G, typename = std::enable_if_t<std::is_same<G, F>::value, void>> // SFINAE via std::enable_if, usage of ::value
std::pair<int, int> func(const E<G> & e) // 明示的に指定された戻り値の型
{
    if (elements.count(e)) // .count() メンバーシップテスト
    {
        // ...
    }

    elements.erase( 
        std::remove_if(
            elements.begin(), elements.end(),
            [&](const auto x){
                return x == 1;
            }),
        elements.end()); // remove-erase 慣用句

    return std::make_pair(1, 2); // make_pair() によってペアを作成します
}

// 構文糖を使った方法 (C++14/17/20)
template <typename G>
requires std::same_v<G, F> // SFINAE via C++20 concept, usage of C++14 テンプレートエイリアス
auto func(const E<G> & e) // 自動戻り値型 (C++14)
{
    if (elements.contains(e)) // C++20 .contains メンバーシップテスト
    {
        // ...
    }

    elements.erase_if(
        elements,
        [&](const auto x){
            return x == 1;
        }); // C++20 std::erase_if

    return {1, 2}; // または: return std::pair(1, 2); // 初期化リストまたは値の初期化 (C++17) でペアを作成
}
```

## プラットフォーム {#platform}

**1.** 特定のプラットフォーム向けにコードを書きます。

しかし、他の条件が同じ場合、クロスプラットフォームまたはポータブルコードが優先されます。

**2.** 言語：C++20（利用可能な[C++20機能](https://en.cppreference.com/w/cpp/compiler_support#C.2B.2B20_features)のリストを参照）。

**3.** コンパイラ：`clang`。執筆時（2022年7月）、コードは clang バージョン >= 12 でコンパイルされます（`gcc` を使用してコンパイルすることも可能ですが、未テストであり、本番使用には適していません）。

標準ライブラリは使用されています（`libc++`）。

**4.** OS：Linux Ubuntu、Precise 以上ではないこと。

**5.** コードは x86_64 CPU アーキテクチャ向けに書かれています。

CPU 命令セットは、私たちのサーバー間で支持される最低限のセットです。 現在、SSE 4.2 です。

**6.** コンパイルフラグには `-Wall -Wextra -Werror -Weverything` を使用し、いくつかの例外があります。

**7.** 難しい静的リンクのライブラリを除き、すべてのライブラリは静的リンクを使用します（`ldd` コマンドの出力を参照）。

**8.** コードはリリース設定で開発およびデバッグされます。

## ツール {#tools}

**1.** KDevelop は優れた IDE です。

**2.** デバッグには `gdb`、`valgrind`（`memcheck`）、`strace`、`-fsanitize=...`、または `tcmalloc_minimal_debug` を使用してください。

**3.** プロファイリングには `Linux Perf`、`valgrind`（`callgrind`）、または `strace -cf` を使用してください。

**4.** ソースは Git にあります。

**5.** アセンブリには `CMake` を使用します。

**6.** プログラムは `deb` パッケージを使用してリリースされます。

**7.** master へのコミットはビルドを壊さないようにします。

選択されたリビジョンのみが作業可能と見なされます。

**8.** コードが部分的にしか準備できていない場合でも、可能な限り頻繁にコミットしてください。

この目的のためにブランチを使用してください。

`master` ブランチ内のコードがまだビルドできない場合は、`push` 前にビルドから除外してください。数日以内にそれを完成させるか削除する必要があります。

**9.** 重要でない変更の場合は、ブランチを使用し、それらをサーバーで公開してください。

**10.** 未使用のコードはリポジトリから削除されます。

## ライブラリ {#libraries}

**1.** C++20 標準ライブラリが使用され、（実験的な拡張は許可される）`boost` および `Poco` フレームワークも使用されます。

**2.** OS パッケージからのライブラリの使用は許可されていません。インストール済みのライブラリの使用も許可されていません。すべてのライブラリは `contrib` ディレクトリ内のソースコードの形で置かれ、ClickHouse と共にビルドされるべきです。新しいサードパーティライブラリを追加するためのガイドラインについての詳細は、[新しいサードパーティライブラリの追加](contrib.md#adding-third-party-libraries)を参照してください。

**3.** 使用中のライブラリには常に優先権が与えられます。

## 一般的な推奨事項 {#general-recommendations-1}

**1.** 可能な限り少ないコードを書くこと。

**2.** 最も単純な解決策を試みること。

**3.** どのように機能するかおよび内部ループがどのように機能するかを理解するまで、コードを書かないこと。

**4.** 最も単純なケースでは、クラスや構造体の代わりに `using` を使用してください。

**5.** 可能であれば、コピーコンストラクタ、代入演算子、デストラクタ（クラスに少なくとも1つの仮想関数が含まれている場合は、仮想のものを除く）、ムーブコンストラクタ、またはムーブ代入演算子を書かないようにしてください。つまり、コンパイラ生成の関数が正しく動作する必要があります。`default` を使用できます。

**6.** コードの簡素化が奨励されます。可能な限りコードのサイズを縮小してください。
