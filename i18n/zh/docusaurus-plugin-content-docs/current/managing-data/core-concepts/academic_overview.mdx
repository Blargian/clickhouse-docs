---
'slug': '/academic_overview'
'title': '架构概述'
'description': '文档版本的 2024 VLDB 论文'
'keywords':
- 'architecture'
---

import useBrokenLinks from "@docusaurus/useBrokenLinks";
import image_01 from '@site/static/images/managing-data/core-concepts/_vldb2024_1_Figure_0.png'
import image_02 from '@site/static/images/managing-data/core-concepts/_vldb2024_2_Figure_0.png'
import image_03 from '@site/static/images/managing-data/core-concepts/_vldb2024_2_Figure_5.png'
import image_04 from '@site/static/images/managing-data/core-concepts/_vldb2024_3_Figure_7.png'
import image_05 from '@site/static/images/managing-data/core-concepts/_vldb2024_4_Figure_6.png'
import image_06 from '@site/static/images/managing-data/core-concepts/_vldb2024_5_Figure_8.png'
import image_07 from '@site/static/images/managing-data/core-concepts/_vldb2024_6_Figure_0.png'
import image_08 from '@site/static/images/managing-data/core-concepts/_vldb2024_7_Figure_1.png'
import image_09 from '@site/static/images/managing-data/core-concepts/_vldb2024_8_Figure_7.png'
import image_10 from '@site/static/images/managing-data/core-concepts/_vldb2024_10_Figure_14.png'
import image_11 from '@site/static/images/managing-data/core-concepts/_vldb2024_10_Figure_0.png'
import image_12 from '@site/static/images/managing-data/core-concepts/_vldb2024_10_Figure_12.png'
import image_13 from '@site/static/images/managing-data/core-concepts/_vldb2024_10_Figure_13.png'
import Image from '@theme/IdealImage';


<!-- needed as docusaurus cannot resolve links to span ids, we need a custom span -->
export function Anchor(props) {
    useBrokenLinks().collectAnchor(props.id);
    return <span style={{scrollMarginTop: "var(--ifm-navbar-height)"}} {...props}/>;
}

这是我们[VLDB 2024 科学论文](https://www.vldb.org/pvldb/vol17/p3731-schulze.pdf)的网络版本。我们也[写博客](https://clickhouse.com/blog/first-clickhouse-research-paper-vldb-lightning-fast-analytics-for-everyone)介绍了其背景和历程，并推荐观看 ClickHouse 首席技术官及创始人 Alexey Milovidov 的 VLDB 2024 演讲：

<iframe width="1024" height="576" src="https://www.youtube.com/embed/7QXKBKDOkJE?si=5uFerjqPSXQWqDkF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
## 摘要 {#abstract}

在过去的几十年中，存储和分析的数据量呈指数级增长。各行各业的企业开始依靠这些数据来改进产品、评估绩效并做出重要的商业决策。然而，随着数据量的不断增长成为互联网规模，企业需要以一种具成本效益和可扩展的方式管理历史数据和新数据，同时使用高并发的查询来分析数据，并期望实时延迟（例如，低于一秒，具体取决于使用场景）。

本文概述了 ClickHouse，这是一种流行的开源 OLAP 数据库，旨在提供针对大规模数据集（例如，数据量达到 PB 级别并具有高摄取率）进行高性能分析的能力。它的存储层结合了基于传统日志结构合并（LSM）树的数据格式以及用于后台历史数据连续转换的新技术（例如，聚合、归档）。查询使用方便的 SQL 方言编写，并由最先进的向量化查询执行引擎处理，可选择性地进行代码编译。ClickHouse 积极使用修剪技术来避免评估查询中无关的数据。其他数据管理系统可以在表函数、表引擎或数据库引擎级别集成。实际的基准测试表明，ClickHouse 是市场上最快的分析数据库之一。
## 1 引言 {#1-introduction}

本文描述了 ClickHouse，这是一种列式 OLAP 数据库，专为高性能分析查询设计，适用于具有万亿行和数百列的表。ClickHouse 于 2009 年作为针对大规模日志文件数据的过滤和聚合操作符启动，并于 2016 年开源。 [图 1](#page-1-0) 说明了本文描述的主要功能何时被引入 ClickHouse。

ClickHouse 旨在解决现代分析数据管理的五个关键挑战：

1. **海量数据集和高摄取率**。许多数据驱动的应用程序（如网页分析、金融和电子商务）具有庞大且不断增长的数据量。为了处理海量数据集，分析数据库不仅必须提供有效的索引和压缩策略，还必须能够在多个节点之间分配数据（扩展），因为单个服务器的存储限制为几十 TB。此外，最近的数据通常对实时洞察比历史数据更相关。因此，分析数据库必须能够以始终较高的速率或突发方式摄取新数据，并且能够持续“降低优先级”（例如，聚合、归档）历史数据，而不会拖慢并行报告查询的速度。

2. **许多同时查询并期望低延迟**。查询通常可以分为即席查询（例如，探索性数据分析）或定期查询（例如，定期仪表板查询）。用例越具互动性，要求的查询延迟越低，这就导致了查询优化和执行上的挑战。定期查询还提供了将物理数据库布局调整到工作负载的机会。因此，数据库应该提供修剪技术，以优化频繁的查询。根据查询的优先级，数据库还必须在共享系统资源（如 CPU、内存、磁盘和网络 I/O）上提供平等或优先的访问，即使在大量查询同时运行时也如此。

3. **数据存储、存储位置和格式的多样化**。为了与现有数据架构集成，现代分析数据库应该表现出较高的开放性，以在任何系统、位置或格式中读取和写入外部数据。

4. **方便的查询语言，支持性能检查**。OLAP 数据库的现实使用还提出了其他“软性”要求。例如，用户通常希望使用一种表达性 SQL 方言与数据库进行交互，而不是一个小众编程语言，并希望支持嵌套数据类型和广泛的常规、聚合和窗口函数。分析数据库还应提供复杂的工具，以检查系统或单个查询的性能。

5. **行业级的健壮性和多样化的部署**。由于商品硬件不可靠，数据库必须提供数据复制，以防止节点故障。此外，数据库应能够在任何硬件上运行，从旧笔记本电脑到强大的服务器。最后，为了避免 JVM 程序中的垃圾回收开销并实现裸金属性能（例如，SIMD），理想情况下，数据库作为目标平台的本机二进制文件进行部署。

<Anchor id="page-1-0"/><Image img={image_01} size="lg" alt="图 1"/>

图 1: ClickHouse 时间线。
## 2 架构 {#2-architecture}

<Anchor id="page-2-0"/><Image img={image_02} size="lg" alt="图 2"/>

图 2: ClickHouse 数据库引擎的高层架构。

如[图 2](#page-2-0)所示，ClickHouse 引擎分成三个主要层次：查询处理层（在[第 4 节](#page-6-0)中描述）、存储层（[第 3 节](#page-1-1)）和集成层（[第 5 节](#page-9-0)）。除了这些之外，访问层管理用户会话，并通过不同协议与应用程序进行通信。还有正交组件用于线程管理、缓存、基于角色的访问控制、备份和持续监控。ClickHouse 是用 C++ 构建的单个静态链接二进制文件，没有依赖项。

查询处理遵循传统的范式，包括解析传入的查询、构建和优化逻辑和物理查询计划以及执行。ClickHouse 使用类似于 MonetDB/X100 的向量化执行模型 [\[11\]](#page-12-0)，结合机会性代码编译 [\[53\]](#page-13-0)。查询可以使用功能丰富的 SQL 方言、PRQL [\[76\]](#page-13-1) 或 Kusto 的 KQL [\[50\]](#page-13-2) 编写。

存储层由不同的表引擎组成，封装了表数据的格式和位置。表引擎分为三类：第一类是 MergeTree* 表引擎系列，它代表了 ClickHouse 中主要的持久化格式。基于 LSM 树的理念 [\[60\]](#page-13-3)，表被分为水平的、排序的部分，后台进程会持续地将这些部分合并在一起。个别的 MergeTree* 表引擎在合并如何将输入部分的行组合时存在差异。例如，可以对过时行进行聚合或替换。

第二类是特殊用途的表引擎，用于加速或分配查询执行。该类包括称为字典的内存内键值表引擎。[字典](https://clickhou.se/dictionaries) 缓存定期执行的查询结果，这些查询是针对内部或外部数据源执行的。这在某些情况下显著减少了访问延迟，可以容忍一定的数据陈旧性。其他特殊用途的表引擎例子包括用于临时表的纯内存引擎和用于透明数据分片的分布式表引擎（见下文）。

第三类表引擎是用于与外部系统（如关系数据库（例如 PostgreSQL、MySQL）、发布/订阅系统（例如 Kafka、RabbitMQ [\[24\]](#page-12-1)）或键值存储（例如 Redis））进行双向数据交换的虚拟表引擎。虚拟引擎还可以与数据湖（例如 Iceberg、DeltaLake、Hudi [\[36\]](#page-12-2)）或对象存储中的文件（例如 AWS S3、Google GCP）进行交互。

ClickHouse 支持在多个集群节点间对表进行分片和复制，以实现可扩展性和可用性。分片根据分片表达式将表划分为一组表分片。个别的分片是相互独立的表，通常位于不同的节点上。客户端可以直接读取和写入分片，即将它们视为独立的表，或者使用分布式特定表引擎，该引擎提供了所有表分片的全局视图。分片的主要目的是处理超出单个节点（通常为几十 TB 的数据）容量的数据集。分片的另一个用途是在多个节点上分配一个表的读写负载，即负载均衡。正交于此，一个分片可以在多个节点间进行复制，以防止节点故障。为此，每个 Merge-Tree* 表引擎都有对应的 ReplicatedMergeTree* 引擎，使用基于 Raft 共识的多主协调方案 [\[59\]](#page-13-4)（由[Keeper](https://clickhou.se/keeper)实现，Keeper 是用 C++ 编写的 Apache Zookeeper 的替代品），以保证每个分片始终有一个可配置数量的副本。第 3.6 节将详细讨论复制机制。作为示例， [图 2](#page-2-0) 显示了一个具有两个分片的表，每个分片复制到两个节点。

最后，ClickHouse 数据库引擎可以在本地、云端、独立或进程内模式中运行。在本地模式下，用户将 ClickHouse 设置为本地单个服务器或具有分片和/或复制的多节点集群。客户端通过本地原生协议、MySQL 二进制协议、PostgreSQL 二进制协议或 HTTP REST API 与数据库通信。云模式由 ClickHouse Cloud 表示，这是一个完全托管和自动扩展的 DBaaS 提供。虽然本文重点介绍本地模式，但我们计划在后续出版物中描述 ClickHouse Cloud 的架构。[独立模式](https://clickhou.se/local-fastest-tool) 将 ClickHouse 转变为用于分析和转换文件的命令行工具，使其成为类似于 Unix 工具如 cat 和 grep 的基于 SQL 的替代品。虽然这不需要先前的配置，但独立模式受限于单个服务器。最近，开发了一种名为 chDB [\[15\]](#page-12-3) 的进程内模式，适用于像 Jupyter notebooks [\[37\]](#page-12-4) 这样的交互式数据分析使用案例，结合 Pandas 数据框 [\[61\]](#page-13-5)。受到 DuckDB [\[67\]](#page-13-6) 的启发， [chDB](https://clickhou.se/chdb-rocket-engine) 将 ClickHouse 嵌入到主机进程中，作为高性能 OLAP 引擎。与其他模式相比，这允许在数据库引擎与应用程序之间高效地传递源数据和结果数据，而无需复制，因为它们在同一地址空间中运行。
## <Anchor id="page-1-1"/>3 存储层 {#3-storage-layer}

本节讨论 MergeTree* 表引擎作为 ClickHouse 的本地存储格式。我们描述它们的磁盘表示，并讨论 ClickHouse 中的三种数据修剪技术。之后，我们呈现合并策略，它们能够持续地转换数据，而不会影响同时的插入。最后，我们解释更新和删除的实现方式，以及数据去重、数据复制和 ACID 的合规性。
### <Anchor id="page-2-2"/>3.1 磁盘格式 {#3-1-on-disk-format}

每个 MergeTree* 表引擎中的表被组织为不可变的表部分集合。每当一组行插入到表中时，就会创建一个部分。部分是自包含的，意为它们包含了解释其内容所需的所有元数据，而无需额外查找中心目录。为了保持每个表的部分数量较低，后台合并作业会定期将多个较小的部分合并到更大的部分中，直到达到可配置的部分大小（默认为 150 GB）。由于部分按表的主键列排序（见[第 3.2 节](#page-3-0)），因此在合并时使用高效的 k-way 合并排序 [\[40\]](#page-12-5)。源部分标记为非活跃状态，并在引用计数降至零（即没有进一步的查询从它们中读取）时最终被删除。

行可以以两种模式插入：在同步插入模式下，每个 INSERT 语句创建一个新部分并将其附加到表中。为了减少合并的开销，数据库客户端鼓励一次以大批量插入元组，例如，一次插入 20,000 行。然而，如果数据需要实时分析，客户端批量处理造成的延迟往往是不可接受的。例如，观察性使用案例通常涉及数千个监控代理持续发送少量事件和指标数据。这些场景可以使用异步插入模式，其中 ClickHouse 将来自多个传入 INSERT 的行缓冲到同一表中，并仅在缓冲区大小超过可配置的阈值或超时到期后创建新部分。

<Anchor id="page-2-1"/><Image img={image_03} size="lg" alt="图 3"/>

图 3: MergeTree*-引擎表的插入和合并。

[图 3](#page-2-1) 说明了对 MergeTree*-引擎表的四个同步和两个异步插入。两次合并减少了活动部分的数量，从最初的五个减少到两个。

与 LSM 树 [\[58\]](#page-13-7) 及其在各种数据库中的实现 [\[13,](#page-12-6) [26,](#page-12-7) [56\]](#page-13-8) 相比，ClickHouse 将所有部分视为平等，而不是将它们排列在层次中。因此，合并不再限于同一级别的部分。由于这还放弃了部分的隐含时间顺序，因此需要基于其他机制进行更新和删除，而不是基于墓碑（见[第 3.4 节](#page-4-0)）。ClickHouse 直接将插入写入磁盘，而其他基于 LSM 树的存储通常使用写预日志（见[第 3.7 节](#page-5-1)）。

一个部分对应于磁盘上的一个目录，每个列包含一文件。作为优化，小部分（默认小于 10 MB）的列连续存储在一个文件中，以增加读写时的空间局部性。一个部分的行进一步逻辑上划分为 8192 条记录的组，称为颗粒。颗粒代表 ClickHouse 中由扫描和索引查找操作处理的最小不可分割的数据单元。然而，磁盘数据的读写并不是在颗粒级别上执行的，而是在块的粒度上执行，这些块将同一列中的多个相邻颗粒组合在一起。基于每块的可配置字节大小（默认 1 MB），形成新块，即块中的颗粒数量是可变的，并取决于列的数据类型和分布。块进一步被压缩以减少其大小和 I/O 成本。 默认情况下，ClickHouse 使用 LZ4 [\[75\]](#page-13-9) 作为通用压缩算法，但用户也可以指定用于浮点数据的专用编解码器，如 Gorilla [\[63\]](#page-13-10) 或 FPC [\[12\]](#page-12-8)。压缩算法也可以链式应用。例如，可以首先使用增量编码来减少数值的逻辑冗余，然后执行重压缩，最后使用 AES 编解码器加密数据。在从磁盘加载到内存时，块是在其上随即解压缩的。为了在压缩的情况下启用对单个颗粒的快速随机访问，ClickHouse 还为每列存储了一个映射，将每个颗粒 id 与其所属压缩块在列文件中的偏移量及颗粒在未压缩块中的偏移量关联起来。

列还可以被字典编码 [\[2,](#page-12-10) [77,](#page-13-11) [81\]](#page-13-12) 或使用两个特殊的包装数据类型变为 Nullable：LowCardinality(T) 通过整数 id 替代原始列值，从而显著减少具有少量唯一值的数据的存储开销。Nullable(T) 向 T 列添加一个内部位图，表示列值是否为 NULL。

最后，表可以使用任意分区表达式进行范围、哈希或轮询分区。为了启用分区修剪，ClickHouse 还为每个分区存储分区表达式的最小值和最大值。用户可选择创建更高级的列统计信息（例如，HyperLogLog [\[30\]](#page-12-11) 或 t-digest [\[28\]](#page-12-12) 统计信息），这些统计信息也提供基数估计。
### <Anchor id="page-3-0"/>3.2 数据修剪 {#3-2-data-pruning}

在大多数使用案例中，仅为了回答单个查询而扫描 PB 级别的数据速度太慢且成本过高。ClickHouse 支持三种数据修剪技术，允许在搜索过程中跳过大多数行，从而显著加快查询速度。

首先，用户可以为表定义 **主键索引**。主键列决定各个部分内行的排序顺序，即索引是局部聚集的。ClickHouse 还为每个部分存储从每个颗粒的第一行的主键列值到颗粒 id 的映射，即索引是稀疏的 [\[31\]](#page-12-13)。生成的数据结构通常足够小，可以完全保留在内存中，例如，仅需要 1000 个条目即可为 810 万行建立索引。主键的主要目的是使用二进制搜索评估经常被过滤的列的相等性和范围谓词，而不是顺序扫描（见[第 4.4 节](#page-7-0)）。局部排序还可用于部分合并和查询优化，例如基于排序的聚合或在主键列形成排序列的前缀时，去除物理执行计划中的排序操作符。

[图 4](#page-3-1) 显示了一个表上 EventTime 列的主键索引，该表具有页面展示统计信息。通过对主键索引进行二进制搜索，可以找到与查询中范围谓词匹配的颗粒，而无需顺序扫描 EventTime。

<Anchor id="page-3-1"/><Image img={image_04} size="lg" alt="图 4"/>

图 4: 使用主键索引评估过滤器。

其次，用户可以创建 **表投影**，即按不同主键排序的具有相同行的表的替代版本 [\[71\]](#page-13-13)。投影可以加速对与主表的主键不同的列的过滤查询，但代价是插入、合并和空间消耗的开销会增加。默认情况下，仅从新插入的主表部分惰性填充投影，而不从现有部分填充，除非用户将投影完全物化。查询优化器根据预估的 I/O 成本在从主表读取或从投影读取之间进行选择。如果某个部分没有投影，查询执行将回退到相应的主表部分。

第三，**跳过索引**提供了一个轻量级的替代方案来代替投影。跳过索引的思想是在多个连续颗粒的层面存储少量元数据，从而避免扫描无关行。可以为任意索引表达式创建跳过索引，并使用可配置的粒度，即跳过索引块中的颗粒数量。可用的跳过索引类型包括：1. 最小-最大索引 [\[51\]](#page-13-14)，存储每个索引块的索引表达式的最小值和最大值。此索引类型适用于具有小绝对范围的局部聚集数据，例如松散排序数据。 2. 集合索引，存储可配置数量的唯一索引块值。此索引最适用于具有小局部基数的数据，即“聚拢在一起”的值。 3. 布隆过滤器索引 [\[9\]](#page-12-14)，构建用于行、标记或 n-gram 值，具有可配置的假阳性率。这些索引支持文本搜索 [\[73\]](#page-13-15)，但与最小-最大和集合索引不同，不能用于范围或负谓词。
### <Anchor id="page-4-3"/>3.3 合并时的数据转换 {#3-3-merge-time-data-transformation}

商业智能和观察性用例经常需要处理以恒定高速度或突发生成的数据。此外，最近生成的数据通常对有意义的实时洞察比历史数据更相关。这些用例需要数据库在持续降低历史数据体积的同时，维持高数据摄取率，方法包括聚合或数据老化。ClickHouse 允许使用不同的合并策略对现有数据进行持续增量转换。合并时的数据转换不会影响 INSERT 语句的性能，但不能保证表中永远不包含不需要的（例如，过时或未聚合的）值。如果需要，所有合并时的转换都可以通过在 SELECT 语句中指定关键字 FINAL 在查询时应用。

**替换合并** 仅保留基于其包含部分的创建时间戳的元组的最新插入版本，旧版本会被删除。如果两个元组的主键列值相同，则认为它们是等价的。为了明确控制保留哪个元组，也可以为比较指定一个特殊的版本列。替换合并通常用作合并时的更新机制（通常在更新频繁的用例中），或作为插入时数据去重的替代方案（见[第 3.5 节](#page-5-2)）。

**聚合合并** 将具有相等主键列值的行合并为一行聚合行。非主键列必须处于持有汇总值的部分聚合状态。两个部分聚合状态（例如，avg() 的和与计数）会组合成一个新的部分聚合状态。聚合合并通常在物化视图中使用，而不是普通表中。物化视图基于对源表的转换查询进行填充。与其他数据库不同，ClickHouse 不会定期使用源表的整个内容刷新物化视图。物化视图通常在新部分插入到源表时，根据转换查询的结果进行增量更新。

[图 5](#page-4-1) 显示了在拥有页面展示统计信息的表上定义的物化视图。对于插入到源表的新部分，转换查询计算按区域分组的最大值和平均延迟，并将结果插入物化视图。聚合函数 avg() 和 max() 配带扩展 -State 返回部分聚合状态，而不是实际结果。为物化视图定义的聚合合并会不断合并不同部分中的部分聚合状态。为了获得最终结果，用户用 avg() 和 max() 结合 -Merge 扩展合并物化视图中的部分聚合状态。

<Anchor id="page-4-1"/><Image img={image_05} size="lg" alt="图 5"/>

图 5: 物化视图中的聚合合并。

**生存时间 (TTL) 合并** 为历史数据提供老化机制。与删除和聚合合并不同，TTL 合并一次只处理一个部分。TTL 合并是根据带有触发器和操作的规则定义的。触发器是一个计算每一行的时间戳的表达式，并与运行 TTL 合并的时间进行比较。虽然这允许用户在行级别上控制操作，但我们发现检查所有行是否满足给定条件并在整个部分上运行操作就足够了。可用的操作包括 1. 将部分移动到另一个卷（例如，更便宜且速度较慢的存储），2. 重新压缩部分（例如，使用更重的编解码器），3. 删除部分，以及 4. 回滚，即使用分组键和聚合函数对行进行聚合。

例如，考虑在[列表 1](#page-4-2) 中的日志表定义。ClickHouse 将把时间戳列值早于一星期的部分移动到速度较慢但便宜的 S3 对象存储中。
<Anchor id="page-4-2"/>
```
1 CREATE TABLE tab ( ts DateTime , msg String )
2 ENGINE MergeTree PRIMARY KEY ts
3 TTL ( ts + INTERVAL 1 WEEK ) TO VOLUME 's3 '
```
列表 1: 一周后将部分移动到对象存储。
### <Anchor id="page-4-0"/>3.4 更新和删除 {#3-4-updates-and-deletes}

MergeTree* 表引擎的设计倾向于追加仅工作负载，但某些用例偶尔需要修改现有数据，例如为了符合法规。对于更新或删除数据，存在两种方法，均不阻止并行插入。

**突变** 在原地重写表的所有部分。为了防止表（删除）或列（更新）在短时间内临时翻倍，此操作是非原子的，即并行 SELECT 语句可能读取突变和非突变部分。突变保证在操作结束时数据的物理更改。删除突变仍然非常昂贵，因为它们会重写所有部分中的所有列。

作为替代方案，**轻量级删除** 仅更新一个内部位图列，指示某行是否被删除。ClickHouse 在 SELECT 查询中附加一个额外的过滤器，以基于位图列排除已删除的行。已删除的行仅在未来的某个不确定时间由常规合并物理删除。根据列计数，轻量级删除可能比突变快得多，但代价是 SELECT 的速度较慢。

对同一表执行的更新和删除操作通常被期望是罕见的，并且被序列化以避免逻辑冲突。
### <Anchor id="page-5-2"/>3.5 幂等插入 {#3-5-idempotent-inserts}

实践中经常出现的问题是，客户如何在将数据发送到服务器以插入到表中后处理连接超时。在这种情况下，客户端很难区分数据是否已成功插入。这个问题通常通过从客户端重新发送数据到服务器并依赖主键或唯一约束来拒绝重复插入来解决。数据库通过基于二叉树的索引结构快速执行所需的点查找 [\[39,](#page-12-15) [68\]](#page-13-16)、基数树 [\[45\]](#page-13-17) 或哈希表 [\[29\]](#page-12-16)。由于这些数据结构对每个元组建立索引，因此它们的空间和更新开销在大数据集和高摄取率下会变得不堪重负。

ClickHouse 提供了一种更轻量级的替代方案，基于每次插入最终创建一个部分的事实。更具体地说，服务器维护最近 N 个插入部分（例如，N=100）的哈希，并忽略已知哈希的部分的重新插入。非复制和复制表的哈希分别存储在 Keeper 中。因此，插入变得幂等，即客户端可以在超时后简单地重新发送相同的一批行，并假设服务器会负责去重。为了对去重过程有更多控制，客户端还可以选择提供一个插入令牌作为部分哈希。虽然基于哈希的去重需要与散列新行相关的开销，但存储和比较哈希的成本微不足道。

### <Anchor id="page-5-0"/>3.6 数据复制 {#3-6-data-replication}

复制是高可用性（对节点故障的容忍）的前提，但也用于负载均衡和零停机升级 [\[14\]](#page-12-17)。在 ClickHouse 中，复制基于表状态的概念，这些状态由一组表片段（第 [3.1 节](#page-2-2)）和表元数据（如列名和类型）组成。节点通过三种操作来推进表的状态：1. 插入将新片段添加到状态中，2. 合并将新片段添加到状态中并删除现有片段，3. 变更和 DDL 语句根据具体操作添加片段、删除片段和/或更改表元数据。操作在单个节点上本地执行，并记录为全局复制日志中的状态转换序列。

复制日志由典型的三台 ClickHouse Keeper 进程的集群维护，使用 Raft 共识算法 [\[59\]](#page-13-4) 提供分布式和容错的协调层，适用于 ClickHouse 节点的集群。所有集群节点最初指向复制日志中的同一位置。当节点执行本地插入、合并、变更和 DDL 语句时，复制日志会异步地在所有其他节点上重放。因此，复制表仅最终一致，即节点在逐渐趋向于最新状态时，可以临时读取旧的表状态。上述大多数操作也可以同步执行，直到节点的法定人数（例如，过半数节点或所有节点）采纳新状态。

例如，[图 6](#page-5-3)显示了在三台 ClickHouse 节点的集群中，最初为空的复制表。节点 1 首先接收两个插入语句，并在 Keeper 集群中记录它们（1 2）。接下来，节点 2 通过获取第一个日志条目（3）并从节点 1 下载新片段（4）来重放该条目，而节点 3 则重放两个日志条目（3 4 5 6）。最后，节点 3 将两个片段合并为一个新片段，删除输入片段，并在复制日志中记录合并条目（7）。

<Anchor id="page-5-3"/><Image img={image_06} size="lg" alt="Image 06"/>

图 6：在三节点集群中的复制示例。

三种优化方法可加速同步：首先，加入集群的新节点并不从头重播复制日志，而是简单地复制写入最后一个复制日志条目的节点的状态。其次，合并通过重复本地合并或从其他节点获取结果片段进行重播。具体行为是可配置的，可以平衡 CPU 消耗和网络 I/O。例如，跨数据中心复制通常更倾向于本地合并以降低运营成本。第三，节点并行重放互相独立的复制日志条目。这包括例如，连续插入同一表的新片段的获取，或在不同表上的操作。

### <Anchor id="page-5-1"/>3.7 ACID 合规性 {#3-7-acid-compliance}

为了最大化并发读写操作的性能，ClickHouse 尽可能避免加锁。查询是针对在查询开始时创建的所有相关表中所有片段的快照执行的。这确保了由并行 INSERT 或合并（第 [3.1 节](#page-2-2)）插入的新片段不参与执行。为了防止片段被同时修改或删除（第 [3.4 节](#page-4-0)），在查询执行期间处理的片段的引用计数会增加。正式地，这对应于通过基于版本的片段实现的快照隔离。结果是，语句通常不符合 ACID，除非在快照拍摄时并发写入每次只影响单个片段的罕见情况。

实际上，ClickHouse 的大多数写重决策使用案例即使在断电情况下也容忍小的丢失新数据的风险。数据库利用这一点，默认情况下不强制将新插入的片段提交（fsync）到磁盘，而是允许内核批量写入，从而放弃原子性。

## <Anchor id="page-6-0"/>4 查询处理层 {#4-query-processing-layer}

<Anchor id="page-6-1"/><Image img={image_07} size="lg" alt="Image 07"/>

图 7：在 SIMD 单元、核心和节点之间的并行化示意图。

如[图 7](#page-6-1)所示，ClickHouse 在数据元素、数据块和表分片层面并行化查询。多个数据元素可以在操作符内同时使用 SIMD 指令处理。在单个节点上，查询引擎同时在多个线程中执行操作符。ClickHouse 使用与 MonetDB/X100 相同的向量化模型 [\[11\]](#page-12-0)，即操作符生成、传递和消费多个行（数据块），而不是单行，以最小化虚拟函数调用的开销。如果源表被拆分为不相交的表分片，多个节点可以同时扫描这些分片。因此，所有硬件资源得到了充分利用，并且可以通过添加节点和通过添加内核水平扩展查询处理。

本节的其余部分首先详细描述数据元素、数据块和分片粒度的并行处理。然后，我们介绍一些关键优化，以最大化查询性能。最后，我们讨论 ClickHouse 如何在存在并发查询的情况下管理共享系统资源。

### 4.1 SIMD 并行化 {#4-1-simd-parallelization}

在操作符之间传递多个行创建了向量化的机会。向量化基于手动编写的内在函数 [\[64,](#page-13-18) [80\]](#page-13-19) 或编译器自动向量化 [\[25\]](#page-12-19)。受益于向量化的代码被编译为不同的计算内核。例如，查询操作符的内部热循环可以基于非向量化内核、自动向量化的 AVX2 内核和手动向量化的 AVX-512 内核来实现。运行时根据 cpuid 指令选择最快的内核。这个方法使 ClickHouse 可以在最老的系统（最低要求 SSE 4.2）上运行，同时在最新硬件上提供显著的性能提升。

### 4.2 多核并行化 {#4-2-multi-core-parallelization}

<Anchor id="page-7-1"/><Image img={image_08} size="lg" alt="Image 08"/>

图 8：具有三个通道的物理操作计划。

ClickHouse 采用传统方法 [\[31\]](#page-12-13)，将 SQL 查询转换为物理计划操作符的有向图。操作符计划的输入由读取原生数据或任何受支持的第三方格式的数据的特殊源操作符表示（参见第 [5 节](#page-9-0)）。同样，特殊的汇操作符将结果转换为所需的输出格式。在查询编译时，物理操作计划根据可配置的最大工作线程数量（默认情况下为核心数）和源表的大小展开为独立的执行通道。通道将要由并行操作符处理的数据分解为不重叠的范围。为了最大化并行处理的机会，通道在最后合并。

例如，[图 8](#page-7-1)中节点 1 的框显示了对具有页面展示统计的表的典型 OLAP 查询的操作符图。在第一阶段，源表的三个不相交范围被同时过滤。一个重新分区交换操作符动态路由结果块以保持处理线程均匀利用。如果扫描范围的选择性差异显著，在第一阶段后通道可能会变得不平衡。在第二阶段，存活的行按 RegionID 分组。聚合操作符维护以 RegionID 为分组列的本地结果组，并为 avg() 提供每组的总和和计数作为部分聚合状态。本地聚合结果最终由 GroupStateMerge 操作符合并为全局聚合结果。该操作符也是管道断路器，即只有在聚合结果完全计算后，第三阶段才能开始。在第三阶段，结果组首先通过一个分发交换操作符分成三个同样大的不相交分区，然后按 AvgLatency 排序。排序分为三个步骤：首先，ChunkSort 操作符对每个分区的单个块进行排序。其次，StreamSort 操作符维护一个本地排序结果，该结果与通过 2 路合并排序的新排序块结合。最后，MergeSort 操作符使用 k 路排序结合本地结果以获得最终结果。

操作符是状态机，并通过输入和输出端口互相连接。操作符的三个可能状态是需要块、准备好和完成。这些状态之间的转换如下：从需要块到准备好，必须将在操作符的输入端口中放置一个块；从准备好到完成，操作符处理输入块并生成输出块；从完成到需要块，输出块从操作符的输出端口中移除。两个连接操作符中的第一次和第三次状态转换只能在一个组合步骤中执行。源操作符（汇操作符）只有准备好和完成两个状态（需要块和完成）。

工作线程不断遍历物理操作计划，并执行状态转换。为了保持 CPU 缓存热，计划中包含提示，以指示同一线程应在同一通道中处理连续的操作符。并行处理发生在多个输入之间的水平（例如，在 [图 8](#page-7-1) 中，聚合操作符同时执行）和在未被管道断路器分隔的阶段之间的垂直（例如，在 [图 8](#page-7-1) 中，同一通道的过滤器和聚合操作符可以同时运行）。为了避免在新查询开始时或并发查询结束时出现过度和不足的订阅，可以在查询过程中根据查询开始时指定的查询工作线程最大数量和一个之间动态调整并行度（参见第 [4.5 节](#page-9-1)）。

操作符还可以以两种方式在运行时进一步影响查询执行。首先，操作符可以动态创建并连接新的操作符。这主要用于在内存消耗超过可配置阈值时切换到外部聚合、排序或连接算法，而不是取消查询。其次，操作符可以请求工作线程移入异步队列。这在等待远程数据时提供了更有效的工作线程使用。

ClickHouse 的查询执行引擎和基于小块驱动的并行性 [\[44\]](#page-12-20) 在于通道通常在不同的核心/ NUMA 套接字上执行，并且工作线程可以从其他通道窃取任务。此外，也没有中央调度组件；相反，工作线程通过不断遍历操作符计划单独选择其任务。与基于小块驱动的并行性不同，ClickHouse 将最大并行度直接纳入计划中，并使用更大的范围来划分源表，与默认的小块大小大约为 100,000 行相比。这在某些情况下可能导致阻塞（例如，当不同通道中过滤器操作符的运行时差异很大时），但我们发现，广泛使用的交换操作符（例如重新分区）至少可以避免这样的不平衡在各个阶段之间的积累。

### 4.3 多节点并行化 {#4-3-multi-node-parallelization}

如果查询的源表经过分片，接收查询的节点上的查询优化器（发起节点）尽量在其他节点上执行尽可能多的工作。来自其他节点的结果可以在查询计划的不同点集成。根据查询情况，远程节点可以 1. 将原始源表列流式传输到发起节点，2. 过滤源列并发送生存下来的行，3. 执行过滤和聚合步骤，并发送具有部分聚合状态的本地结果组，或 4. 运行整个查询，包括过滤、聚合和排序。

[图 8](#page-7-1)中的节点 2 ... N 显示了在持有命中表的分片的其他节点上执行的计划片段。这些节点过滤和分组本地数据，然后将结果发送到发起节点。节点 1 上的 GroupStateMerge 操作符合并本地和远程结果，然后最后对结果组排序。

### <Anchor id="page-7-0"/>4.4 整体性能优化 {#4-4-holistic-performance-optimization}

本节介绍应用于查询执行不同阶段的几个关键性能优化。

**查询优化**。第一组优化应用于语义查询表示之上，语义查询表示来源于查询的 AST。这类优化的例子包括常量折叠（例如，concat(lower('a'),upper('b')) 变为 'aB'）、从某些聚合函数中提取标量（例如，sum(a*2) 变为 2 * sum(a)）、共同子表达式消除以及将相等过滤器的并联变换为 IN 列表（例如，x=c 或 x=d 变为 x IN (c,d)）。经过优化的语义查询表示随后转换为逻辑操作计划。基于逻辑计划的优化包括过滤下推、重新排列函数评估和排序步骤，具体取决于哪一个估计更加昂贵。最后，逻辑查询计划被转换为物理操作计划。这个转换可以利用所涉及表引擎的特殊性。例如，在 MergeTree*-表引擎的情况下，如果 ORDER BY 列形成主键的前缀，则可以按照磁盘顺序读取数据，并且可以从计划中删除排序操作符。此外，如果聚合中的分组列形成主键的前缀，ClickHouse 可以使用排序聚合，即直接聚合预排序输入中相同值的运行。与哈希聚合相比，排序聚合显著减少了内存使用，并且聚合值可以在运行处理之后立即传递给下一个操作符。

**查询编译**。ClickHouse 采用 [基于 LLVM 的查询编译](https://clickhou.se/jit) 动态融合相邻的计划操作符 [\[38,](#page-12-22) [53\]](#page-13-0)。例如，表达式 a * b + c + 1 可以合并为一个操作符，而不是三个操作符。除了表达式外，ClickHouse 还用于评估一次性处理多个聚合函数（即用于 GROUP BY）和具有多个排序键的排序时的编译。查询编译减少了虚拟调用的数量，将数据保存在寄存器或 CPU 缓存中，并对分支预测有所帮助，因为需要执行的代码更少。此外，运行时编译使得丰富的优化集成为可能，例如编译器中实现的逻辑优化和局部优化，并使得能访问到最快的本地可用 CPU 指令。编译仅当相同的常规、聚合或排序表达式被不同查询执行超过可配置次数时才会启动。编译后的查询操作符会被缓存，并可以被后续查询重用。

**主键索引评估**。如果条件的合取范式中的一部分过滤子句构成主键列的前缀，ClickHouse 会使用主键索引来评估 WHERE 条件。主键索引从左到右分析按字典序排序的键值范围。与主键列对应的过滤子句使用三元逻辑评估-它们在范围内均为真、均为假或混合真/假。在后者情况下，该范围被拆分为子范围，递归分析。对于过滤条件中的函数还有其他优化。首先，函数具有描述其单调性的特征，例如，toDayOfMonth(date) 在一个月内分段单调。单调性特征允许推断一个函数是否对排序的输入键值范围产生排序结果。其次，某些函数可以计算给定函数结果的原像。这用于将常量的比较替换为键列上的函数调用，通过比较键列值与原像。例如，可以将 toYear(k) = 2024 替换为 k >= 2024-01-01 && k < 2025-01-01。

**数据跳过**。ClickHouse 尝试在查询运行时避免对数据的读取，使用第 [3.2 节](#page-3-0) 中介绍的数据结构。此外，针对不同列的过滤子句按下降的估计选择性顺序依次进行评估，基于启发式和（可选）的列统计信息。只有包含至少一个匹配行的数据块会被传递到下一个谓词。这逐渐减少了从谓词到谓词所需读取的数据量和要执行的计算数量。只有在至少存在一个高选择性谓词的情况下才会应用该优化，否则查询延迟会相较于并行评估所有谓词而恶化。

**哈希表**。哈希表是用于聚合和哈希连接的基本数据结构。选择合适类型的哈希表对性能至关重要。ClickHouse [实例化](https://clickhou.se/hashtables) 多种哈希表（截至 2024 年 3 月已超过 30 种），从通用哈希表模板中选择哈希函数、分配器、单元类型和调整大小策略作为可变点。根据分组列的数据类型、估计的哈希表基数和其他因素，为每个查询操作符单独选择速度最快的哈希表。为哈希表实施的其他优化包括：

- 使用 256 个子表的两级布局（基于哈希的第一个字节）以支持庞大的键集，
- 字符串哈希表 [\[79\]](#page-13-20) 具有四个子表和针对不同字符串长度的不同哈希函数，
- 查找表在只有少量键时直接使用键作为桶索引（即无哈希），
- 带有嵌入哈希值的值，用于在比较代价高昂时更快地解决冲突（例如字符串、AST），
- 基于运行时统计数据预测大小创建哈希表，以避免不必要的调整，
- 在单个内存块上分配多个具有相同创建/销毁生命周期的小哈希表，
- 使用每个哈希映射和每个单元版本计数器立即清除哈希表以供重用，
- 利用 CPU 预取（__builtin_prefetch）加速在对键进行哈希后检索的值。

**连接**。由于 ClickHouse 最初仅支持 rudimentary 连接，许多用例在历史上依赖于非规范化表。如今，数据库 [提供](https://clickhou.se/joins) SQL 中的所有连接类型（内连接、左/右/全外连接、交叉连接、随时间变化的连接），以及不同的连接算法，例如哈希连接（简单、优雅）、排序-合并连接和针对具有快速键值查找的表引擎的索引连接（通常是字典）。

由于连接是数据库中成本最高的操作之一，对于经典连接算法提供并行变体是重要的，理想的情况下需具备可配置的空间/时间权衡。对于哈希连接，ClickHouse 实现了非阻塞的共享分区算法 [\[7\]](#page-12-23)。例如，[图 9](#page-8-3) 中的查询计算用户在页面点击统计表中如何在 URL 之间移动。连接的构建阶段被拆分为三个通道，覆盖源表的三个不相交范围。使用分区哈希表，而不是全局哈希表。工作线程（通常是三个）通过计算哈希函数的模来确定构建侧每个输入行的目标分区。对哈希表分区的访问通过 Gather 交换操作符进行同步。探测阶段也以类似的方式查找其输入元组的目标分区。虽然该算法在每个元组中引入两个额外的哈希计算，但它大大减少了构建阶段的锁争用，具体取决于哈希表分区的数量。

<Anchor id="page-8-3"/><Image img={image_09} size="lg" alt="Image 09"/>

图 9：具有三个哈希表分区的并行哈希连接。

### <Anchor id="page-9-1"/>4.5 工作负载隔离 {#4-5-workload-isolation}

ClickHouse 提供并发控制、内存使用限制和 I/O 调度，使用户能够将查询隔离到工作负载类别中。通过为特定工作负载类别设置共享资源（CPU 核心、DRAM、磁盘和网络 I/O）的限制，它确保这些查询不会影响其他关键业务查询。

并发控制防止在并发查询数量较高的情况下产生线程过度分配。更具体地说，每个查询的工作线程数会根据指定的比例动态调整与可用 CPU 核心的数量之间的关系。

ClickHouse 跟踪在服务器、用户和查询级别的内存分配字节大小，从而允许设置灵活的内存使用限制。内存超分配允许查询在保证内存之外使用额外的可用内存，同时保证其他查询的内存限制。此外，可以限制聚合、排序和连接子句的内存使用，一旦超过内存限制，就会回退到外部算法。

最后，I/O 调度允许用户基于最大带宽、进行中的请求和策略（例如，FIFO、SFC [\[32\]](#page-12-24)）限制工作负载类别的本地和远程磁盘访问。

### <Anchor id="page-9-0"/>5 集成层 {#5-integration-layer}

实时决策应用程序通常依赖于对多个位置的数据进行高效的低延迟访问。有两种方法可以使外部数据在 OLAP 数据库中可用。使用基于推送的数据访问，第三方组件将数据库与外部数据存储连接起来。一个例子是专门的提取-转换-加载（ETL）工具，它将远程数据推送到目标系统。在基于拉取的模型中，数据库本身连接到远程数据源，将数据拉取到本地表中进行查询，或将数据导出到远程系统。虽然基于推送的方法更具灵活性和常见性，但它们涉及更大的架构占用和可扩展性瓶颈。相比之下，数据库直接的远程连接提供了有趣的功能，例如在本地数据和远程数据之间进行连接，同时保持整体架构简单并缩短洞察时间。

本节的其余部分探讨 ClickHouse 中的基于拉取的数据集成方法，旨在访问远程位置的数据。我们注意到在 SQL 数据库中远程连接的理念并不新鲜。例如，SQL/MED 标准 [\[35\]](#page-12-25)，在 2001 年引入并自 2011 年以来由 PostgreSQL 实现 [\[65\]](#page-13-21)，建议外部数据包装器作为管理外部数据的统一接口。与其他数据存储和存储格式的最大互操作性是 ClickHouse 的设计目标之一。截至 2024 年 3 月，ClickHouse 提供了我们所知的在所有分析数据库中最丰富的内置数据集成选项。

外部连接性。ClickHouse 提供 [50+](https://clickhou.se/query-integrations) 积分表函数和引擎，以连接外部系统和存储位置，包括 ODBC、MySQL、PostgreSQL、SQLite、Kafka、Hive、MongoDB、Redis、S3/GCP/Azure 对象存储和各种数据湖。我们将它们进一步分为以下附加图表中显示的类别（不是原始 vldb 论文的一部分）。

<Anchor id="bonus-figure"/><Image img={image_10} size="lg" alt="Image 10"/>

附加图：ClickBench 的互操作选项。

通过集成 **表函数** 实现临时访问。表函数可以在 SELECT 查询的 FROM 子句中调用，以读取远程数据进行探索性临时查询。或者，它们可以用于使用 INSERT INTO TABLE FUNCTION 语句将数据写入远程存储。

持久访问。有三种方法可以与远程数据存储和处理系统建立长期连接。

首先，集成 **表引擎** 将远程数据源（例如 MySQL 表）表示为持久的本地表。用户使用 CREATE TABLE AS 语法存储表定义，并与 SELECT 查询和表函数结合使用。可以指定自定义架构，例如仅引用远程列的子集，或使用架构推断自动确定列名和等效的 ClickHouse 类型。我们进一步区分被动和主动运行时行为：被动表引擎将查询转发到远程系统，并用结果填充本地代理表。相比之下，主动表引擎定期从远程系统拉取数据，或订阅远程更改，例如通过 PostgreSQL 的逻辑复制协议。因此，本地表包含远程表的完整副本。

第二，集成 **数据库引擎** 将远程数据存储中的所有表映射到 ClickHouse 中的一个表架构。与前者不同，它们通常要求远程数据存储为关系数据库，并提供对 DDL 语句的有限支持。

第三，**字典** 可使用针对几乎所有可能数据源的任意查询进行填充，方法是相应的集成表函数或引擎。运行时行为是主动的，因为数据是以恒定的间隔从远程存储中拉取的。

数据格式。为了与第三方系统进行交互，现代分析数据库还必须能够处理任何格式的数据。除了其本机格式外，ClickHouse 还支持 [90+](https://clickhou.se/query-formats) 种格式，包括 CSV、JSON、Parquet、Avro、ORC、Arrow 和 Protobuf。每种格式可以是输入格式（ClickHouse 可以读取），输出格式（ClickHouse 可以导出），或两者兼而有之。一些面向分析的格式，如 Parquet，亦与查询处理集成，即优化器可以利用嵌入统计信息，过滤器直接在压缩数据上评估。

兼容性接口。除了其原生的二进制传输协议和 HTTP，客户端还可以通过与 MySQL 或 PostgreSQL 传输协议兼容的接口与 ClickHouse 交互。此兼容性特性对于启用来自专有应用程序（例如某些商业智能工具）的访问非常有用，因为供应商尚未实现原生 ClickHouse 连接。

## 6 性能作为一种特性 {#6-performance-as-a-feature}

本节展示了用于性能分析的内置工具，并使用实际和基准查询评估性能。

### 6.1 内置性能分析工具 {#6-1-built-in-performance-analysis-tools}

可用一系列工具来调查单个查询或后台操作中的性能瓶颈。用户通过基于系统表的统一接口与所有工具交互。

**服务器和查询指标**。服务器级别的统计信息，如活动片段计数、网络吞吐量和缓存命中率，辅以逐查询统计信息，例如读取的块数或索引使用统计信息。指标可以在请求时同步计算，或在可配置的间隔内异步计算。

**采样分析器**。可以使用采样分析器收集服务器线程的调用堆栈。结果可以选择性地导出到外部工具，如火焰图可视化工具。

**OpenTelemetry 集成**。OpenTelemetry 是一种在多个数据处理系统中跟踪数据行的开放标准 [\[8\]](#page-12-26)。ClickHouse 可以为所有查询处理步骤生成具有可配置粒度的 OpenTelemetry 日志跨度，并收集和分析来自其他系统的 OpenTelemetry 日志跨度。

**解释查询**。与其他数据库一样，SELECT 查询可以通过 EXPLAIN 前置，以获取对查询 AST、逻辑和物理操作计划及执行时行为的详细见解。

### 6.2 基准测试 {#6-2-benchmarks}

尽管基准测试因不够现实而受到批评 [\[10\]](#page-12-27) [52,](#page-13-22) [66,](#page-13-23) [74\]](#page-13-24)，但它仍然有助于识别数据库的优缺点。接下来，我们讨论基准测试如何用于评估 ClickHouse 的性能。
#### 6.2.1 非规范化表 {#6-2-1-denormalized-tables}

对非规范化事实表的过滤和聚合查询历史上代表了 ClickHouse 的主要用例。我们报告了 ClickBench 的运行时间，这是一个典型的工作负载，模拟了在点击流和流量分析中使用的临时和定期报告查询。基准测试由 43 个查询组成，这些查询针对一个包含 1 亿个匿名页面点击的表，该数据源自网络上最大的分析平台之一。一个在线仪表板 [\[17\]](#page-12-28) 显示截至 2024 年 6 月的 45 个以上商业和研究数据库的测量数据（冷/热运行时间、数据导入时间、磁盘大小）。结果由独立贡献者提交，基于公开可用的数据集和查询 [\[16\]](#page-12-29)。这些查询测试顺序和索引扫描访问路径，并常规暴露 CPU、IO 或内存绑定的关系操作符。

[图 10](#page-10-0) 显示了在常用于分析的数据库中顺序执行所有 ClickBench 查询的总体相对冷和热运行时间。测量是在单节点 AWS EC2 c6a.4xlarge 实例上进行的，该实例具有 16 个 vCPU、32 GB RAM 和 5000 IOPS / 1000 MiB/s 磁盘。用于 Redshift 的系统（[ra3.4xlarge](https://clickhou.se/redshift-sizes)，12 个 vCPU、96 GB RAM）和 Snowfake 的系统（[仓库大小 S](https://clickhou.se/snowflake-sizes): 2x8 vCPU，2x16 GB RAM）也采用了可比的架构。物理数据库设计仅进行了轻微调整，例如，我们指定了主键，但不更改单独列的压缩，不创建投影或跳过索引。在每个冷查询运行之前，我们还会清空 Linux 页面缓存，但不调整数据库或操作系统的设定。对于每个查询，选取所有数据库中最快的运行时间作为基线。其他数据库的相对查询运行时间计算为 ( + 10)/(_ + 10)。某个数据库的总相对运行时间是每个查询比率的几何平均值。虽然研究数据库 Umbra [\[54\]](#page-13-25) 实现了最佳的整体热运行时间，但 ClickHouse 在热和冷运行时间上优于所有其他生产级数据库。

<Anchor id="page-10-0"/><Image img={image_11} size="lg" alt="图 11"/>

图 10: ClickBench 的相对冷和热运行时间。

为了随着时间的推移跟踪在更复杂工作负载下 SELECT 的性能，我们 [使用](https://clickhou.se/performance-over-years) 一种名为 VersionsBench 的四重基准组合 [\[19\]](#page-12-30)。每当发布新版本时，此基准每月执行一次，以评估其性能 [\[20\]](#page-12-31)，并确定可能导致性能下降的代码变更：个别基准包括：1. ClickBench（如上所述），2. 15 个 MgBench [\[21\]](#page-12-32) 查询，3. 针对包含 6 亿行的非规范化星型模式基准 [\[57\]](#page-13-26) 事实表的 13 个查询。4. 针对 [NYC Taxi Rides](https://clickhou.se/nyc-taxi-rides-benchmark) 的 4 个查询，该查询包含 34 亿行 [\[70\]](#page-13-27)。

[图 11](#page-10-5) 显示了 2018 年 3 月到 2024 年 3 月间 77 个 ClickHouse 版本的 VersionsBench 运行时间的发展情况。为了补偿单个查询相对运行时间的差异，我们使用几何平均对运行时间进行标准化，采用相对于所有版本中最小查询运行时间的比率作为权重。在过去六年中，VersionBench 的性能提高了 1.72 ×。具有长期支持（LTS）的版本发布日期在 x 轴上标记。尽管有些时候性能暂时下降，但 LTS 版本通常具有与之前 LTS 版本相当或更好的性能。2022 年 8 月的显著改善是由第 [4.4](#page-7-0) 节中描述的逐列过滤评估技术引起的。

<Anchor id="page-10-5"/><Image img={image_12} size="lg" alt="图 12"/>

图 11: 2018-2024 年 VersionsBench 的相对热运行时间。
#### 6.2.2 规范化表 {#6-2-2-normalized-tables}

在经典仓库中，数据通常使用星型或雪花模式建模。我们展示了 TPC-H 查询（规模因子 100）的运行时间，但指出规范化表是 ClickHouse 的一个新兴用例。 [图 12](#page-10-6) 显示了基于第 [4.4](#page-7-0) 节中描述的并行哈希连接算法的 TPC-H 查询的热运行时间。测量是在单节点 AWS EC2 c6i.16xlarge 实例上进行的，该实例具有 64 个 vCPU、128 GB RAM 和 5000 IOPS / 1000 MiB/s 磁盘。记录了五次运行中最快的一次。作为参考，我们在一个可比大小的 Snowfake 系统（仓库大小 L，8x8 vCPU，8x16 GB RAM）中进行了相同的测量。表中排除了 11 个查询的结果：查询 Q2、Q4、Q13、Q17 和 Q20-22 包含 ClickHouse v24.6 版本不支持的相关子查询。查询 Q7-Q9 和 Q19 依赖于连接的扩展计划级优化，例如连接重排序和连接谓词下推（在 ClickHouse v24.6 中都缺失），以实现可行的运行时间。自动子查询去相关和更好的连接优化器支持计划于 2024 年实施 [\[18\]](#page-12-33)。在其余 11 个查询中，有 5 个（6 个）查询在 ClickHouse 中执行得更快（Snowfake）。如前所述，这些优化已知对性能至关重要 [\[27\]](#page-12-34)，我们预计一旦实施它们将进一步改善这些查询的运行时间。

<Anchor id="page-10-6"/><Image img={image_13} size="lg" alt="图 13"/>

图 12: TPC-H 查询的热运行时间（以秒为单位）。
## 7 相关工作 {#7-related-work}

分析数据库在近几十年间一直受到学术界和商业界的高度关注 [\[1\]](#page-12-35)。早期的系统如 Sybase IQ [\[48\]](#page-13-28)、Teradata [\[72\]](#page-13-29)、Vertica [\[42\]](#page-12-36) 和 Greenplum [\[47\]](#page-13-30) 的特点是昂贵的批处理 ETL 任务和由于其本地部署性质而有限的弹性。2010 年代初，云原生数据仓库和数据库即服务（DBaaS）产品的出现，如 Snowfake [\[22\]](#page-12-37)、BigQuery [\[49\]](#page-13-31) 和 Redshift [\[4\]](#page-12-38)，大幅降低了组织进行分析的成本和复杂性，同时受益于高可用性和自动资源扩展。最近，分析执行内核（例如 Photon [\[5\]](#page-12-39) 和 Velox [\[62\]](#page-13-32)）为在不同分析、流处理和机器学习应用中使用的协同数据处理提供了可能。

与 ClickHouse 在目标和设计原则方面最相似的数据库是 Druid [\[78\]](#page-13-33) 和 Pinot [\[34\]](#page-12-40)。这两个系统针对具有高数据摄取率的实时分析。与 ClickHouse 一样，表被分割成称为段的水平部分。虽然 ClickHouse 持续合并较小的部分，并可选择性地通过第 [3.3](#page-4-3) 节中的技术减少数据量，但 Druid 和 Pinot 中的分片永远保持不可变。此外，Druid 和 Pinot 需要专用节点来创建、修改和搜索表，而 ClickHouse 则使用单一的二进制文件执行这些任务。

Snowfake [\[22\]](#page-12-37) 是一个受欢迎的基于共享磁盘架构的专有云数据仓库。其将表划分为微分区的方法与 ClickHouse 中分片的概念相似。Snowfake 使用混合 PAX 页面 [\[3\]](#page-12-41) 进行持久化，而 ClickHouse 的存储格式则严格为列式。Snowfake 还强调使用自动创建的轻量级索引 [\[31,](#page-12-13) [51\]](#page-13-14) 进行本地缓存和数据裁剪以获得良好性能。与 ClickHouse 的主键类似，用户可以选择性地创建聚集索引，以将具有相同值的数据放在一起。

Photon [\[5\]](#page-12-39) 和 Velox [\[62\]](#page-13-32) 是查询执行引擎，旨在作为复杂数据管理系统中的组件使用。这两个系统接收查询计划作为输入，随后在本地节点上针对 Parquet（Photon）或 Arrow（Velox）文件执行 [\[46\]](#page-13-34)。ClickHouse 能够消费和生成这些通用格式的数据，但更喜欢其本地文件格式进行存储。虽然 Velox 和 Photon 不优化查询计划（Velox 执行基本的表达式优化），但它们利用运行时自适应技术，例如根据数据特征动态切换计算内核。同样，ClickHouse 中的计划操作符可以在运行时创建其他操作符，主要目的是在查询内存消耗的基础上切换到外部聚合或连接操作符。Photon 论文指出，代码生成设计 [\[38,](#page-12-22) [41,](#page-12-42) [53\]](#page-13-0) 比解释型向量化设计 [\[11\]](#page-12-0) 更难开发和调试。在 Velox 的支持下，代码生成会构建并链接由运行时生成的 C++ 代码生成的共享库，而 ClickHouse 则直接与 LLVM 的按需编译 API 交互。

DuckDB [\[67\]](#page-13-6) 也旨在被主机进程嵌入，但还提供查询优化和事务。它设计用于 OLAP 查询并混合偶尔的 OLTP 语句。DuckDB 相应地选择了 DataBlocks [\[43\]](#page-12-43) 存储格式，该格式采用轻量级压缩方法，如保持顺序的字典或参考框架 [\[2\]](#page-12-10) ，以在混合工作负载中实现良好的性能。相比之下，ClickHouse 针对仅追加的用例进行了优化，即没有或很少的更新和删除。块使用重型技术（如 LZ4）进行压缩，假设用户自由使用数据裁剪以加速频繁查询，并且 I/O 成本相较于剩余查询的解压缩成本更高。DuckDB 还基于 Hyper 的 MVCC 方案提供可序列化的事务 [\[55\]](#page-13-35)，而 ClickHouse 仅提供快照隔离。
## 8 结论与展望 {#8-conclusion-and-outlook}

我们介绍了 ClickHouse 的架构，这是一个开源的高性能 OLAP 数据库。以写优化的存储层和最先进的向量化查询引擎为基础，ClickHouse 可以对每个 PB 级数据集执行实时分析，同时具有高摄取率。通过在后台异步合并和转换数据，ClickHouse 有效地解耦了数据维护和并行插入。其存储层使用稀疏主索引、跳过索引和投影表支持激进的数据裁剪。我们描述了 ClickHouse 的更新和删除、幂等插入和节点间数据复制的实现，以支持高可用性。查询处理层利用丰富的技术来优化查询，并在所有服务器和集群资源之间并行执行。集成表引擎和函数提供了一种方便的方式与其他数据管理系统和数据格式无缝交互。通过基准测试，我们证明 ClickHouse 是市场上最快的分析数据库之一，并展示了 ClickHouse 在现实部署中典型查询性能的显著改善。

所有计划于 2024 年实施的功能和增强内容可以在公开路线图上找到 [\[18\]](#page-12-33)。计划的改进包括对用户事务的支持、PromQL [\[69\]](#page-13-36) 作为替代查询语言、用于半结构化数据的新数据类型（例如 JSON）、连接的更好计划级优化，以及轻量级更新的实现，以补充轻量级删除。
## 致谢 {#acknowledgements}

根据版本 24.6，SELECT * FROM system.contributors 返回 1994 名对 ClickHouse 做出贡献的个人。我们要感谢 ClickHouse Inc. 的整个工程团队和 ClickHouse 的优秀开源社区，感谢他们在一起构建这个数据库上的辛勤工作和奉献。
## REFERENCES {#references}

- <Anchor id="page-12-35"/>[1] Daniel Abadi, Peter Boncz, Stavros Harizopoulos, Stratos Idreaos, 和 Samuel Madden. 2013. 现代列式数据库系统的设计与实现. https://doi.org/10.1561/9781601987556
- <Anchor id="page-12-10"/>[2] Daniel Abadi, Samuel Madden, 和 Miguel Ferreira. 2006. 在列式数据库系统中整合压缩与执行. 在2006年ACM SIGMOD管理数据国际会议论文集 (SIGMOD '06). 671–682. https://doi.org/10.1145/1142473.1142548
- <Anchor id="page-12-41"/>[3] Anastassia Ailamaki, David J. DeWitt, Mark D. Hill, 和 Marios Skounakis. 2001. 为缓存性能编织关系. 在第27届国际超大规模数据库会议论文集 (VLDB '01). Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 169–180.
- <Anchor id="page-12-38"/>[4] Nikos Armenatzoglou, Sanuj Basu, Naga Bhanoori, Mengchu Cai, Naresh Chainani, Kiran Chinta, Venkatraman Govindaraju, Todd J. Green, Monish Gupta, Sebastian Hillig, Eric Hotinger, Yan Leshinksy, Jintian Liang, Michael McCreedy, Fabian Nagel, Ippokratis Pandis, Panos Parchas, Rahul Pathak, Orestis Polychroniou, Foyzur Rahman, Gaurav Saxena, Gokul Soundararajan, Sriram Subramanian, 和 Doug Terry. 2022. 重新定义 Amazon Redshift. 在2022年国际管理数据会议论文集 (费城, PA, 美国) (SIGMOD '22). Association for Computing Machinery, New York, NY, USA, 2205–2217. https://doi.org/10.1145/3514221.3526045
- <Anchor id="page-12-39"/>[5] Alexander Behm, Shoumik Palkar, Utkarsh Agarwal, Timothy Armstrong, David Cashman, Ankur Dave, Todd Greenstein, Shant Hovsepian, Ryan Johnson, Arvind Sai Krishnan, Paul Leventis, Ala Luszczak, Prashanth Menon, Mostafa Mokhtar, Gene Pang, Sameer Paranjpye, Greg Rahn, Bart Samwel, Tom van Bussel, Herman van Hovell, Maryann Xue, Reynold Xin, 和 Matei Zaharia. 2022. Photon: 一个快速的查询引擎用于数据湖系统 (SIGMOD '22). Association for Computing Machinery, New York, NY, USA, 2326–2339. [https://doi.org/10.1145/3514221.](https://doi.org/10.1145/3514221.3526054) [3526054](https://doi.org/10.1145/3514221.3526054)
- <Anchor id="page-12-18"/>[6] Philip A. Bernstein 和 Nathan Goodman. 1981. 分布式数据库系统中的并发控制. ACM Computing Survey 13, 2 (1981), 185–221. https://doi.org/10.1145/356842.356846
- <Anchor id="page-12-23"/>[7] Spyros Blanas, Yinan Li, 和 Jignesh M. Patel. 2011. 设计与评估面向多核CPU的主内存哈希连接算法. 在2011年ACM SIGMOD国际管理数据会议论文集 (雅典, 希腊) (SIGMOD '11). Association for Computing Machinery, New York, NY, USA, 37–48. https://doi.org/10.1145/1989323.1989328
- <Anchor id="page-12-26"/><Anchor id="page-12-14"/>[8] Daniel Gomez Blanco. 2023. 实用的 OpenTelemetry. Springer Nature.
- [9] Burton H. Bloom. 1970. 允许错误的哈希编码中的空间/时间权衡. Commun. ACM 13, 7 (1970), 422–426. [https://doi.org/10.1145/362686.](https://doi.org/10.1145/362686.362692) [362692](https://doi.org/10.1145/362686.362692)
- <Anchor id="page-12-27"/>[10] Peter Boncz, Thomas Neumann, 和 Orri Erling. 2014. TPC-H 分析：从一个有影响力的基准中的隐藏信息和教训. 在性能特征和基准测试中. 61–76. [https://doi.org/10.1007/978-3-319-](https://doi.org/10.1007/978-3-319-04936-6_5) [04936-6_5](https://doi.org/10.1007/978-3-319-04936-6_5)
- <Anchor id="page-12-0"/>[11] Peter Boncz, Marcin Zukowski, 和 Niels Nes. 2005. MonetDB/X100: 超级管道查询执行. 在CIDR.
- <Anchor id="page-12-8"/>[12] Martin Burtscher 和 Paruj Ratanaworabhan. 2007. 高通量双精度浮点数据压缩. 在数据压缩会议 (DCC). 293–302. https://doi.org/10.1109/DCC.2007.44
- <Anchor id="page-12-6"/>[13] Jef Carpenter 和 Eben Hewitt. 2016. Cassandra: 权威指南 (第二版). O'Reilly Media, Inc.
- <Anchor id="page-12-17"/>[14] Bernadette Charron-Bost, Fernando Pedone, 和 André Schiper (Eds.). 2010. 复制：理论与实践. Springer-Verlag.
- <Anchor id="page-12-3"/>[15] chDB. 2024. chDB - 嵌入式OLAP SQL引擎. 取自2024-06-20 https://github.com/chdb-io/chdb
- <Anchor id="page-12-29"/>[16] ClickHouse. 2024. ClickBench: 分析数据库基准测试. 取自2024-06-20 https://github.com/ClickHouse/ClickBench
- <Anchor id="page-12-28"/>[17] ClickHouse. 2024. ClickBench: 比较测量. 取自2024-06-20 https://benchmark.clickhouse.com
- <Anchor id="page-12-33"/>[18] ClickHouse. 2024. ClickHouse 2024路线图 (Github). 取自2024-06-20 https://github.com/ClickHouse/ClickHouse/issues/58392
- <Anchor id="page-12-30"/>[19] ClickHouse. 2024. ClickHouse版本基准. 取自2024-06-20 https://github.com/ClickHouse/ClickBench/tree/main/versions
- <Anchor id="page-12-31"/>[20] ClickHouse. 2024. ClickHouse版本基准结果. 取自2024-06-20 https://benchmark.clickhouse.com/versions/
- <Anchor id="page-12-32"/>[21] Andrew Crotty. 2022. MgBench. 取自2024-06-20 [https://github.com/](https://github.com/andrewcrotty/mgbench) [andrewcrotty/mgbench](https://github.com/andrewcrotty/mgbench)
- <Anchor id="page-12-37"/>[22] Benoit Dageville, Thierry Cruanes, Marcin Zukowski, Vadim Antonov, Artin Avanes, Jon Bock, Jonathan Claybaugh, Daniel Engovatov, Martin Hentschel, Jiansheng Huang, Allison W. Lee, Ashish Motivala, Abdul Q. Munir, Steven Pelley, Peter Povinec, Greg Rahn, Spyridon Triantafyllis, 和 Philipp Unterbrunner. 2016. Snowfake弹性数据仓库. 在2016年国际管理数据会议论文集 (旧金山, 加利福尼亚, 美国) (SIGMOD '16). Association for Computing Machinery, New York, NY, USA, 215–226. [https:](https://doi.org/10.1145/2882903.2903741) [//doi.org/10.1145/2882903.2903741](https://doi.org/10.1145/2882903.2903741)
- <Anchor id="page-12-9"/>[23] Patrick Damme, Annett Ungethüm, Juliana Hildebrandt, Dirk Habich, 和 Wolfgang Lehner. 2019. 从全面的实验调查到轻量级整数压缩算法的基于成本的选择策略. ACM Trans. 数据库系统. 44, 3, 文章9 (2019), 46页. https://doi.org/10.1145/3323991
- <Anchor id="page-12-1"/>[24] Philippe Dobbelaere 和 Kyumars Sheykh Esmaili. 2017. Kafka与RabbitMQ：两个行业参考发布/订阅实现的比较研究：行业论文 (DEBS '17). Association for Computing Machinery, New York, NY, USA, 227–238. https://doi.org/10.1145/3093742.3093908
- <Anchor id="page-12-19"/>[25] LLVM文档. 2024. LLVM中的自动向量化. 取自2024-06-20 https://llvm.org/docs/Vectorizers.html
- <Anchor id="page-12-7"/>[26] Siying Dong, Andrew Kryczka, Yanqin Jin, 和 Michael Stumm. 2021. RocksDB：为大规模应用服务的键值存储的发展优先级的演变. ACM Transactions on Storage 17, 4, 文章26 (2021), 32页. https://doi.org/10.1145/3483840
- <Anchor id="page-12-34"/>[27] Markus Dreseler, Martin Boissier, Tilmann Rabl, 和 Matthias Ufacker. 2020. 量化TPC-H瓶颈及其优化. Proc. VLDB Endow. 13, 8 (2020), 1206–1220. https://doi.org/10.14778/3389133.3389138
- <Anchor id="page-12-12"/>[28] Ted Dunning. 2021. t-digest：高效的分布估计. 软件影响 7 (2021). https://doi.org/10.1016/j.simpa.2020.100049
- <Anchor id="page-12-16"/>[29] Martin Faust, Martin Boissier, Marvin Keller, David Schwalb, Holger Bischof, Katrin Eisenreich, Franz Färber, 和 Hasso Plattner. 2016. 在SAP HANA中使用哈希索引进行的足迹减少和唯一性强制. 在数据库和专家系统应用. 137–151. [https://doi.org/10.1007/978-3-319-44406-](https://doi.org/10.1007/978-3-319-44406-2_11) [2_11](https://doi.org/10.1007/978-3-319-44406-2_11)
- <Anchor id="page-12-11"/>[30] Philippe Flajolet, Eric Fusy, Olivier Gandouet, 和 Frederic Meunier. 2007. HyperLogLog：近乎最佳基数估计算法的分析. 在AofA：算法分析，DMTCS会议卷，2007年算法分析会议 (AofA 07). 离散数学与理论计算机科学, 137–156. https://doi.org/10.46298/dmtcs.3545
- <Anchor id="page-12-13"/>[31] Hector Garcia-Molina, Jefrey D. Ullman, 和 Jennifer Widom. 2009. 数据库系统 - 完整书籍 (第二版).
- <Anchor id="page-12-24"/>[32] Pawan Goyal, Harrick M. Vin, 和 Haichen Chen. 1996. 启动时间公平排队：一个集成服务分组交换网络的调度算法. 26, 4 (1996), 157–168. https://doi.org/10.1145/248157.248171
- <Anchor id="page-12-21"/>[33] Goetz Graefe. 1993. 大型数据库的查询评估技术. ACM Comput. Surv. 25, 2 (1993), 73–169. https://doi.org/10.1145/152610.152611
- <Anchor id="page-12-40"/>[34] Jean-François Im, Kishore Gopalakrishna, Subbu Subramaniam, Mayank Shrivastava, Adwait Tumbde, Xiaotian Jiang, Jennifer Dai, Seunghyun Lee, Neha Pawar, Jialiang Li, 和 Ravi Aringunram. 2018. Pinot：530百万用户的实时OLAP. 在2018年国际管理数据会议论文集 (休斯顿, TX, 美国) (SIGMOD '18). Association for Computing Machinery, New York, NY, USA, 583–594. https://doi.org/10.1145/3183713.3190661
- <Anchor id="page-12-25"/>[35] ISO/IEC 9075-9:2001 2001. 信息技术 — 数据库语言 — SQL — 第9部分：管理外部数据 (SQL/MED). 标准. 国际标准化组织.
- <Anchor id="page-12-2"/>[36] Paras Jain, Peter Kraft, Conor Power, Tathagata Das, Ion Stoica, 和 Matei Zaharia. 2023. 分析与比较湖仓存储系统. CIDR.
- <Anchor id="page-12-4"/>[37] Project Jupyter. 2024. Jupyter Notebooks. 取自2024-06-20 [https:](https://jupyter.org/) [//jupyter.org/](https://jupyter.org/)
- <Anchor id="page-12-22"/>[38] Timo Kersten, Viktor Leis, Alfons Kemper, Thomas Neumann, Andrew Pavlo, 和 Peter Boncz. 2018. 你总是想知道的关于编译和向量化查询的所有内容，但又害怕提问. Proc. VLDB Endow. 11, 13 (sep 2018), 2209–2222. https://doi.org/10.14778/3275366.3284966
- <Anchor id="page-12-15"/>[39] Changkyu Kim, Jatin Chhugani, Nadathur Satish, Eric Sedlar, Anthony D. Nguyen, Tim Kaldewey, Victor W. Lee, Scott A. Brandt, 和 Pradeep Dubey. 2010. FAST：面向现代CPU和GPU的快速架构敏感树搜索. 在2010年ACM SIGMOD国际管理数据会议论文集 (印第安纳波利斯, 印第安纳, 美国) (SIGMOD '10). Association for Computing Machinery, New York, NY, USA, 339–350. https://doi.org/10.1145/1807167.1807206
- <Anchor id="page-12-5"/>[40] Donald E. Knuth. 1973. 计算机程序设计的艺术，第三卷：排序与搜索. Addison-Wesley.
- <Anchor id="page-12-42"/>[41] André Kohn, Viktor Leis, 和 Thomas Neumann. 2018. 编译查询的自适应执行. 在2018年IEEE第34届国际数据工程会议 (ICDE). 197–208. https://doi.org/10.1109/ICDE.2018.00027
- <Anchor id="page-12-36"/>[42] Andrew Lamb, Matt Fuller, Ramakrishna Varadarajan, Nga Tran, Ben Vandiver, Lyric Doshi, 和 Chuck Bear. 2012. Vertica分析数据库：7年后的C-Store. Proc. VLDB Endow. 5, 12 (aug 2012), 1790–1801. [https://doi.org/10.](https://doi.org/10.14778/2367502.2367518) [14778/2367502.2367518](https://doi.org/10.14778/2367502.2367518)
- <Anchor id="page-12-43"/>[43] Harald Lang, Tobias Mühlbauer, Florian Funke, Peter A. Boncz, Thomas Neumann, 和 Alfons Kemper. 2016. 数据块：使用向量化和编译的压缩存储上的混合OLTP和OLAP. 在2016年国际管理数据会议论文集 (旧金山, 加利福尼亚, 美国) (SIGMOD '16). Association for Computing Machinery, New York, NY, USA, 311–326. https://doi.org/10.1145/2882903.2882925
- <Anchor id="page-12-20"/>[44] Viktor Leis, Peter Boncz, Alfons Kemper, 和 Thomas Neumann. 2014. 基于部分驱动的并行处理：一个NUMA感知的查询评估框架，适应多核心时代. 在2014年ACM SIGMOD国际管理数据会议论文集 (雪鸟, 犹他州, 美国) (SIGMOD '14). Association for Computing Machinery, New York, NY, USA, 743–754. [https://doi.org/10.1145/2588555.](https://doi.org/10.1145/2588555.2610507) [2610507](https://doi.org/10.1145/2588555.2610507)
- <Anchor id="page-13-17"/>[45] Viktor Leis, Alfons Kemper, 和 Thomas Neumann. 2013. 自适应基数树：主内存数据库的ARTful索引. 在2013年IEEE第29届国际数据工程会议 (ICDE). 38–49. [https://doi.org/10.1109/ICDE.](https://doi.org/10.1109/ICDE.2013.6544812) [2013.6544812](https://doi.org/10.1109/ICDE.2013.6544812)
- <Anchor id="page-13-34"/>[46] Chunwei Liu, Anna Pavlenko, Matteo Interlandi, 和 Brandon Haynes. 2023. 深入探讨分析DBMS的常见开放格式. 16, 11 (jul 2023), 3044–3056. https://doi.org/10.14778/3611479.3611507
- <Anchor id="page-13-30"/>[47] Zhenghua Lyu, Huan Hubert Zhang, Gang Xiong, Gang Guo, Haozhou Wang, Jinbao Chen, Asim Praveen, Yu Yang, Xiaoming Gao, Alexandra Wang, Wen Lin, Ashwin Agrawal, Junfeng Yang, Hao Wu, Xiaoliang Li, Feng Guo, Jiang Wu, Jesse Zhang, 和 Venkatesh Raghavan. 2021. Greenplum：一个用于事务和分析工作负载的混合数据库 (SIGMOD '21). Association for Computing Machinery, New York, NY, USA, 2530–2542. [https:](https://doi.org/10.1145/3448016.3457562) [//doi.org/10.1145/3448016.3457562](https://doi.org/10.1145/3448016.3457562)
- <Anchor id="page-13-28"/>[48] Roger MacNicol 和 Blaine French. 2004. Sybase IQ Multiplex - 为分析而设计. 在第三十届国际超大规模数据库会议论文集 - 第30卷 (多伦多, 加拿大) (VLDB '04). VLDB Endowment, 1227–1230.
- <Anchor id="page-13-31"/>[49] Sergey Melnik, Andrey Gubarev, Jing Jing Long, Geofrey Romer, Shiva Shivakumar, Matt Tolton, Theo Vassilakis, Hossein Ahmadi, Dan Delorey, Slava Min, Mosha Pasumansky, 和 Jef Shute. 2020. Dremel：十年大规模Web交互SQL分析. Proc. VLDB Endow. 13, 12 (aug 2020), 3461–3472. https://doi.org/10.14778/3415478.3415568
- <Anchor id="page-13-2"/>[50] Microsoft. 2024. Kusto查询语言. 取自2024-06-20 [https:](https://github.com/microsoft/Kusto-Query-Language) [//github.com/microsoft/Kusto-Query-Language](https://github.com/microsoft/Kusto-Query-Language)
- <Anchor id="page-13-14"/>[51] Guido Moerkotte. 1998. 小型物化聚合：用于数据仓库的轻量级索引结构. 在第24届国际超大规模数据库会议论文集 (VLDB '98). 476–487.
- <Anchor id="page-13-22"/>[52] Jalal Mostafa, Sara Wehbi, Suren Chilingaryan, 和 Andreas Kopmann. 2022. SciTS：科学实验和工业物联网中的时间序列数据库基准. 在第34届科学与统计数据库管理国际会议论文集 (SSDBM '22). 文章12. [https:](https://doi.org/10.1145/3538712.3538723) [//doi.org/10.1145/3538712.3538723](https://doi.org/10.1145/3538712.3538723)
- <Anchor id="page-13-0"/>[53] Thomas Neumann. 2011. 为现代硬件高效编译高效的查询计划. Proc. VLDB Endow. 4, 9 (jun 2011), 539–550. [https://doi.org/10.14778/](https://doi.org/10.14778/2002938.2002940) [2002938.2002940](https://doi.org/10.14778/2002938.2002940)
- <Anchor id="page-13-25"/>[54] Thomas Neumann 和 Michael J. Freitag. 2020. Umbra：具有内存性能的基于磁盘的系统. 在第10届创新数据系统研究会议，CIDR 2020, 阿姆斯特丹，荷兰，2020年1月12日至15日，在线会议论文. www.cidrdb.org. [http://cidrdb.org/cidr2020/papers/p29-neumann](http://cidrdb.org/cidr2020/papers/p29-neumann-cidr20.pdf)[cidr20.pdf](http://cidrdb.org/cidr2020/papers/p29-neumann-cidr20.pdf)
- <Anchor id="page-13-35"/>[55] Thomas Neumann, Tobias Mühlbauer, 和 Alfons Kemper. 2015. 面向主内存数据库系统的快速可串行化多版本并发控制. 在2015年ACM SIGMOD国际管理数据会议论文集 (墨尔本, 维多利亚州, 澳大利亚) (SIGMOD '15). Association for Computing Machinery, New York, NY, USA, 677–689. [https://doi.org/10.1145/2723372.](https://doi.org/10.1145/2723372.2749436) [2749436](https://doi.org/10.1145/2723372.2749436)
- <Anchor id="page-13-8"/>[56] LevelDB在GitHub上. 2024. LevelDB. 取自2024-06-20 [https://github.](https://github.com/google/leveldb) [com/google/leveldb](https://github.com/google/leveldb)
- <Anchor id="page-13-26"/>[57] Patrick O'Neil, Elizabeth O'Neil, Xuedong Chen, 和 Stephen Revilak. 2009. 星型模式基准和增强事实表索引. 在性能评估和基准测试中. Springer Berlin Heidelberg, 237–252. [https:](https://doi.org/10.1007/978-3-642-10424-4_17) [//doi.org/10.1007/978-3-642-10424-4_17](https://doi.org/10.1007/978-3-642-10424-4_17)
- <Anchor id="page-13-7"/>[58] Patrick E. O'Neil, Edward Y. C. Cheng, Dieter Gawlick, 和 Elizabeth J. O'Neil. 1996. 日志结构合并树 (LSM-tree). Acta Informatica 33 (1996), 351–385. https://doi.org/10.1007/s002360050048
- <Anchor id="page-13-4"/>[59] Diego Ongaro 和 John Ousterhout. 2014. 寻找一个可理解的共识算法. 在2014年USENIX会议上的USENIX年度技术会议 (USENIX ATC'14). 305–320. [https://doi.org/doi/10.](https://doi.org/doi/10.5555/2643634.2643666) [5555/2643634.2643666](https://doi.org/doi/10.5555/2643634.2643666)
- <Anchor id="page-13-3"/>[60] Patrick O'Neil, Edward Cheng, Dieter Gawlick, 和 Elizabeth O'Neil. 1996. 日志结构合并树 (LSM-Tree). Acta Inf. 33, 4 (1996), 351–385. [https:](https://doi.org/10.1007/s002360050048) [//doi.org/10.1007/s002360050048](https://doi.org/10.1007/s002360050048)
- <Anchor id="page-13-5"/>[61] Pandas. 2024. Pandas数据框. 取自2024-06-20 [https://pandas.](https://pandas.pydata.org/) [pydata.org/](https://pandas.pydata.org/)
- <Anchor id="page-13-32"/>[62] Pedro Pedreira, Orri Erling, Masha Basmanova, Kevin Wilfong, Laith Sakka, Krishna Pai, Wei He, 和 Biswapesh Chattopadhyay. 2022. Velox：Meta的统一执行引擎. Proc. VLDB Endow. 15, 12 (aug 2022), 3372–3384. [https:](https://doi.org/10.14778/3554821.3554829) [//doi.org/10.14778/3554821.3554829](https://doi.org/10.14778/3554821.3554829)
- <Anchor id="page-13-10"/>[63] Tuomas Pelkonen, Scott Franklin, Justin Teller, Paul Cavallaro, Qi Huang, Justin Meza, 和 Kaushik Veeraraghavan. 2015. Gorilla：一个快速、可扩展的内存时间序列数据库. 维尔巴数据集成增刊第8期, 第12卷 (2015), 1816–1827. https://doi.org/10.14778/2824032.2824078
- <Anchor id="page-13-18"/>[64] Orestis Polychroniou, Arun Raghavan, 和 Kenneth A. Ross. 2015. 重新思考内存数据库的SIMD向量化. 在2015年ACM SIGMOD国际管理数据会议论文集 (SIGMOD '15). 1493–1508. https://doi.org/10.1145/2723372.2747645
- <Anchor id="page-13-21"/>[65] PostgreSQL. 2024. PostgreSQL - 外部数据包装器. 取自2024-06-20 https://wiki.postgresql.org/wiki/Foreign_data_wrappers
- <Anchor id="page-13-23"/>[66] Mark Raasveldt, Pedro Holanda, Tim Gubner, 和 Hannes Mühleisen. 2018. 公平基准测试被认为困难：数据库性能测试中的常见陷阱. 在数据库系统测试研讨会论文集 (休斯顿, TX, 美国) (DBTest'18). 文章2, 6页. https://doi.org/10.1145/3209950.3209955
- <Anchor id="page-13-6"/>[67] Mark Raasveldt 和 Hannes Mühleisen. 2019. DuckDB：一个可嵌入的分析数据库 (SIGMOD '19). Association for Computing Machinery, New York, NY, USA, 1981–1984. https://doi.org/10.1145/3299869.3320212
- <Anchor id="page-13-16"/>[68] Jun Rao 和 Kenneth A. Ross. 1999. 为决策支持的主内存缓存感知索引. 在第25届国际超大规模数据库会议论文集 (VLDB '99). 旧金山, CA, 美国, 78–89.
- <Anchor id="page-13-36"/>[69] Navin C. Sabharwal 和 Piyush Kant Pandey. 2020. 使用 Prometheus 查询语言 (PromQL). 在监控微服务和容器化应用程序中. https://doi.org/10.1007/978-1-4842-6216-0_5
- <Anchor id="page-13-27"/>[70] Todd W. Schneider. 2022. 纽约市出租车和招募车辆数据. 取自2024-06-20 https://github.com/toddwschneider/nyc-taxi-data
- <Anchor id="page-13-13"/>[71] Mike Stonebraker, Daniel J. Abadi, Adam Batkin, Xuedong Chen, Mitch Cherniack, Miguel Ferreira, Edmond Lau, Amerson Lin, Sam Madden, Elizabeth O'Neil, Pat O'Neil, Alex Rasin, Nga Tran, 和 Stan Zdonik. 2005. C-Store：一个面向列的数据库管理系统. 在第31届国际超大规模数据库会议论文集 (VLDB '05). 553–564.
- <Anchor id="page-13-29"/>[72] Teradata. 2024. Teradata数据库. 取自2024-06-20 [https://www.](https://www.teradata.com/resources/datasheets/teradata-database) [teradata.com/resources/datasheets/teradata-database](https://www.teradata.com/resources/datasheets/teradata-database)
- <Anchor id="page-13-15"/>[73] Frederik Transier. 2010. 内存文本搜索引擎的算法和数据结构. 博士学位论文. https://doi.org/10.5445/IR/1000015824
- <Anchor id="page-13-24"/>[74] Adrian Vogelsgesang, Michael Haubenschild, Jan Finis, Alfons Kemper, Viktor Leis, Tobias Muehlbauer, Thomas Neumann, 和 Manuel Then. 2018. 真实情况：基准测试如何未能代表现实世界. 在数据库系统测试研讨会论文集 (休斯顿, TX, 美国) (DBTest'18). 文章1, 6页. https://doi.org/10.1145/3209950.3209952
- <Anchor id="page-13-9"/>[75] LZ4网站. 2024. LZ4. 取自2024-06-20 https://lz4.org/
- <Anchor id="page-13-11"/><Anchor id="page-13-1"/>[76] PRQL网站. 2024. PRQL. 取自2024-06-20 https://prql-lang.org [77] Till Westmann, Donald Kossmann, Sven Helmer, 和 Guido Moerkotte. 2000. 压缩数据库的实现和性能. SIGMOD Rec.
- <Anchor id="page-13-33"/>29, 3 (sep 2000), 55–67. https://doi.org/10.1145/362084.362137 [78] Fangjin Yang, Eric Tschetter, Xavier Léauté, Nelson Ray, Gian Merlino, 和 Deep Ganguli. 2014. Druid：一个实时分析数据存储. 在2014年ACM SIGMOD国际管理数据会议论文集 (雪鸟, 犹他州, 美国) (SIGMOD '14). Association for Computing Machinery, New York, NY, USA, 157–168. https://doi.org/10.1145/2588555.2595631
- <Anchor id="page-13-20"/>[79] Tianqi Zheng, Zhibin Zhang, 和 Xueqi Cheng. 2020. SAHA：一个用于分析数据库的字符串自适应哈希表. 应用科学 10, 6 (2020). [https:](https://doi.org/10.3390/app10061915) [//doi.org/10.3390/app10061915](https://doi.org/10.3390/app10061915)
- <Anchor id="page-13-19"/>[80] Jingren Zhou 和 Kenneth A. Ross. 2002. 使用SIMD指令实现数据库操作. 在2002年ACM SIGMOD国际管理数据会议论文集 (SIGMOD '02). 145–156. [https://doi.org/10.](https://doi.org/10.1145/564691.564709) [1145/564691.564709](https://doi.org/10.1145/564691.564709)
- <Anchor id="page-13-12"/>[81] Marcin Zukowski, Sandor Heman, Niels Nes, 和 Peter Boncz. 2006. 超标量RAM-CPU缓存压缩. 在第22届国际数据工程大会论文集 (ICDE '06). 59. [https://doi.org/10.1109/ICDE.](https://doi.org/10.1109/ICDE.2006.150) [2006.150](https://doi.org/10.1109/ICDE.2006.150)
