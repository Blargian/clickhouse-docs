import React from 'react';
// Import the ORIGINAL library component
import { VerticalStepper as OriginalVerticalStepper } from '@clickhouse/click-ui/bundled';

// Define props expected by the wrapper Step (from plugin)
interface StepWrapperProps {
    children?: React.ReactNode;
    // Props generated by the plugin:
    id?: string;
    label?: React.ReactNode;
    status?: 'active' | 'complete' | 'incomplete';
    collapsed?: boolean | null; // Plugin passes null for true, undefined for false
    // Props injected by parent wrapper:
    index?: number;
    isLast?: boolean;
    stepperType?: 'numbered' | 'bulleted';
    // Allow pass-through of other props if needed
    [key: string]: any;
}

// Wrapper for the Step sub-component
const StepWrapper = ({
                         children,
                         collapsed, // Receives null for true, undefined for false from plugin AST
                         ...restProps // id, label, status, index, isLast, stepperType etc.
                     }: StepWrapperProps) => {

    // Convert the incoming prop to the boolean expected by OriginalVerticalStepper.Step
    // If prop is null (meaning true), pass true. Otherwise (prop is undefined), pass false.
    const booleanCollapsed = (collapsed === null);

    console.log(`[Step Wrapper] Label: "${restProps.label}", Received collapsed: ${collapsed}, Passing boolean: ${booleanCollapsed}`);

    // Render the ORIGINAL library Step component
    return (
        <OriginalVerticalStepper.Step collapsed={booleanCollapsed} {...restProps}>
            {children}
        </OriginalVerticalStepper.Step>
    );
};


// Wrapper for the main VerticalStepper component
interface StepperWrapperProps {
    children?: React.ReactNode;
    type?: 'numbered' | 'bulleted';
    className?: string;
    // Allow pass-through of other props if needed
    [key: string]: any;
}

const VerticalStepperWrapper = ({
                                    children,
                                    type = 'numbered', // Get type from MDX tag attribute
                                    ...props // Pass other props like className through
                                }: StepperWrapperProps) => {

    // Filter and clone children to inject index/isLast/type IF the original component needs them
    // Check the OriginalVerticalStepper documentation/usage. Often, context is used.
    // For simplicity, let's assume we might need to inject index/type if context isn't used by original.
    const processedChildren = React.Children.toArray(children)
        .filter(child => React.isValidElement(child) /* && child.type === StepWrapper - this check happens via MDX mapping */)
        .map((step, index, arr) => {
            return React.cloneElement(step as React.ReactElement, {
                // Inject props needed by StepWrapper OR potentially OriginalVerticalStepper.Step itself
                // It's cleaner if StepWrapper handles everything needed by Original.
                // Check if OriginalVerticalStepper.Step uses index/isLast/stepperType props directly.
                // Let's assume StepWrapper receives them and passes needed ones via ...restProps.
                key: (step as React.ReactElement).props.id || index, // Add key prop
            // index: index + 1, // If OriginalStep needs it
            // isLast: index === arr.length - 1, // If OriginalStep needs it
            // stepperType: type, // If OriginalStep needs it
        });
        });


    // Render the ORIGINAL library VerticalStepper component
    return (
        <OriginalVerticalStepper type={type} {...props}>
            {processedChildren}
        </OriginalVerticalStepper>
    );
};

// Attach the Step Wrapper for mapping purposes
VerticalStepperWrapper.Step = StepWrapper;

export default VerticalStepperWrapper;