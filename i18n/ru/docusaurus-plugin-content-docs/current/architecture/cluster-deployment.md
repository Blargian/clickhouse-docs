---
slug: /architecture/cluster-deployment
sidebar_label: 'Развертывание кластера'
sidebar_position: 100
title: 'Развертывание кластера'
description: 'Пройдя этот учебник, вы научитесь настраивать простой кластер ClickHouse.'
---

Этот учебник предполагает, что вы уже настроили [локальный сервер ClickHouse](../getting-started/install.md).

Пройдя этот учебник, вы научитесь настраивать простой кластер ClickHouse. Он будет компактным, но отказоустойчивым и масштабируемым. Затем мы используем один из примеров наборов данных, чтобы заполнить его данными и выполнить несколько демонстрационных запросов.

## Развертывание кластера {#cluster-deployment}

Этот кластер ClickHouse будет однородным. Вот шаги:

1.  Установите сервер ClickHouse на всех машинах кластера.
2.  Настройте конфигурационные файлы кластера.
3.  Создайте локальные таблицы на каждом экземпляре.
4.  Создайте [распределённую таблицу](../engines/table-engines/special/distributed.md).

[Распределённая таблица](../engines/table-engines/special/distributed.md) представляет собой своего рода "представление" локальных таблиц в кластере ClickHouse. Запрос SELECT из распределённой таблицы выполняется с использованием ресурсов всех шардов кластера. Вы можете указать конфигурации для нескольких кластеров и создать несколько распределённых таблиц, чтобы предоставить представления для различных кластеров.

Вот пример конфигурации для кластера с тремя шардов, с одной репликой каждый:

```xml
<remote_servers>
    <perftest_3shards_1replicas>
        <shard>
            <replica>
                <host>example-perftest01j.clickhouse.com</host>
                <port>9000</port>
            </replica>
        </shard>
        <shard>
            <replica>
                <host>example-perftest02j.clickhouse.com</host>
                <port>9000</port>
            </replica>
        </shard>
        <shard>
            <replica>
                <host>example-perftest03j.clickhouse.com</host>
                <port>9000</port>
            </replica>
        </shard>
    </perftest_3shards_1replicas>
</remote_servers>
```

Для дальнейшей демонстрации давайте создадим новую локальную таблицу с тем же запросом `CREATE TABLE`, который мы использовали для `hits_v1` в учебнике по развертыванию на одном узле, но с другим именем таблицы:

```sql
CREATE TABLE tutorial.hits_local (...) ENGINE = MergeTree() ...
```

Создание распределённой таблицы предоставляет представление над локальными таблицами кластера:

```sql
CREATE TABLE tutorial.hits_all AS tutorial.hits_local
ENGINE = Distributed(perftest_3shards_1replicas, tutorial, hits_local, rand());
```

Обычной практикой является создание аналогичных распределённых таблиц на всех машинах кластера. Это позволяет выполнять распределённые запросы на любой машине кластера. Есть также альтернатива создать временную распределённую таблицу для данного запроса SELECT, используя [функцию таблицы remote](../sql-reference/table-functions/remote.md).

Давайте выполните [INSERT SELECT](../sql-reference/statements/insert-into.md) в распределённую таблицу, чтобы распределить таблицу на несколько серверов.

```sql
INSERT INTO tutorial.hits_all SELECT * FROM tutorial.hits_v1;
```

Как и следовало ожидать, вычислительно тяжелые запросы работают в N раз быстрее, если они используют 3 сервера вместо одного.

В этом случае мы используем кластер с 3 шардов, и каждый шард содержит одну реплику.

Чтобы обеспечить отказоустойчивость в производственной среде, мы рекомендуем, чтобы каждый шард содержал 2-3 реплики, распределённые между несколькими зонами доступности или дата-центрами (или, по крайней мере, стойками). Обратите внимание, что ClickHouse поддерживает неограниченное количество реплик.

Вот пример конфигурации для кластера с одним шардом, содержащим три реплики:

```xml
<remote_servers>
    ...
    <perftest_1shards_3replicas>
        <shard>
            <replica>
                <host>example-perftest01j.clickhouse.com</host>
                <port>9000</port>
             </replica>
             <replica>
                <host>example-perftest02j.clickhouse.com</host>
                <port>9000</port>
             </replica>
             <replica>
                <host>example-perftest03j.clickhouse.com</host>
                <port>9000</port>
             </replica>
        </shard>
    </perftest_1shards_3replicas>
</remote_servers>
```

Чтобы включить нативную репликацию, требуется [ZooKeeper](http://zookeeper.apache.org). ClickHouse обеспечивает согласованность данных на всех репликах и автоматически запускает процедуру восстановления после сбоя. Рекомендуется развертывать кластер ZooKeeper на отдельных серверах (где не работают другие процессы, включая ClickHouse).

:::note Примечание
ZooKeeper не является строгим требованием: в некоторых простых случаях вы можете дублировать данные, записывая их во все реплики из вашего кода приложения. Этот подход **не** рекомендуется, так как в этом случае ClickHouse не сможет гарантировать согласованность данных на всех репликах. Таким образом, это становится ответственностью вашего приложения.
:::

Расположение ZooKeeper указывается в конфигурационном файле:

```xml
<zookeeper>
    <node>
        <host>zoo01.clickhouse.com</host>
        <port>2181</port>
    </node>
    <node>
        <host>zoo02.clickhouse.com</host>
        <port>2181</port>
    </node>
    <node>
        <host>zoo03.clickhouse.com</host>
        <port>2181</port>
    </node>
</zookeeper>
```

Также необходимо установить макросы для идентификации каждого шарда и реплики, которые используются при создании таблицы:

```xml
<macros>
    <shard>01</shard>
    <replica>01</replica>
</macros>
```

Если в момент создания реплицируемой таблицы нет реплик, создаётся новая первая реплика. Если уже есть живые реплики, новая реплика клонирует данные от существующих. У вас есть возможность сначала создать все реплицируемые таблицы, а затем вставить в них данные. Другой вариант - создать некоторые реплики и добавить другие после или во время вставки данных.

```sql
CREATE TABLE tutorial.hits_replica (...)
ENGINE = ReplicatedMergeTree(
    '/clickhouse_perftest/tables/{shard}/hits',
    '{replica}'
)
...
```

Здесь мы используем таблицу с движком [ReplicatedMergeTree](../engines/table-engines/mergetree-family/replication.md). В параметрах мы указываем путь ZooKeeper, содержащий идентификаторы шардов и реплик.

```sql
INSERT INTO tutorial.hits_replica SELECT * FROM tutorial.hits_local;
```

Репликация работает в режиме мульти-мастера. Данные могут загружаться в любую реплику, а система затем автоматически синхронизирует их с другими экземплярами. Репликация асинхронна, поэтому в данный момент не все реплики могут содержать недавно вставленные данные. По крайней мере, одна реплика должна быть активна, чтобы разрешить прием данных. Другие будут синхронизировать данные и исправлять согласованность, как только они снова станут активными. Обратите внимание, что этот подход позволяет снизить вероятность потери недавно вставленных данных.
