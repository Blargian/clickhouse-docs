---
'slug': '/optimize/skipping-indexes'
'sidebar_label': '数据跳过索引'
'sidebar_position': 2
'description': '跳过索引使 ClickHouse 能够跳过读取一些数据块，这些数据块肯定不包含任何匹配值。'
'title': '理解 ClickHouse 数据跳过索引'
---

import simple_skip from '@site/static/images/guides/best-practices/simple_skip.png';
import bad_skip from '@site/static/images/guides/best-practices/bad_skip.png';
import Image from '@theme/IdealImage';


# 理解 ClickHouse 数据跳过索引

## 介绍 {#introduction}

许多因素会影响 ClickHouse 查询性能。在大多数场景中，关键因素是 ClickHouse 在评估查询的 WHERE 子句条件时是否能够使用主键。因此，选择一个适用于最常见查询模式的主键对有效的表设计至关重要。

然而，无论主键调整得多么仔细，必然会有一些查询用例无法有效利用它。用户通常依赖 ClickHouse 来处理时间序列类型的数据，但他们常常希望根据其他业务维度分析这些数据，例如客户 ID、网站 URL 或产品编号。在这种情况下，查询性能可能显著下降，因为可能需要对每一列的值进行全面扫描，以应用 WHERE 子句条件。虽然在这些情况下 ClickHouse 仍然相对快速，但评估数百万或数十亿个单独的值将导致“未索引”的查询执行速度远慢于基于主键的查询。

在传统的关系数据库中，解决此问题的一种方法是向表附加一个或多个“次级”索引。这是一种 B-tree 结构，使数据库能够在 O(log(n)) 时间内找到所有匹配的行，而不是 O(n) 时间（即表扫描），其中 n 是行的数量。然而，这种类型的次级索引不适用于 ClickHouse（或其他列式数据库），因为磁盘上没有单独的行可供添加到索引中。

相反，ClickHouse 提供了另一种类型的索引，在特定情况下可以显著提高查询速度。这些结构被称为“跳过”索引，因为它们使 ClickHouse 能够跳过读取保证没有匹配值的大块数据。

## 基本操作 {#basic-operation}

用户只能在 MergeTree 系列表上使用数据跳过索引。每个数据跳过索引有四个主要参数：

- 索引名称。索引名称用于在每个分区中创建索引文件。此外，在删除或物化索引时也需要该名称作为参数。
- 索引表达式。索引表达式用于计算存储在索引中的值集。它可以是列的组合、简单操作符和/或由索引类型确定的函数子集。
- TYPE。索引的类型控制确定是否可以跳过读取和评估每个索引块的计算。
- GRANULARITY。每个索引块由若干 GRANULARITY 个粒子组成。例如，如果主表索引的粒度为 8192 行，而索引粒度为 4，则每个索引“块”将为 32768 行。

当用户创建数据跳过索引时，表的每个数据部分目录中将有两个额外的文件。

- `skp_idx_{index_name}.idx`，其中包含有序的表达式值
- `skp_idx_{index_name}.mrk2`，其中包含对应的偏移量，指向关联的数据列文件。

如果在执行查询并读取相关列文件时，WHERE 子句过滤条件的某些部分与跳过索引表达式匹配，ClickHouse 将使用索引文件中的数据来确定每个相关数据块是否必须处理或可以跳过（假设该块尚未通过应用主键而被排除）。为了给出一个非常简单的示例，考虑以下已加载可预测数据的表。

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

在执行不使用主键的简单查询时，`my_value` 列中的所有 1 亿条目都被扫描：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.079 sec. Processed 100.00 million rows, 800.10 MB (1.26 billion rows/s., 10.10 GB/s.
```

现在添加一个非常基本的跳过索引：

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

通常情况下，跳过索引仅应用于新插入的数据，因此仅添加索引不会影响上述查询。

要索引已经存在的数据，请使用以下语句：

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

使用新创建的索引重新运行查询：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192 rows in set. Elapsed: 0.051 sec. Processed 32.77 thousand rows, 360.45 KB (643.75 thousand rows/s., 7.08 MB/s.)
```

ClickHouse 读取和分析的不是 80 兆字节的 1 亿行，而是 32768 行的 360 千字节
-- 四个粒度为 8192 行。

以更直观的方式来看，这就是如何读取并选择 `my_value` 为 125 的 4096 行，以及如何跳过以下行而不从磁盘读取：

<Image img={simple_skip} size="md" alt="简单跳过"/>

用户可以通过在执行查询时启用跟踪来访问关于跳过索引使用的详细信息。通过 clickhouse-client，设置 `send_logs_level`：

```sql
SET send_logs_level='trace';
```
这将提供有用的调试信息，帮助调整查询 SQL 和表索引。从上述示例中，调试日志显示跳过索引丢弃了除两个粒度之外的所有粒度：

```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Index `vix` has dropped 6102/6104 granules.
```

## 跳过索引类型 {#skip-index-types}

### minmax {#minmax}

这种轻量级索引类型不需要任何参数。它为每个块存储索引表达式的最小值和最大值（如果表达式是元组，则分别存储元组每个元素的值）。这种类型理想用于按值松散排序的列。该索引类型在查询处理过程中通常是成本最低的。

这种类型的索引只能与标量或元组表达式正确工作 -- 该索引永远不会应用于返回数组或映射数据类型的表达式。

### set {#set}

这种轻量级索引类型接受一个参数，即每个块的值集的 max_size（0 允许无限数量的离散值）。该集合包含块中的所有值（如果值的数量超过 max_size，则为空）。针对每组粒度，该索引类型在低基数的列中表现良好（本质上是“聚集在一起”），但总体上具有较高的基数。

该索引的成本、性能和有效性取决于块内的基数。如果每个块包含大量唯一值，那么根据大型索引集评估查询条件将非常昂贵，或者索引不会被应用，因为由于超过 max_size 导致索引为空。

### Bloom 过滤器类型 {#bloom-filter-types}

*Bloom 过滤器*是一种数据结构，允许以节省空间的方式测试集合成员资格，但存在小概率的假阳性。在跳过索引的情况下，假阳性并不是一个重要的问题，因为唯一的缺点是读取一些不必要的块。然而，假阳性的潜在出现确实意味着索引表达式应预计为真，否则有效数据可能被跳过。

由于 Bloom 过滤器可以更有效地处理对大量离散值的测试，因此它们可以适用于生成更多值进行测试的条件表达式。特别是，Bloom 过滤器索引可以应用于数组，其中数组中的每个值都被测试，并且可以通过使用 mapKeys 或 mapValues 函数将键或值转换为数组来应用于映射。

基于 Bloom 过滤器有三种数据跳过索引类型：

* 基本的 **bloom_filter**，它接受一个可选参数，指定允许的“假阳性”率，范围为 0 到 1（如果未指定，则使用 0.025）。

* 专门的 **tokenbf_v1**。它接受三个参数，均与调整所使用的 Bloom 过滤器有关：(1) 过滤器的大小（以字节为单位，较大的过滤器具有较少的假阳性，但会增加存储成本），(2) 应用的哈希函数数量（同样，更多哈希过滤器减少假阳性），以及 (3) Bloom 过滤器哈希函数的种子。有关这些参数如何影响 Bloom 过滤器功能的更多细节，请参见 [此处](https://hur.st/bloomfilter/) 的计算器。
该索引仅与字符串、固定字符串和映射数据类型配合使用。输入表达式被分割为由非字母数字字符分隔的字符序列。例如，列值为 `This is a candidate for a "full text" search` 将包含令牌 `This` `is` `a` `candidate` `for` `full` `text` `search`。它适用于 LIKE、EQUALS、IN、hasToken() 和类似搜索，以查找更长字符串中的单词和其他值。例如，一种可能的用法可能是在一列自由格式的应用程序日志行中搜索少量类名或行号。

* 专门的 **ngrambf_v1**。该索引的功能与 token 索引相同。它在 Bloom 过滤器设置之前接受一个额外参数，即要索引的 ngram 的大小。ngram 是一个长度为 `n` 的字符字符串，可以是任何字符，因此字符串 `A short string` 的 ngram 大小为 4 将被索引为：
```text
  'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
```
该索引对于文本搜索也非常有用，特别是在没有单词断开的语言中，例如中文。

## 跳过索引函数 {#skip-index-functions}

数据跳过索引的核心目的是限制热门查询分析的数据量。考虑到 ClickHouse 数据的分析性质，这些查询的模式在大多数情况下都包括功能表达式。因此，跳过索引必须与常用函数正确交互，以提高效率。这可以在以下情况下发生：
* 数据被插入，并且索引被定义为功能表达式（索引文件中存储表达式的结果），或者
* 查询被处理，并且表达式应用于存储的索引值以确定是否排除该块。

每种类型的跳过索引都根据适用于列表的 ClickHouse 函数的可用子集进行工作 [这里](/engines/table-engines/mergetree-family/mergetree/#functions-support)。一般来说，set 索引和基于 Bloom 过滤器的索引（另一种类型的 set 索引）都是无序的，因此不适用于范围。相比之下，minmax 索引在范围方面工作得特别好，因为确定范围是否相交是非常快速的。部分匹配函数 LIKE、startsWith、endsWith 和 hasToken 的有效性取决于所使用的索引类型、索引表达式以及数据的特定形状。

## 跳过索引设置 {#skip-index-settings}

有两个适用于跳过索引的可用设置。

* **use_skip_indexes** （0 或 1，默认为 1）。并非所有查询都能有效利用跳过索引。如果特定的过滤条件可能包含大多数粒度，则应用数据跳过索引会产生不必要且有时很大的成本。对于不太可能从任何跳过索引中受益的查询，将该值设置为 0。
* **force_data_skipping_indices** （以逗号分隔的索引名称列表）。该设置可用于防止某些类型的低效查询。在查询表的情况下，如果不使用跳过索引则成本过高，则使用一个或多个索引名称的此设置将返回任何不使用所列索引的查询的异常。这将阻止编写不良查询消耗服务器资源。

## 跳过最佳实践 {#skip-best-practices}

跳过索引并不直观，尤其是对于习惯于来自 RDMS 领域的基于行的次级索引或文档存储中的反向索引的用户。要获得任何收益，应用 ClickHouse 数据跳过索引必须避免足够的粒度读取，以抵消计算索引的成本。关键是，如果一个值在索引块中出现一次，则表示整个块必须被读取到内存中并进行评估，而索引成本则是在无谓地产生。

考虑以下数据分布：

<Image img={bad_skip} size="md" alt="不良跳过"/>

假设主键/排序键是 `timestamp`，并且有一个对 `visitor_id` 的索引。考虑以下查询：

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001`
```

在这种数据分布的情况下，传统的次级索引将非常有利。它会包含仅五个行位置，而不是读取所有 32768 行来查找请求的 visitor_id 的五行。对于 ClickHouse 数据跳过索引，情况恰恰相反。无论跳过索引的类型如何，`visitor_id` 列中的所有 32768 个值都将被测试。

因此，试图通过简单地向关键列添加索引来加速 ClickHouse 查询的自然冲动往往是错误的。此高级功能应仅在调查其他替代方案后使用，例如修改主键（请参见 [如何选择主键](../best-practices/sparse-primary-indexes.md)）、使用投影或使用物化视图。即使在数据跳过索引适用的情况下，对索引和表进行精心调整通常也是必要的。

在大多数情况下，有用的跳过索引需要主键与目标非主列/表达式之间的强关联。如果没有关联（如上图所示），则满足筛选条件的几率较高，且在数千个值的块中几乎不会跳过块。相反，如果主键（如一天中的时间）的值范围与潜在索引列中的值（如观众年龄）有强关联，则 minmax 类型的索引可能会有益。请注意，在插入数据时可能会增加这种关联，无论是通过在排序/ORDER BY 键中包含其他列，还是以将与主键相关的值分组的方式批量插入。例如，某个 site_id 的所有事件可以通过摄取过程分组并一起插入，即使主键是包含来自众多站点的事件的时间戳。这将导致包含仅少数 site_id 的许多粒度，从而在按特定 site_id 值搜索时可以跳过许多块。

另一个适合跳过索引的候选项是对于高基数表达式，其中任一值在数据中相对稀疏。例如，一个观察平台跟踪 API 请求中的错误代码。某些错误代码虽然在数据中比较少见，但在搜索中可能特别重要。对 error_code 列使用的 set 跳过索引将允许跳过绝大多数不包含错误的块，从而显著提升以错误为重点的查询。

最后，关键的最佳实践是测试、测试、再测试。不同于传统的 B-tree 次级索引或用于搜索文档的反向索引，数据跳过索引的行为并不易于预测。将它们添加到表中会对数据摄取和查询带来显著的成本，这些查询出于任何原因都不会从索引中受益。它们应该始终在真实世界类型的数据上进行测试，测试应包括类型、粒度大小和其他参数的变化。测试通常会揭示仅通过思维实验无法明确的模式和陷阱。
