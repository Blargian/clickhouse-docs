---
description: 'Документация для комбинаторов агрегатных функций'
sidebar_label: 'Комбинаторы'
sidebar_position: 37
slug: /sql-reference/aggregate-functions/combinators
title: 'Комбинаторы агрегатных функций'
---


# Комбинаторы агрегатных функций

Имя агрегатной функции может иметь суффикс. Это изменяет работу агрегатной функции.

## -If {#-if}

Суффикс -If может быть добавлен к имени любой агрегатной функции. В этом случае агрегатная функция принимает дополнительный аргумент — условие (тип Uint8). Агрегатная функция обрабатывает только строки, которые удовлетворяют условию. Если условие не срабатывало ни разу, она возвращает значение по умолчанию (обычно нули или пустые строки).

Примеры: `sumIf(column, cond)`, `countIf(cond)`, `avgIf(x, cond)`, `quantilesTimingIf(level1, level2)(x, cond)`, `argMinIf(arg, val, cond)` и так далее.

С помощью условных агрегатных функций вы можете вычислять агрегаты для нескольких условий одновременно, без использования подзапросов и `JOIN`s. Например, условные агрегатные функции могут использоваться для реализации функциональности сравнения сегментов.

## -Array {#-array}

Суффикс -Array может быть добавлен к любой агрегатной функции. В этом случае агрегатная функция принимает аргументы типа 'Array(T)' (массивы) вместо аргументов типа 'T'. Если агрегатная функция принимает несколько аргументов, это должны быть массивы одинаковой длины. При обработке массивов агрегатная функция работает так же, как оригинальная агрегатная функция, применяемая ко всем элементам массива.

Пример 1: `sumArray(arr)` — Суммирует все элементы всех массивов 'arr'. В этом примере это можно было бы записать проще: `sum(arraySum(arr))`.

Пример 2: `uniqArray(arr)` — Считает количество уникальных элементов во всех массивах 'arr'. Это можно было бы сделать проще: `uniq(arrayJoin(arr))`, но не всегда возможно добавить 'arrayJoin' к запросу.

-If и -Array могут комбинироваться. Однако 'Array' должен быть первым, затем 'If'. Примеры: `uniqArrayIf(arr, cond)`, `quantilesTimingArrayIf(level1, level2)(arr, cond)`. Из-за этого порядка аргумент 'cond' не будет массивом.

## -Map {#-map}

Суффикс -Map может быть добавлен к любой агрегатной функции. Это создаст агрегатную функцию, которая получает аргумент типа Map и агрегирует значения каждого ключа карты отдельно, используя указанную агрегатную функцию. Результат также имеет тип Map.

**Пример**

```sql
CREATE TABLE map_map(
    date Date,
    timeslot DateTime,
    status Map(String, UInt64)
) ENGINE = Log;

INSERT INTO map_map VALUES
    ('2000-01-01', '2000-01-01 00:00:00', (['a', 'b', 'c'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:00:00', (['c', 'd', 'e'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', (['d', 'e', 'f'], [10, 10, 10])),
    ('2000-01-01', '2000-01-01 00:01:00', (['f', 'g', 'g'], [10, 10, 10]));

SELECT
    timeslot,
    sumMap(status),
    avgMap(status),
    minMap(status)
FROM map_map
GROUP BY timeslot;

┌────────────timeslot─┬─sumMap(status)───────────────────────┬─avgMap(status)───────────────────────┬─minMap(status)───────────────────────┐
│ 2000-01-01 00:00:00 │ {'a':10,'b':10,'c':20,'d':10,'e':10} │ {'a':10,'b':10,'c':10,'d':10,'e':10} │ {'a':10,'b':10,'c':10,'d':10,'e':10} │
│ 2000-01-01 00:01:00 │ {'d':10,'e':10,'f':20,'g':20}        │ {'d':10,'e':10,'f':10,'g':10}        │ {'d':10,'e':10,'f':10,'g':10}        │
└─────────────────────┴──────────────────────────────────────┴──────────────────────────────────────┴──────────────────────────────────────┘
```

## -SimpleState {#-simplestate}

Если вы применяете этот комбинатор, агрегатная функция возвращает то же значение, но с другим типом. Это [SimpleAggregateFunction(...)](../../sql-reference/data-types/simpleaggregatefunction.md), который может храниться в таблице для работы с [AggregatingMergeTree](../../engines/table-engines/mergetree-family/aggregatingmergetree.md) таблицами.

**Синтаксис**

```sql
<aggFunction>SimpleState(x)
```

**Аргументы**

- `x` — Параметры агрегатной функции.

**Возвращаемые значения**

Значение агрегатной функции с типом `SimpleAggregateFunction(...)`.

**Пример**

Запрос:

```sql
WITH anySimpleState(number) AS c SELECT toTypeName(c), c FROM numbers(1);
```

Результат:

```text
┌─toTypeName(c)────────────────────────┬─c─┐
│ SimpleAggregateFunction(any, UInt64) │ 0 │
└──────────────────────────────────────┴───┘
```

## -State {#-state}

Если вы применяете этот комбинатор, агрегатная функция не возвращает итоговое значение (например, количество уникальных значений для функции [uniq](/sql-reference/aggregate-functions/reference/uniq)), а промежуточное состояние агрегации (для `uniq` это хеш-таблица для подсчета количества уникальных значений). Это `AggregateFunction(...)`, который может использоваться для дальнейшей обработки или храниться в таблице для завершения агрегации позже.

:::note
Обратите внимание, что -MapState не является инвариантом для одних и тех же данных из-за того, что порядок данных в промежуточном состоянии может изменяться, хотя это не влияет на прием этих данных.
:::

Для работы с этими состояниями используйте:

- [AggregatingMergeTree](../../engines/table-engines/mergetree-family/aggregatingmergetree.md) движок таблицы.
- [finalizeAggregation](/sql-reference/functions/other-functions#finalizeaggregation) функция.
- [runningAccumulate](../../sql-reference/functions/other-functions.md#runningaccumulate) функция.
- [-Merge](#-merge) комбинатор.
- [-MergeState](#-mergestate) комбинатор.

## -Merge {#-merge}

Если вы применяете этот комбинатор, агрегатная функция принимает промежуточное состояние агрегации в качестве аргумента, сочетает состояния для завершения агрегации и возвращает итоговое значение.

## -MergeState {#-mergestate}

Объединяет промежуточные состояния агрегации так же, как и комбинатор -Merge. Однако он не возвращает итоговое значение, а промежуточное состояние агрегации, аналогично комбинатору -State.

## -ForEach {#-foreach}

Преобразует агрегатную функцию для таблиц в агрегатную функцию для массивов, которая агрегирует соответствующие элементы массива и возвращает массив результатов. Например, `sumForEach` для массивов `[1, 2]`, `[3, 4, 5]` и `[6, 7]` возвращает результат `[10, 13, 5]` после сложения соответствующих элементов массива.

## -Distinct {#-distinct}

Каждая уникальная комбинация аргументов будет агрегироваться только один раз. Повторяющиеся значения игнорируются. Примеры: `sum(DISTINCT x)` (или `sumDistinct(x)`), `groupArray(DISTINCT x)` (или `groupArrayDistinct(x)`), `corrStable(DISTINCT x, y)` (или `corrStableDistinct(x, y)`) и так далее.

## -OrDefault {#-ordefault}

Изменяет поведение агрегатной функции.

Если у агрегатной функции нет входных значений, с этим комбинатором она возвращает значение по умолчанию для своего возвращаемого типа данных. Применяется к агрегатным функциям, которые могут принимать пустые входные данные.

`-OrDefault` можно использовать с другими комбинаторами.

**Синтаксис**

```sql
<aggFunction>OrDefault(x)
```

**Аргументы**

- `x` — Параметры агрегатной функции.

**Возвращаемые значения**

Возвращает значение по умолчанию типа возвращаемых значений агрегатной функции, если нечего агрегировать.

Тип зависит от используемой агрегатной функции.

**Пример**

Запрос:

```sql
SELECT avg(number), avgOrDefault(number) FROM numbers(0)
```

Результат:

```text
┌─avg(number)─┬─avgOrDefault(number)─┐
│         nan │                    0 │
└─────────────┴──────────────────────┘
```

Также `-OrDefault` можно использовать с другими комбинаторами. Это полезно, когда агрегатная функция не принимает пустой ввод.

Запрос:

```sql
SELECT avgOrDefaultIf(x, x > 10)
FROM
(
    SELECT toDecimal32(1.23, 2) AS x
)
```

Результат:

```text
┌─avgOrDefaultIf(x, greater(x, 10))─┐
│                              0.00 │
└───────────────────────────────────┘
```

## -OrNull {#-ornull}

Изменяет поведение агрегатной функции.

Этот комбинатор преобразует результат агрегатной функции в тип [Nullable](../../sql-reference/data-types/nullable.md). Если у агрегатной функции нет значений для вычисления, она возвращает [NULL](/operations/settings/formats#input_format_null_as_default).

`-OrNull` можно использовать с другими комбинаторами.

**Синтаксис**

```sql
<aggFunction>OrNull(x)
```

**Аргументы**

- `x` — Параметры агрегатной функции.

**Возвращаемые значения**

- Результат агрегатной функции, преобразованный в тип `Nullable`.
- `NULL`, если нечего агрегировать.

Тип: `Nullable(тип возвращаемого значения агрегатной функции)`.

**Пример**

Добавьте `-orNull` в конце агрегатной функции.

Запрос:

```sql
SELECT sumOrNull(number), toTypeName(sumOrNull(number)) FROM numbers(10) WHERE number > 10
```

Результат:

```text
┌─sumOrNull(number)─┬─toTypeName(sumOrNull(number))─┐
│              ᴺᵁᴸᴸ │ Nullable(UInt64)              │
└───────────────────┴───────────────────────────────┘
```

Также `-OrNull` можно использовать с другими комбинаторами. Это полезно, когда агрегатная функция не принимает пустой ввод.

Запрос:

```sql
SELECT avgOrNullIf(x, x > 10)
FROM
(
    SELECT toDecimal32(1.23, 2) AS x
)
```

Результат:

```text
┌─avgOrNullIf(x, greater(x, 10))─┐
│                           ᴺᵁᴸᴸ │
└────────────────────────────────┘
```

## -Resample {#-resample}

Позволяет вам делить данные на группы, а затем отдельно агрегировать данные в этих группах. Группы создаются путем разбивки значений из одной колонки на интервалы.

```sql
<aggFunction>Resample(start, end, step)(<aggFunction_params>, resampling_key)
```

**Аргументы**

- `start` — Начальное значение всего требуемого интервала для значений `resampling_key`.
- `stop` — Конечное значение всего требуемого интервала для значений `resampling_key`. Весь интервал не включает значение `stop` `[start, stop)`.
- `step` — Шаг для разделения всего интервала на подинтервалы. Функция `aggFunction` выполняется по каждому из этих подинтервалов независимо.
- `resampling_key` — Колонка, значения которой используются для разделения данных на интервалы.
- `aggFunction_params` — Параметры `aggFunction`.

**Возвращаемые значения**

- Массив результатов `aggFunction` для каждого подинтервала.

**Пример**

Рассмотрим таблицу `people` со следующими данными:

```text
┌─name───┬─age─┬─wage─┐
│ John   │  16 │   10 │
│ Alice  │  30 │   15 │
│ Mary   │  35 │    8 │
│ Evelyn │  48 │ 11.5 │
│ David  │  62 │  9.9 │
│ Brian  │  60 │   16 │
└────────┴─────┴──────┘
```

Давайте получим имена людей, чей возраст находится в интервалах `[30,60)` и `[60,75)`. Поскольку мы используем целочисленное представление возраста, мы получаем возраста в интервалах `[30, 59]` и `[60,74]`.

Чтобы агрегировать имена в массиве, мы используем агрегатную функцию [groupArray](/sql-reference/aggregate-functions/reference/grouparray). Она принимает один аргумент. В нашем случае это колонка `name`. Функция `groupArrayResample` должна использовать колонку `age` для агрегации имен по возрасту. Для определения требуемых интервалов мы передаем аргументы `30, 75, 30` в функцию `groupArrayResample`.

```sql
SELECT groupArrayResample(30, 75, 30)(name, age) FROM people
```

```text
┌─groupArrayResample(30, 75, 30)(name, age)─────┐
│ [['Alice','Mary','Evelyn'],['David','Brian']] │
└───────────────────────────────────────────────┘
```

Смотрим на результаты.

`John` не входит в выборку, потому что он слишком молод. Другие люди распределены в соответствии с заданными возрастными интервалами.

Теперь давайте посчитаем общее количество людей и их среднюю зарплату в указанных возрастных интервалах.

```sql
SELECT
    countResample(30, 75, 30)(name, age) AS amount,
    avgResample(30, 75, 30)(wage, age) AS avg_wage
FROM people
```

```text
┌─amount─┬─avg_wage──────────────────┐
│ [3,2]  │ [11.5,12.949999809265137] │
└────────┴───────────────────────────┘
```

## -ArgMin {#-argmin}

Суффикс -ArgMin может быть добавлен к имени любой агрегатной функции. В этом случае агрегатная функция принимает дополнительный аргумент, который должен быть любым сопоставимым выражением. Агрегатная функция обрабатывает только строки, которые имеют минимальное значение для указанного дополнительного выражения.

Примеры: `sumArgMin(column, expr)`, `countArgMin(expr)`, `avgArgMin(x, expr)` и так далее.

## -ArgMax {#-argmax}

Похоже на суффикс -ArgMin, но обрабатывает только строки, которые имеют максимальное значение для указанного дополнительного выражения.

## Связанный контент {#related-content}

- Блог: [Использование агрегатных комбинаторов в ClickHouse](https://clickhouse.com/blog/aggregate-functions-combinators-in-clickhouse-for-arrays-maps-and-states)
