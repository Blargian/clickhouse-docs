---
slug: /architecture/cluster-deployment
sidebar_label: 'Развертывание кластера'
sidebar_position: 100
title: 'Развертывание кластера'
description: 'Пройдя этот урок, вы научитесь настраивать простой кластер ClickHouse.'
---

Этот урок предполагает, что вы уже настроили [локальный сервер ClickHouse](../getting-started/install.md).

Пройдя этот урок, вы научитесь настраивать простой кластер ClickHouse. Он будет небольшим, но отказоустойчивым и масштабируемым. Затем мы будем использовать один из примерных наборов данных, чтобы заполнить его данными и выполнить некоторые демонстрационные запросы.

## Развертывание кластера {#cluster-deployment}

Этот кластер ClickHouse будет однородным. Вот шаги:

1.  Установите сервер ClickHouse на всех машинах кластера.
2.  Настройте конфигурации кластера в файлах конфигурации.
3.  Создайте локальные таблицы на каждом экземпляре.
4.  Создайте [распределённую таблицу](../engines/table-engines/special/distributed.md).

[Распределённая таблица](../engines/table-engines/special/distributed.md) — это своего рода "представление" локальных таблиц в кластере ClickHouse. Запрос SELECT из распределённой таблицы выполняется с использованием ресурсов всех шардов кластера. Вы можете указать конфигурации для нескольких кластеров и создать несколько распределённых таблиц для предоставления представлений для разных кластеров.

Вот пример конфигурации для кластера с тремя шардами, с одной репликой каждый:

```xml
<remote_servers>
    <perftest_3shards_1replicas>
        <shard>
            <replica>
                <host>example-perftest01j.clickhouse.com</host>
                <port>9000</port>
            </replica>
        </shard>
        <shard>
            <replica>
                <host>example-perftest02j.clickhouse.com</host>
                <port>9000</port>
            </replica>
        </shard>
        <shard>
            <replica>
                <host>example-perftest03j.clickhouse.com</host>
                <port>9000</port>
            </replica>
        </shard>
    </perftest_3shards_1replicas>
</remote_servers>
```

Для дальнейшей демонстрации давайте создадим новую локальную таблицу с тем же запросом `CREATE TABLE`, который мы использовали для `hits_v1` в учебнике по развертыванию на одном узле, но с другим именем таблицы:

```sql
CREATE TABLE tutorial.hits_local (...) ENGINE = MergeTree() ...
```

Создание распределённой таблицы предоставляет представление в локальные таблицы кластера:

```sql
CREATE TABLE tutorial.hits_all AS tutorial.hits_local
ENGINE = Distributed(perftest_3shards_1replicas, tutorial, hits_local, rand());
```

Общей практикой является создание аналогичных распределённых таблиц на всех машинах кластера. Это позволяет выполнять распределённые запросы на любой машине кластера. Также есть альтернативный вариант создания временной распределённой таблицы для данного запроса SELECT с использованием [remote](../sql-reference/table-functions/remote.md) табличной функции.

Давайте выполните [INSERT SELECT](../sql-reference/statements/insert-into.md) в распределённую таблицу, чтобы распространить таблицу по нескольким серверам.

```sql
INSERT INTO tutorial.hits_all SELECT * FROM tutorial.hits_v1;
```

Как вы могли ожидать, ресурсоёмкие запросы выполняются в N раз быстрее, если они используют 3 сервера вместо одного.

В этом случае мы используем кластер с 3 шардом, и каждый шарда содержит одну реплику.

Для обеспечения надёжности в производственной среде мы рекомендуем, чтобы каждая шард содержала 2-3 реплики, распределённые между несколькими зонами доступности или дата-центрами (или, по крайней мере, стойками). Обратите внимание, что ClickHouse поддерживает неограниченное количество реплик.

Вот пример конфигурации для кластера с одной шардой, содержащей три реплики:

```xml
<remote_servers>
    ...
    <perftest_1shards_3replicas>
        <shard>
            <replica>
                <host>example-perftest01j.clickhouse.com</host>
                <port>9000</port>
             </replica>
             <replica>
                <host>example-perftest02j.clickhouse.com</host>
                <port>9000</port>
             </replica>
             <replica>
                <host>example-perftest03j.clickhouse.com</host>
                <port>9000</port>
             </replica>
        </shard>
    </perftest_1shards_3replicas>
</remote_servers>
```

Чтобы включить нативную репликацию, требуется [ZooKeeper](http://zookeeper.apache.org/). ClickHouse заботится о целостности данных на всех репликах и автоматически запускает процедуру восстановления после сбоя. Рекомендуется развернуть кластер ZooKeeper на отдельных серверах (где не работают другие процессы, включая ClickHouse).

:::note Примечание
ZooKeeper не является строгим требованием: в некоторых простых случаях вы можете дублировать данные, записывая их во все реплики из вашего прикладного кода. Такой подход **не** рекомендуется, так как в этом случае ClickHouse не сможет гарантировать целостность данных на всех репликах. Таким образом, это становится ответственностью вашего приложения.
:::

Местоположения ZooKeeper указаны в файле конфигурации:

```xml
<zookeeper>
    <node>
        <host>zoo01.clickhouse.com</host>
        <port>2181</port>
    </node>
    <node>
        <host>zoo02.clickhouse.com</host>
        <port>2181</port>
    </node>
    <node>
        <host>zoo03.clickhouse.com</host>
        <port>2181</port>
    </node>
</zookeeper>
```

Кроме того, нам нужно установить макросы для идентификации каждой шарды и реплики, используемые при создании таблиц:

```xml
<macros>
    <shard>01</shard>
    <replica>01</replica>
</macros>
```

Если в момент создания реплицированной таблицы нет реплик, создаётся новая первая реплика. Если уже есть активные реплики, новая реплика клонирует данные из существующих. У вас есть возможность создать все реплицированные таблицы сначала, а затем вставить данные в них. Другой вариант - создать некоторые реплики и добавить другие после или во время вставки данных.

```sql
CREATE TABLE tutorial.hits_replica (...)
ENGINE = ReplicatedMergeTree(
    '/clickhouse_perftest/tables/{shard}/hits',
    '{replica}'
)
...
```

Здесь мы используем движок таблиц [ReplicatedMergeTree](../engines/table-engines/mergetree-family/replication.md). В параметрах мы указываем путь ZooKeeper, содержащий идентификаторы шарды и реплики.

```sql
INSERT INTO tutorial.hits_replica SELECT * FROM tutorial.hits_local;
```

Репликация работает в режиме многоуровневого управления. Данные могут загружаться в любую реплику, и система затем синхронизирует их с другими экземплярами автоматически. Репликация является асинхронной, поэтому в данный момент времени не все реплики могут содержать недавно вставленные данные. По крайней мере одна реплика должна быть активной, чтобы обеспечить приём данных. Другие синхронизируют данные и восстанавливают целостность, как только они вновь станут активными. Обратите внимание, что такой подход позволяет снизить вероятность потери недавно вставленных данных.
