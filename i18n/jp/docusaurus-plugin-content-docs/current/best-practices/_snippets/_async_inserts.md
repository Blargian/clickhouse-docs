
import Image from '@theme/IdealImage';
import async_inserts from '@site/static/images/bestpractices/async_inserts.png';

ClickHouseの非同期インサートは、クライアント側でのバッチ処理が実行できない場合に強力な代替手段を提供します。これは特に、数百または数千のエージェントが継続的にデータを送信する観測可能性ワークロードで価値があります - ログ、メトリクス、トレース - 多くの場合、小さなリアルタイムペイロードで行われます。このような環境でクライアント側にデータをバッファリングすると、十分に大きなバッチを送信するための中央キューが必要になり、複雑さが増します。

:::note
同期モードで多数の小さなバッチを送信することは推奨されません。これにより、多くのパーツが作成されます。これにより、クエリパフォーマンスが低下し、["too many part"](/knowledgebase/exception-too-many-parts) エラーが発生します。
:::

非同期インサートは、受信データをインメモリバッファに書き込み、設定可能なしきい値に基づいてストレージにフラッシュすることにより、クライアントからサーバへのバッチ処理の責任を移します。このアプローチは、パーツ作成のオーバーヘッドを大幅に削減し、CPU使用率を下げ、同時実行性が高い環境でも効率的なインジェスチョンを保証します。

コアの動作は、[`async_insert`](/operations/settings/settings#async_insert) 設定によって制御されます。

<Image img={async_inserts} size="lg" alt="非同期インサート"/>

有効にすると (1)、インサートはバッファリングされ、フラッシュ条件の1つが満たされたときにのみディスクに書き込まれます：

(1) バッファが指定されたサイズに達する (async_insert_max_data_size)  
(2) 時間のしきい値が経過する (async_insert_busy_timeout_ms)  または  
(3) 複数のインサートクエリが蓄積される (async_insert_max_query_number)。

このバッチ処理プロセスはクライアントには見えず、ClickHouseは複数のソースからのインサートトラフィックを効率的にマージします。ただし、フラッシュが行われるまでデータをクエリすることはできません。重要なのは、インサートの形状と設定の組み合わせごとに複数のバッファが存在し、クラスター内ではノードごとにバッファが維持されるため、マルチテナント環境での細かい制御が可能になります。インサートのメカニズムは、[同期インサート](/best-practices/selecting-an-insert-strategy#synchronous-inserts-by-default) に関して説明されているものと同じです。

### 戻り値モードの選択 {#choosing-a-return-mode}

非同期インサートの動作は、[`wait_for_async_insert`](/operations/settings/settings#wait_for_async_insert) 設定を使用してさらに洗練させることができます。

1に設定すると (デフォルト) 、ClickHouseはデータがディスクに正常にフラッシュされるまでインサートを認識しません。これにより、強い耐久性保証が確保され、エラーハンドリングが簡素化されます：フラッシュ中に何かがうまくいかない場合、エラーはクライアントに返されます。このモードは、インサートの失敗を確実に追跡する必要がある特に多くの運用シナリオで推奨されます。

[ベンチマーク](https://clickhouse.com/blog/asynchronous-data-inserts-in-clickhouse)は、200または500のクライアントを実行していても、適応型インサートと安定したパーツ作成の動作のおかげで、同時実行性に良くスケーラブルであることを示しています。

`wait_for_async_insert = 0`を設定すると、「ファイア・アンド・フォゲット」モードが有効になります。ここでは、サーバーはデータがバッファリングされるとすぐにインサートを認識し、ストレージに到達するのを待ちません。

これは超低レイテンシのインサートと最大スループットを提供し、高速で低重要なデータに最適ですが、データが永続化される保証はなく、エラーはフラッシュ中にのみ発生する可能性があり、失敗したインサートを追跡するのが難しいというトレードオフがあります。このモードは、ワークロードがデータの損失に耐えられる場合にのみ使用してください。

[ベンチマークも示しています](https://clickhouse.com/blog/asynchronous-data-inserts-in-clickhouse) バッファフラッシュがあまり発生しない場合 (例：30秒ごと) に、パーツの大幅な削減と低いCPU使用率があることがわかりますが、サイレント失敗のリスクは残ります。

非同期インサートを使用する場合、`async_insert=1,wait_for_async_insert=1`の使用を強く推奨します。`wait_for_async_insert=0`を使用することは非常に危険で、INSERTクライアントがエラーに気付かない可能性があり、ClickHouseサーバーが書き込みを遅くしたり、サービスの信頼性を確保するためにバックプレッシャーを作成する必要がある状況で、クライアントが迅速に書き込み続けると潜在的な過負荷を引き起こす可能性があります。

### 重複排除と信頼性 {#deduplication-and-reliability}

デフォルトでは、ClickHouseは同期インサートに対して自動的に重複排除を実行するため、失敗シナリオでの再試行が安全です。ただし、非同期インサートには明示的に有効にしない限り無効です（依存関係のあるマテリアライズドビューがある場合は有効にしないでください - [問題を参照](https://github.com/ClickHouse/ClickHouse/issues/66003)）。

実際には、重複排除がオンになっていて、同じインサートが再試行されると、たとえばタイムアウトやネットワークの切断によるものであれば、ClickHouseは重複を安全に無視できます。これにより、冪等性が維持され、データの二重書き込みを避けることができます。ただし、バッファフラッシュ中にのみインサートの検証とスキーマの解析が行われるため、エラー（型の不一致など）はその時点でのみ発生します。

### 非同期インサートの有効化 {#enabling-asynchronous-inserts}

非同期インサートは特定のユーザーまたは特定のクエリのために有効にすることができます：

- ユーザーレベルで非同期インサートを有効にする。この例では、ユーザー `default` を使用しています。他のユーザーを作成する場合は、そのユーザー名に置き換えてください：
  ```sql
  ALTER USER default SETTINGS async_insert = 1
  ```
- インサートクエリのSETTINGS句を使用して非同期インサート設定を指定することができます：
  ```sql
  INSERT INTO YourTable SETTINGS async_insert=1, wait_for_async_insert=1 VALUES (...)
  ```
- ClickHouseプログラミング言語クライアントを使用する際に、接続パラメータとして非同期インサート設定を指定することもできます。

  たとえば、ClickHouse Cloud に接続するためにClickHouse Java JDBCドライバを使用する場合、JDBC接続文字列内でそれを行う方法：
  ```bash
  "jdbc:ch://HOST.clickhouse.cloud:8443/?user=default&password=PASSWORD&ssl=true&custom_http_params=async_insert=1,wait_for_async_insert=1"
  ```
```
