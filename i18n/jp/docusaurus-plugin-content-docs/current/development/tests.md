---
description: 'ClickHouseのテストとテストスイートの実行に関するガイド'
sidebar_label: 'テスト'
sidebar_position: 40
slug: /development/tests
title: 'ClickHouseのテスト'
---


# ClickHouseのテスト

## 機能テスト {#functional-tests}

機能テストは、最も単純で便利な使い方ができます。
ClickHouseのほとんどの機能は、機能テストを使用してテストでき、ClickHouseコードに変更を加える際には、必ず使用する必要があります。

各機能テストは、実行中のClickHouseサーバーに1つまたは複数のクエリを送信し、結果を参照と比較します。

テストは `queries` ディレクトリにあります。
2つのサブディレクトリがあります: `stateless` と `stateful` です。
- ステートレステストは、事前にロードされたテストデータなしでクエリを実行します - しばしばテスト自体の中で小さな合成データセットを動的に作成します。
- ステートフルテストは、ClickHouseから事前にロードされたテストデータを必要とし、一般公に利用可能です。[継続的インテグレーションにおけるステートフルテスト](continuous-integration.md#functional-stateful-tests)を参照してください。

各テストは、`.sql`および`.sh`の2つのタイプのいずれかです。
- `.sql` テストは、シンプルなSQLスクリプトで、`clickhouse-client` にパイプされます。
- `.sh` テストは、自身が実行されるスクリプトです。

通常、SQLテストは `.sh` テストよりも好ましいです。
純粋なSQLからは操作できない機能をテストする必要がある場合のみ、`.sh` テストを使用するべきです。例えば、入力データを `clickhouse-client` にパイプしたり、`clickhouse-local` をテストする場合です。

:::note
`DateTime` および `DateTime64` のデータ型をテストする際の一般的な間違いは、サーバーが特定のタイムゾーン（例: "UTC"）を使用していると想定することです。これは当てはまりません、CIテストの実行時にはタイムゾーンが故意にランダム化されます。テスト値に対してタイムゾーンを明示的に指定する最も簡単な回避策は、`toDateTime64(val, 3, 'Europe/Amsterdam')` を使用することです。
:::

### ローカルでのテスト実行 {#running-a-test-locally}

デフォルトポート（9000）でリッスンするようにローカルでClickHouseサーバーを起動します。
例えば、テスト `01428_hash_set_nan_key` を実行するには、リポジトリフォルダーに移動し、次のコマンドを実行します:

```sh
PATH=<path to clickhouse-client>:$PATH tests/clickhouse-test 01428_hash_set_nan_key
```

テスト結果（`stderr` および `stdout`）は、テスト自体の隣にあるファイル `01428_hash_set_nan_key.[stderr|stdout]` に書き込まれます（`queries/0_stateless/foo.sql` の出力は `queries/0_stateless/foo.stdout` になります）。

すべてのオプションは `tests/clickhouse-test --help` で確認できます。
すべてのテストを実行するか、テスト名のフィルターを提供してテストのサブセットを実行できます: `./clickhouse-test substring`。
テストを並列で実行したり、ランダム順に実行するオプションもあります。

### 新しいテストの追加 {#adding-a-new-test}

新しいテストを追加するには、まず `queries/0_stateless` ディレクトリに `.sql` または `.sh` ファイルを作成します。
次に、`clickhouse-client < 12345_test.sql > 12345_test.reference` または `./12345_test.sh > ./12345_test.reference` を使用して対応する `.reference` ファイルを生成します。

テストは、あらかじめ自動的に作成されるデータベース `test` において、テーブルの作成、削除、選択などのみを行う必要があります。
一時テーブルを使用することは問題ありません。

CIと同じ環境をローカルでセットアップするには、テスト構成をインストールしてください（Zookeeperのモック実装を使用し、いくつかの設定を調整します）。

```sh
cd <repository>/tests/config
sudo ./install.sh
```

:::note
テストは以下の条件を満たすべきです:
- 最小限であること: 最小限必要なテーブル、カラム、および複雑さのみを作成すること、
- 速いこと: 数秒（できればサブ秒）以上かかってはならないこと、
- 正確で決定論的であること: 機能が動作しない場合のみ失敗すること、
- 孤立している/ステートレスであること: 環境やタイミングに依存しないこと
- 徹底的であること: ゼロ、ヌル、空のセット、例外（負のテスト、`-- { serverError xyz }` と `-- { clientError xyz }` 構文を使用）などのコーナーケースをカバーすること、
- テストの最後にテーブルをクリーンアップすること（残り物がある場合）、
- 他のテストが同じ内容をテストしないことを確認すること（すなわち、最初にgrepを実行すること）。
:::

### テスト実行の制限 {#restricting-test-runs}

テストは、CI内でどのコンテキストで実行されるかを指定する制限を持つ0個以上の _tags_ を持つことができます。

`.sql` テストでは、タグはSQLコメントとして最初の行に配置されます:

```sql
-- Tags: no-fasttest, no-replicated-database
-- no-fasttest: <provide_a_reason_for_the_tag_here>
-- no-replicated-database: <provide_a_reason_here>

SELECT 1
```

`.sh` テストでは、タグは2行目にコメントとして書かれます:

```bash
#!/usr/bin/env bash

# Tags: no-fasttest, no-replicated-database

# - no-fasttest: <provide_a_reason_for_the_tag_here>

# - no-replicated-database: <provide_a_reason_here>
```

利用可能なタグのリスト:

|タグ名 | 何をするか | 使用例 |
|---|---|---|
| `disabled`| テストは実行されません ||
| `long` | テストの実行時間が1分から10分に延長されます ||
| `deadlock` | テストは長時間ループで実行されます ||
| `race` | `deadlock` と同様です。`deadlock` を推奨します ||
| `shard` | サーバーは `127.0.0.*` をリッスンする必要があります ||
| `distributed` | `shard` と同様です。`shard` を推奨します ||
| `global` | `shard` と同様です。`shard` を推奨します ||
| `zookeeper` | テストは実行するためにZookeeperまたはClickHouse Keeperを必要とします | テストは `ReplicatedMergeTree` を使用します |
| `replica` | `zookeeper` と同様です。`zookeeper` を推奨します ||
| `no-fasttest`|  テストは [Fast test](continuous-integration.md#fast-test) の下では実行されません | テストは、Fast testで無効な `MySQL` テーブルエンジンを使用します|
| `no-[asan, tsan, msan, ubsan]` | [サニタイザー](#sanitizers)のあるビルドでテストを無効にします | テストはQEMUで実行され、サニタイザーは機能しません |
| `no-replicated-database` |||
| `no-ordinary-database` |||
| `no-parallel` | このテストと並行して他のテストの実行を無効にします | テストは `system` テーブルから読み込み、不変条件が破れる可能性があります |
| `no-parallel-replicas` |||
| `no-debug` |||
| `no-stress` |||
| `no-polymorphic-parts` |||
| `no-random-settings` |||
| `no-random-merge-tree-settings` |||
| `no-backward-compatibility-check` |||
| `no-cpu-x86_64` |||
| `no-cpu-aarch64` |||
| `no-cpu-ppc64le` |||
| `no-s3-storage` |||

上記の設定に加えて、特定のClickHouse機能の使用を定義するために `system.build_options` から `USE_*` フラグを使用できます。
例えば、テストがMySQLテーブルを使用する場合は、タグ `use-mysql` を追加する必要があります。

### ランダム設定の制限を指定する {#specifying-limits-for-random-settings}

テストは、テスト実行中にランダム化される可能性のある設定の最小および最大許可値を指定できます。

`.sh` テストでは、制限はタグの隣の行か、タグが指定されていない場合は2行目にコメントとして書かれます:

```bash
#!/usr/bin/env bash

# Tags: no-fasttest

# Random settings limits: max_block_size=(1000, 10000); index_granularity=(100, None)
```

`.sql` テストでは、タグはタグの隣の行か、最初の行としてSQLコメントとして配置されます:

```sql
-- Tags: no-fasttest
-- Random settings limits: max_block_size=(1000, 10000); index_granularity=(100, None)
SELECT 1
```

一つの制限だけを指定する場合は、もう一方に `None` を使うことができます。

### テスト名の選択 {#choosing-the-test-name}

テストの名前は、5桁の接頭辞で始まり、それに続いて説明的な名前が続く形式（例: `00422_hash_function_constexpr.sql`）です。
接頭辞を選ぶには、ディレクトリ内に既に存在する最大の接頭辞を見つけ、それを1増やします。

```sh
ls tests/queries/0_stateless/[0-9]*.reference | tail -n 1
```

その間に、同じ数値の接頭辞を持つ他のテストが追加されるかもしれませんが、これは問題にはならず、後で変更する必要はありません。

### 発生するべきエラーのチェック {#checking-for-an-error-that-must-occur}

時には、誤ったクエリに対してサーバーエラーが発生することをテストしたいことがあります。私たちは、SQLテストにおいて以下の形式の特別な注釈をサポートしています:

```sql
select x; -- { serverError 49 }
```

このテストは、サーバーが未知のカラム `x` に関してコード49のエラーを返すことを保証します。
エラーが発生しない場合や、エラーが異なる場合、テストは失敗します。
クライアント側でエラーが発生することを保証したい場合は、`clientError` 注釈を代わりに使用してください。

エラーメッセージの具体的な表現を確認しないでください。将来的に変更される可能性があり、テストが不必要に壊れることになります。
エラーコードのみを確認してください。
既存のエラーコードがニーズに対して十分に正確でない場合は、新しいコードを追加することを検討してください。

### 分散クエリのテスト {#testing-a-distributed-query}

機能テストで分散クエリを使用する場合は、サーバーが自分自身をクエリできるように `127.0.0.{1..2}` アドレスを持つ `remote` テーブル関数を活用することができます。または、サーバー設定ファイルに `test_shard_localhost` のような事前定義されたテストクラスターを使用することもできます。
テスト名に `shard` または `distributed` の単語を追加して、CI内で正しい設定で実行されるようにしてください。サーバーが分散クエリをサポートするように設定されています。

### 一時ファイルの取り扱い {#working-with-temporary-files}

時には、シェルテスト内で作業するためにファイルを動的に作成する必要があるかもしれません。
一部のCIチェックはテストを並行して実行するため、一意の名前なしで一時ファイルを作成または削除を行うと、FlakyなどのCIチェックが失敗する可能性があります。
これを回避するには、環境変数 `$CLICKHOUSE_TEST_UNIQUE_NAME` を使用して、実行中のテストに固有の名前を持つ一時ファイルを付与するべきです。
これにより、セットアップ中に作成するファイルやクリーンアップ中に削除するファイルが、そのテストだけで使用されているものであり、並行して実行されている他のテストによって利用されていないことが保証されます。

## 既知のバグ {#known-bugs}

機能テストによって容易に再現できるバグが知られている場合は、準備された機能テストを `tests/queries/bugs` ディレクトリに配置します。
これらのテストは、バグが修正されると `tests/queries/0_stateless` に移動されます。

## 統合テスト {#integration-tests}

統合テストは、クラスター構成でClickHouseをテストし、ClickHouseがMySQL、Postgres、MongoDBなどの他のサーバーとどのように相互作用するかをテストできます。
これらはネットワークの分割、パケットの損失などをエミュレートするのに便利です。
これらのテストはDockerの下で実行され、様々なソフトウェアを持つ複数のコンテナを作成します。

これらのテストを実行する方法については、`tests/integration/README.md` を参照してください。

ClickHouseとサードパーティドライバの統合はテストされていないことに注意してください。
また、現在のところJDBCおよびODBCドライバとの統合テストはありません。

## 単体テスト {#unit-tests}

単体テストは、ClickHouse全体ではなく、単一の孤立したライブラリやクラスをテストしたいときに役立ちます。
テストのビルドを有効または無効にするには、`ENABLE_TESTS` CMakeオプションを使用します。
単体テスト（および他のテストプログラム）は、コード内の `tests` サブディレクトリにあります。
単体テストを実行するには、`ninja test` と入力します。
一部のテストは `gtest` を使用しますが、他のものはテスト失敗時に非ゼロの終了コードを返すプログラムです。

コードが機能テストで既にカバーされている場合、単体テストは必ずしも必要ではありません（機能テストは通常はるかに簡単に使えます）。

個別のgtestチェックを直接実行ファイルを呼び出して実行することができます。例えば、

```bash
$ ./src/unit_tests_dbms --gtest_filter=LocalAddress*
```

## パフォーマンステスト {#performance-tests}

パフォーマンステストは、合成クエリのいくつかの孤立した部分のパフォーマンスを測定し、比較することを可能にします。
パフォーマンステストは `tests/performance/` にあります。
各テストは、テストケースの説明が含まれた `.xml` ファイルで表されます。
テストは `docker/test/performance-comparison` ツールで実行されます。起動方法についてはREADMEファイルを参照してください。

各テストは、1つまたは複数のクエリ（パラメータの組み合わせを含む可能性があります）をループで実行します。

特定のシナリオでClickHouseのパフォーマンスを改善したい場合、改善が単純なクエリで観察できる場合には、パフォーマンステストを書くことを強くお勧めします。
また、比較的孤立していてあまり不明瞭でないSQL関数を追加または変更する際には、パフォーマンステストを書くことが推奨されます。
テスト中に `perf top` や他の `perf` ツールを使用するのが常に理にかなっています。

## テストツールとスクリプト {#test-tools-and-scripts}

`tests` ディレクトリ内のいくつかのプログラムは、準備されたテストではなく、テストツールです。
例えば、`Lexer` のためのツールは、標準入力のトークン化を行い、色付けされた結果を標準出力に書き込む `src/Parsers/tests/lexer` です。
この種のツールをコードの例や調査、手動テストに使用できます。

## その他のテスト {#miscellaneous-tests}

`tests/external_models` には、機械学習モデルのテストがあります。
これらのテストは更新されておらず、統合テストに移行する必要があります。

クオラム挿入のための別のテストがあります。
このテストは、ClickHouseクラスターを別々のサーバーで実行し、さまざまな障害ケースをエミュレートします: ネットワーク分割、パケットドロップ（ClickHouseノード間、ClickHouseとZooKeeperの間、ClickHouseサーバーとクライアントの間など）、`kill -9`、`kill -STOP`および `kill -CONT` 、[Jepsen](https://aphyr.com/tags/Jepsen)のように。次に、テストは、すべての承認された挿入が書き込まれ、すべての拒否された挿入が書き込まれていないことを確認します。

クオラムテストは、ClickHouseがオープンソース化される前に別チームによって書かれました。
このチームは現在もClickHouseには関与していません。
テストは偶然にもJavaで記述されています。
この理由から、クオラムテストは書き直され、統合テストに移される必要があります。

## 手動テスト {#manual-testing}

新機能を開発する際には、手動でテストすることも合理的です。
次の手順で実行できます:

ClickHouseをビルドします。ターミナルからClickHouseを実行します: ディレクトリを `programs/clickhouse-server` に変更し、`./clickhouse-server` で実行します。それはデフォルトで現在のディレクトリからの構成（`config.xml`、`users.xml` および `config.d` および `users.d` ディレクトリ内のファイル）を使用します。ClickHouseサーバーに接続するには、`programs/clickhouse-client/clickhouse-client` を実行します。

すべてのClickHouseツール（サーバー、クライアントなど）は、`clickhouse` という名前の単一のバイナリへのシンボリックリンクであることに注意してください。
このバイナリは `programs/clickhouse` にあります。
すべてのツールも `clickhouse tool` ではなく `clickhouse-tool` として呼び出すことができます。

代わりに、ClickHouseパッケージをインストールします: ClickHouseリポジトリからの安定版を使用するか、ClickHouseソースのルートで `./release` によって自分用にパッケージをビルドすることができます。
次に、`sudo clickhouse start` でサーバーを起動し（またはサーバーを停止するには停止します）。
ログは `/etc/clickhouse-server/clickhouse-server.log` にあります。

ClickHouseがすでにあなたのシステムにインストールされている場合には、新しい `clickhouse` バイナリをビルドして、既存のバイナリを置き換えることができます:

```bash
$ sudo clickhouse stop
$ sudo cp ./clickhouse /usr/bin/
$ sudo clickhouse start
```

また、システムのClickHouseサーバーを停止し、同じ構成のもとで端末にログを書き出すように自分のものを実行することもできます:

```bash
$ sudo clickhouse stop
$ sudo -u clickhouse /usr/bin/clickhouse server --config-file /etc/clickhouse-server/config.xml
```

gdbを使った例:

```bash
$ sudo -u clickhouse gdb --args /usr/bin/clickhouse server --config-file /etc/clickhouse-server/config.xml
```

システムのClickHouseサーバーがすでに実行中で停止したくない場合は、`config.xml`でポート番号を変更するか（各 `config.d` ディレクトリ内のファイルに上書き）、適切なデータパスを提供して実行します。

`clickhouse` バイナリはほとんど依存関係がなく、幅広いLinuxディストリビューションで動作します。
サーバー上で変更を迅速かつ簡易にテストするためには、単に新しくビルドした `clickhouse` バイナリをサーバーに `scp` し、上記の例のように実行することができます。

## ビルドテスト {#build-tests}

ビルドテストは、様々な代替構成や外部システム上でビルドが壊れていないことを確認します。
これらのテストも自動化されています。

例:
- Darwin x86_64 (macOS) 用のクロスコンパイル
- FreeBSD x86_64 用のクロスコンパイル
- Linux AArch64 用のクロスコンパイル
- システムパッケージからライブラリを使用してUbuntuでビルド（推奨されません）
- ライブラリの共有リンクを使用してビルド（推奨されません）

例えば、システムパッケージとともにビルドすることは悪い習慣です。なぜなら、システムにおいて正確にどのバージョンのパッケージが存在するかを保証できないからです。
しかし、これはDebianメンテナーによって本当に必要とされているため、このビルドの変種を少なくともサポートする必要があります。
別の例として、共有リンクが一般的な問題の原因であるが、いくつかの愛好家のために必要です。

すべてのビルドの代替チェックを行うことはできませんが、異なるビルドの変種が壊れていないことを確認したいという意図でビルドテストを使用します。

また、コンパイルが長すぎる翻訳単位や多くのRAMを必要とする単位がないことをテストします。

さらに、大きすぎるスタックフレームがないこともテストします。

## プロトコル互換性のテスト {#testing-for-protocol-compatibility}

ClickHouseのネットワークプロトコルを拡張する際には、手動で古いclickhouse-clientが新しいclickhouse-serverと正常に動作するか、新しいclickhouse-clientが古いclickhouse-serverで正常に動作するかをテストします（対応するパッケージからバイナリを実行することで）。

統合テストでいくつかのケースも自動的にテストしています:
- 古いバージョンのClickHouseによって書き込まれたデータを新しいバージョンで正常に読み取れるか;
- 異なるClickHouseバージョンでクラスター内の分散クエリが機能するか。

## コンパイラーからのヘルプ {#help-from-the-compiler}

メインのClickHouseコード（`src` ディレクトリに配置されている）は、`-Wall -Wextra -Werror` でビルドされ、いくつかの追加の警告も有効になっています。
これらのオプションは、サードパーティライブラリには有効にされていません。

Clangはさらに便利な警告を持っています - `-Weverything` を使用して検索し、デフォルトビルドで選択することができます。

私たちは常に開発及び生産環境のためにClickHouseをビルドする際にClangを使用しています。
あなたのマシン上でデバッグモードでビルドすることはできます（ラップトップのバッテリーを節約するために），しかしコンパイラーは `-O3` で優れた制御フローとプロシージャ間分析により、より多くの警告を生成することができることに注意してください。
デバッグモードでClangを使用してビルドする際には、より多くの実行時エラーを捕捉できるデバッグバージョンの `libc++` が使用されます。

## サニタイザー {#sanitizers}

:::note
プロセス（ClickHouseサーバーまたはクライアント）がローカルで起動時にクラッシュする場合は、アドレス空間レイアウトのランダム化を無効にする必要があるかもしれません: `sudo sysctl kernel.randomize_va_space=0`
:::

### アドレスサニタイザー {#address-sanitizer}

機能的、統合、ストレス、及び単体テストは、コミットごとにASanの下で実行されます。

### スレッドサニタイザー {#thread-sanitizer}

機能的、統合、ストレス、および単体テストは、コミットごとにTSanの下で実行されます。

### メモリサニタイザー {#memory-sanitizer}

機能的、統合、ストレス、および単体テストは、コミットごとにMSanの下で実行されます。

### 未定義動作サニタイザー {#undefined-behaviour-sanitizer}

機能的、統合、ストレス、および単体テストは、コミットごとにUBSanの下で実行されます。
一部のサードパーティライブラリのコードは、UBのサニタイジングが行われていません。

### Valgrind (Memcheck) {#valgrind-memcheck}

私たちは以前、Valgrindの下で機能テストを徹夜で実行していましたが、現在は行っていません。
数時間かかります。
現在、`re2`ライブラリにおいて既知の偽陽性が1つあります。詳細は[こちらの記事](https://research.swtch.com/sparse)を参照してください。

## ファジング {#fuzzing}

ClickHouseのファジングは、[libFuzzer](https://llvm.org/docs/LibFuzzer.html)とランダムなSQLクエリを使用して実装されています。
すべてのファジングテストは、サニタイザー（アドレスおよび未定義）を使用して実行する必要があります。

LibFuzzerは、ライブラリコードの孤立したファジングテストに使用されます。
ファジングはテストコードの一部として実装されており、"_fuzzer" の名前接尾辞があります。
ファジングの例は `src/Parsers/fuzzers/lexer_fuzzer.cpp` にあります。
LibFuzzer固有の設定、辞書、およびコーパスは `tests/fuzz` に格納されています。
私たちは、ユーザー入力を扱うすべての機能に対してファジングテストを書くことを奨励します。

ファジングツールはデフォルトでビルドされません。
ファジングをビルドするには、`-DENABLE_FUZZING=1` および `-DENABLE_TESTS=1` オプションを設定する必要があります。
ファジングをビルドするときにはJemallocを無効にすることをお勧めします。
Google OSS-FuzzにClickHouseファジングを統合するために使用される設定は `docker/fuzz` にあります。

また、ランダムなSQLクエリを生成して、サーバーがそれらを実行しても死なないかを確認するために簡単なファジングテストも使用しています。
これは `00746_sql_fuzzy.pl` にあります。
このテストは継続的に実行されるべきです（夜間およびそれ以上）。

さらに、特に多くのコーナーケースを見つけることができる高度なASTベースのクエリファジングツールも使用しています。
これはクエリのASTにおいてランダムな置換と置き換えを行います。
以前のテストからASTノードを記憶し、ランダム順で処理しながら後続のテストのファジングにそれらを使用します。
このファジングテストについての詳細は、[こちらのブログ記事](https://clickhouse.com/blog/fuzzing-click-house)で学ぶことができます。

## ストレステスト {#stress-test}

ストレステストは別のファジングのケースです。
すべての機能テストを並行でランダム順に単一のサーバー上で実行します。
テストの結果はチェックされません。

以下の条件がチェックされます:
- サーバーがクラッシュせず、デバッグやサニタイザーのトラップがトリガーされないこと;
- デッドロックがないこと;
- データベース構造が一貫していること;
- テスト後にサーバーが正常に停止し、例外なしに再起動できること。

5つのバリアントがあります（デバッグ、ASan、TSan、MSan、UBSan）。

## スレッドファジング {#thread-fuzzer}

スレッドファジング（スレッドサニタイザーと混同しないでください）は、スレッドの実行順序をランダム化する別のファジングの種類です。
これはさらに多くの特別なケースを見つけるのに役立ちます。

## セキュリティ監査 {#security-audit}

私たちのセキュリティチームは、セキュリティの観点からClickHouseの機能を基本的にレビューしました。

## 静的アナライザー {#static-analyzers}

私たちはコミットごとに `clang-tidy` を実行します。
`clang-static-analyzer` チェックも有効になっています。
`clang-tidy` はスタイルチェックにも使用されます。

私たちは `clang-tidy`, `Coverity`, `cppcheck`, `PVS-Studio`, `tscancode`, `CodeQL` を評価しました。
使用方法については `tests/instructions/` ディレクトリで見つけることができます。

もし `CLion` をIDEとして使用する場合は、標準でいくつかの `clang-tidy` チェックを利用できます。

また、シェルスクリプトの静的分析に `shellcheck` を使用しています。

## ハードニング {#hardening}

デバッグビルドでは、ユーザーレベルの割り当てにASLRを行うカスタムアロケータを使用しています。

また、割り当て後に読み取り専用であると予想されるメモリ領域を手動で保護します。

デバッグビルドでは、呼び出されることがない「有害な」（古くなった、安全でない、スレッドセーフでない）関数が呼び出されないようにするlibcのカスタマイズも行います。

デバッグアサーションが広範に使用されます。

デバッグビルドでは、「論理エラー」コードの例外がスローされる場合（バグを示唆している）、プログラムが早期に終了します。
これにより、リリースビルドで例外を使用し、デバッグビルドでアサーションにすることができます。

Jemallocのデバッグバージョンはデバッグビルドに使用されます。
libc++のデバッグバージョンもデバッグビルドに使用されます。

## 実行時整合性チェック {#runtime-integrity-checks}

ディスクに保存されたデータはチェックサム化されています。
MergeTreeテーブル内のデータは、同時に三つの方法でチェックサム化されています*（圧縮データブロック、非圧縮データブロック、ブロック間の総チェックサム）。
クライアントとサーバー間、またはサーバー間で転送されるデータもチェックサム化されています。
レプリケーションは、レプリカ上のビット単位で同一のデータを保証します。

これは、故障したハードウェア（ストレージメディアのビットロット、サーバーのRAMでのビットフリップ、ネットワークコントローラーのRAMでのビットフリップ、ネットワークスイッチのRAMでのビットフリップ、クライアントのRAMでのビットフリップ、ワイヤ上のビットフリップ）から保護する必要があります。
ビットフリップは一般的であり、ECC RAMやTCPチェックサムの存在でさえ、貴方が毎日ペタバイトのデータを処理する何千ものサーバーを稼働させる場合には発生する可能性が高いことに注意してください。
[このビデオを見てください (ロシア語)](https://www.youtube.com/watch?v=ooBAQIe0KlQ)。

ClickHouseは、オペレーションエンジニアリングが故障したハードウェアを特定するのを助ける診断を提供します。

\* そしてこれは遅くありません。

## コードスタイル {#code-style}

コードスタイルルールは[こちら](style.md)に記載されています。

一般的なスタイル違反をチェックするために、`utils/check-style` スクリプトを使用できます。

コードの正しいスタイルを強制するには、`clang-format` を使用します。
ファイル `.clang-format` はソースのルートにあります。
これは、私たちの実際のコードスタイルにほぼ対応します。
しかし、既存のファイルに `clang-format` を適用することは推奨されません。なぜなら、整形が悪化するからです。
`clang-format-diff` ツールを使用して、clangのソースリポジトリで見つけることができます。

あるいは、コードを再フォーマットするために `uncrustify` ツールを試すことができます。
設定はソースのルートにある `uncrustify.cfg` にあります。
これは `clang-format` よりもテストが少ないです。

`CLion` は、私たちのコードスタイルに合わせて調整が必要な独自のコードフォーマッタを持っています。

また、`codespell` を使用してコード内のタイプミスを見つけることもできます。
これも自動化されています。

## テストカバレッジ {#test-coverage}

私たちは機能テストに対してのみ、ClickHouseサーバーに対するテストカバレッジを追跡しています。
これは日次で実施されています。

## テストのためのテスト {#tests-for-tests}

フレーク テストの自動チェックがあります。
新しいテストを100回（機能テストの場合）または10回（統合テストの場合）実行します。
少なくとも1回でもテストが失敗すると、それはフレークと見なされます。

## テストの自動化 {#test-automation}

私たちはテストを [GitHub Actions](https://github.com/features/actions) で実行します。

ビルドジョブとテストは、コミットごとにSandboxで実行されます。
生成されたパッケージとテスト結果はGitHubに公開され、直接リンクでダウンロード可能です。
アーティファクトは数ヶ月間保存されます。
GitHubでプルリクエストを送信すると、それを「テスト可能」とタグ付けし、CIシステムがあなたのためにClickHouseパッケージ（リリース、デバッグ、アドレスサニタイザー付きなど）をビルドします。
