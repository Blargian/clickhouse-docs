---
description: 'Позволяет быстро записывать состояния объектов, которые постоянно изменяются, и удалять старые состояния объектов в фоновом режиме.'
sidebar_label: 'VersionedCollapsingMergeTree'
sidebar_position: 80
slug: /engines/table-engines/mergetree-family/versionedcollapsingmergetree
title: 'VersionedCollapsingMergeTree'
---


# VersionedCollapsingMergeTree

Этот движок:

- Позволяет быстро записывать состояния объектов, которые постоянно изменяются.
- Удаляет старые состояния объектов в фоновом режиме. Это значительно снижает объём хранилища.

Смотрите раздел [Collapsing](#table_engines_versionedcollapsingmergetree) для получения подробной информации.

Движок наследует от [MergeTree](/engines/table-engines/mergetree-family/versionedcollapsingmergetree) и добавляет логику коллапса строк к алгоритму слияния частей данных. `VersionedCollapsingMergeTree` выполняет ту же функцию, что и [CollapsingMergeTree](../../../engines/table-engines/mergetree-family/collapsingmergetree.md), но использует другой алгоритм коллапса, который позволяет вставлять данные в любом порядке с использованием нескольких потоков. В частности, колонка `Version` помогает корректно коллапсировать строки, даже если они были вставлены в неправильном порядке. В отличие от этого, `CollapsingMergeTree` допускает только строго последовательную вставку.

## Создание таблицы {#creating-a-table}

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE = VersionedCollapsingMergeTree(sign, version)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

Для описания параметров запроса см. [описание запроса](../../../sql-reference/statements/create/table.md).

### Параметры движка {#engine-parameters}

```sql
VersionedCollapsingMergeTree(sign, version)
```

| Параметр  | Описание                                                                           | Тип                                                                                                                                                                                                                                                                                    |
|-----------|------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sign`    | Имя колонки с типом строки: `1` — это строка "состояния", `-1` — строка "отмены".  | [`Int8`](/sql-reference/data-types/int-uint)                                                                                                                                                                                                                                    |
| `version` | Имя колонки с версией состояния объекта.                                           | [`Int*`](/sql-reference/data-types/int-uint), [`UInt*`](/sql-reference/data-types/int-uint), [`Date`](/sql-reference/data-types/date), [`Date32`](/sql-reference/data-types/date32), [`DateTime`](/sql-reference/data-types/datetime) или [`DateTime64`](/sql-reference/data-types/datetime64) |

### Условия запроса {#query-clauses}

При создании таблицы `VersionedCollapsingMergeTree` требуются те же [условия](../../../engines/table-engines/mergetree-family/mergetree.md), что и при создании таблицы `MergeTree`.

<details markdown="1">

<summary>Устаревший метод создания таблицы</summary>

:::note
Не используйте этот метод в новых проектах. Если возможно, переключите старые проекты на метод, описанный выше.
:::

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE [=] VersionedCollapsingMergeTree(date-column [, samp#table_engines_versionedcollapsingmergetreeling_expression], (primary, key), index_granularity, sign, version)
```

Все параметры, кроме `sign` и `version`, имеют то же значение, что и в `MergeTree`.

- `sign` — Имя колонки с типом строки: `1` — это строка "состояния", `-1` — строка "отмены".

    Тип данных колонки — `Int8`.

- `version` — Имя колонки с версией состояния объекта.

    Тип данных колонки должен быть `UInt*`.

</details>

## Коллапсирование {#table_engines_versionedcollapsingmergetree}

### Данные {#data}

Рассмотрим ситуацию, когда вам нужно сохранить постоянно изменяющиеся данные для какого-либо объекта. Разумно иметь одну строку для объекта и обновлять строку всякий раз, когда происходят изменения. Однако операция обновления дорогостоящая и медленная для СУБД, так как требует переписывания данных в хранилище. Обновление неприемлемо, если вам нужно быстро записывать данные, но вы можете записывать изменения для объекта последовательно следующим образом.

Используйте колонку `Sign` при записи строки. Если `Sign = 1`, это означает, что строка является состоянием объекта (назовем её "строкой состояния"). Если `Sign = -1`, это указывает на отмену состояния объекта с теми же атрибутами (назовем её "строкой отмены"). Также используйте колонку `Version`, которая должна идентифицировать каждое состояние объекта отдельным номером.

Например, мы хотим подсчитать, сколько страниц пользователи посетили на каком-либо сайте и как долго они там находились. В какой-то момент времени мы записываем следующую строку с состоянием активности пользователя:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Позже мы регистрируем изменение активности пользователя и записываем это с помощью следующих двух строк.

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Первая строка отменяет предыдущее состояние объекта (пользователя). Она должна копировать все поля отмененного состояния, кроме `Sign`.

Вторая строка содержит текущее состояние.

Поскольку нам нужно только последнее состояние активности пользователя, строки

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

могут быть удалены, коллапсируя недопустимое (старое) состояние объекта. `VersionedCollapsingMergeTree` делает это во время слияния частей данных.

Чтобы узнать, почему нам нужны две строки для каждого изменения, смотрите [Алгоритм](#table_engines-versionedcollapsingmergetree-algorithm).

**Примечания по использованию**

1. Программа, которая записывает данные, должна помнить состояние объекта, чтобы иметь возможность его отменить. Строка "отмена" должна содержать копии полей первичного ключа и версию строки "состояния" с противоположным `Sign`. Это увеличивает первоначальный объём хранилища, но позволяет быстро записывать данные.
2. Длинные растущие массивы в колонках снижают эффективность движка из-за нагрузки за счёт записи. Чем проще данные, тем лучше эффективность.
3. Результаты `SELECT` сильно зависят от согласованности истории изменений объекта. Будьте внимательны при подготовке данных для вставки. Вы можете получить непредсказуемые результаты с несогласованными данными, например, отрицательные значения для неотрицательных метрик, таких как глубина сессии.

### Алгоритм {#table_engines-versionedcollapsingmergetree-algorithm}

Когда ClickHouse сливает части данных, он удаляет каждую пару строк, имеющих одинаковый первичный ключ и версию, и разные `Sign`. Порядок строк не имеет значения.

Когда ClickHouse вставляет данные, он упорядочивает строки по первичному ключу. Если колонка `Version` отсутствует в первичном ключе, ClickHouse добавляет её в первичный ключ неявно как последнее поле и использует её для упорядочивания.

## Выбор данных {#selecting-data}

ClickHouse не гарантирует, что все строки с одинаковым первичным ключом будут находиться в одной результирующей части данных или даже на одном физическом сервере. Это касается как записи данных, так и последующего слияния частей данных. Кроме того, ClickHouse обрабатывает запросы `SELECT` с помощью нескольких потоков, и он не может предсказать порядок строк в результате. Это означает, что требуется агрегация, если необходимо получить полностью "коллапсированные" данные из таблицы `VersionedCollapsingMergeTree`.

Для завершения коллапса напишите запрос с условием `GROUP BY` и агрегатными функциями, учитывающими знак. Например, для подсчёта количества используйте `sum(Sign)`, а не `count()`. Чтобы подсчитать сумму чего-то, используйте `sum(Sign * x)` вместо `sum(x)`, и добавьте `HAVING sum(Sign) > 0`.

Агрегаты `count`, `sum` и `avg` можно вычислить таким образом. Агрегат `uniq` можно вычислить, если объект имеет как минимум одно неколлапсированное состояние. Агрегаты `min` и `max` не могут быть вычислены, так как `VersionedCollapsingMergeTree` не сохраняет историю значений коллапсированных состояний.

Если вам нужно извлечь данные с "коллапсом", но без агрегации (например, чтобы проверить, существуют ли строки, чьи новейшие значения соответствуют определённым условиям), вы можете использовать модификатор `FINAL` для условия `FROM`. Этот подход неэффективен и не должен использоваться с большими таблицами.

## Пример использования {#example-of-use}

Пример данных:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Создание таблицы:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8,
    Version UInt8
)
ENGINE = VersionedCollapsingMergeTree(Sign, Version)
ORDER BY UserID
```

Вставка данных:

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1, 1)
```

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1, 1),(4324182021466249494, 6, 185, 1, 2)
```

Мы используем два запроса `INSERT` для создания двух разных частей данных. Если бы мы вставили данные с помощью одного запроса, ClickHouse создал бы одну часть данных и никогда не выполнил бы слияние.

Получение данных:

```sql
SELECT * FROM UAct
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 │
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Что мы здесь видим и где коллапсированные части?
Мы создали две части данных с помощью двух запросов `INSERT`. Запрос `SELECT` был выполнен в два потока, и результат — произвольный порядок строк.
Коллапсирование не произошло, потому что части данных ещё не были слиты. ClickHouse сливает части данных в неизвестный момент времени, который мы не можем предсказать.

Вот почему нам нужна агрегация:

```sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration,
    Version
FROM UAct
GROUP BY UserID, Version
HAVING sum(Sign) > 0
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │       2 │
└─────────────────────┴───────────┴──────────┴─────────┘
```

Если мы не нуждаемся в агрегации и хотим принудительно выполнить коллапс, мы можем использовать модификатор `FINAL` для условия `FROM`.

```sql
SELECT * FROM UAct FINAL
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Этот способ выбора данных является очень неэффективным. Не используйте его для больших таблиц.
