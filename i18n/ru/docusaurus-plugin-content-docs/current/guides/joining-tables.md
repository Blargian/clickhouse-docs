---
title: 'Использование JOIN в ClickHouse'
description: 'Как объединять таблицы в ClickHouse'
keywords: ['joins', 'join tables']
slug: /guides/joining-tables
---

import Image from '@theme/IdealImage';
import joins_1 from '@site/static/images/guides/joins-1.png';
import joins_2 from '@site/static/images/guides/joins-2.png';
import joins_3 from '@site/static/images/guides/joins-3.png';
import joins_4 from '@site/static/images/guides/joins-4.png';
import joins_5 from '@site/static/images/guides/joins-5.png';

ClickHouse имеет [полную поддержку `JOIN`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1) с широким набором алгоритмов объединения. Для максимизации производительности мы рекомендуем следовать рекомендациям по оптимизации объединений, перечисленным в этом руководстве.

- Для достижения оптимальной производительности пользователи должны стремиться уменьшить количество `JOIN` в запросах, особенно для аналитических рабочих нагрузок в реальном времени, где требуется работа с миллисекундной производительностью. Стремитесь к максимуму в 3-4 объединения в одном запросе. Мы подробно описываем ряд изменений, чтобы минимизировать объединения в [разделе моделирования данных](/data-modeling/schema-design), включая денормализацию, словари и материализованные представления.
- В настоящее время ClickHouse не меняет порядок объединений. Всегда убедитесь, что самая маленькая таблица находится справа от объединения. Это будет находиться в памяти для большинства алгоритмов объединения и обеспечит наименьшее использование памяти для запроса.
- Если вашему запросу требуется прямое объединение, то есть `LEFT ANY JOIN` — как показано ниже, мы рекомендуем использовать [Словари](/dictionary), где это возможно.

<Image img={joins_1} size="sm" alt="Left any join"/>

- Если вы выполняете внутренние объединения, часто более оптимально записывать их как подзапросы с использованием условия `IN`. Рассмотрим следующие запросы, которые функционально эквивалентны. Оба находят количество `posts`, которые не упоминают ClickHouse в вопросе, но делают это в `comments`.

```sql
SELECT count()
FROM stackoverflow.posts AS p
ANY INNER `JOIN` stackoverflow.comments AS c ON p.Id = c.PostId
WHERE (p.Title != '') AND (p.Title NOT ILIKE '%clickhouse%') AND (p.Body NOT ILIKE '%clickhouse%') AND (c.Text ILIKE '%clickhouse%')

┌─count()─┐
│       86 │
└─────────┘

1 row in set. Elapsed: 8.209 sec. Processed 150.20 million rows, 56.05 GB (18.30 million rows/s., 6.83 GB/s.)
Peak memory usage: 1.23 GiB.
```

Обратите внимание, что мы используем `ANY INNER JOIN` вместо простого `INNER JOIN`, так как не хотим получать декартово произведение, то есть хотим лишь одно соответствие для каждого поста.

Это объединение можно переписать, используя подзапрос, что значительно улучшит производительность:

```sql
SELECT count()
FROM stackoverflow.posts
WHERE (Title != '') AND (Title NOT ILIKE '%clickhouse%') AND (Body NOT ILIKE '%clickhouse%') AND (Id IN (
        SELECT PostId
        FROM stackoverflow.comments
        WHERE Text ILIKE '%clickhouse%'
))
┌─count()─┐
│       86 │
└─────────┘

1 row in set. Elapsed: 2.284 sec. Processed 150.20 million rows, 16.61 GB (65.76 million rows/s., 7.27 GB/s.)
Peak memory usage: 323.52 MiB.
```

Хотя ClickHouse пытается передавать условия во все предложения объединения и подзапросы, мы рекомендуем пользователям всегда вручную применять условия ко всем подзапросам, где это возможно, минимизируя таким образом размер данных, которые нужно `JOIN`. Рассмотрим следующий пример, где мы хотим вычислить количество положительных голосов за посты, связанные с Java, начиная с 2020 года.

Наивный запрос, с более крупной таблицей слева, завершается за 56 секунд:

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.posts AS p
INNER JOIN stackoverflow.votes AS v ON p.Id = v.PostId
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 56.642 sec. Processed 252.30 million rows, 1.62 GB (4.45 million rows/s., 28.60 MB/s.)
```

Изменение порядка этого объединения значительно улучшает производительность до 1.5 секунд:

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.votes AS v
INNER JOIN stackoverflow.posts AS p ON v.PostId = p.Id
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 1.519 sec. Processed 252.30 million rows, 1.62 GB (166.06 million rows/s., 1.07 GB/s.)
```

Добавление фильтра к таблице справа еще больше улучшает производительность до 0.5 секунд.

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.votes AS v
INNER JOIN stackoverflow.posts AS p ON v.PostId = p.Id
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01') AND (v.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 0.597 sec. Processed 81.14 million rows, 1.31 GB (135.82 million rows/s., 2.19 GB/s.)
Peak memory usage: 249.42 MiB.
```

Этот запрос можно улучшить еще больше, переместив `INNER JOIN` в подзапрос, как отмечалось ранее, сохраняя фильтр как в внешнем, так и во внутренних запросах.

```sql
SELECT count() AS upvotes
FROM stackoverflow.votes
WHERE (VoteTypeId = 2) AND (PostId IN (
        SELECT Id
        FROM stackoverflow.posts
        WHERE (CreationDate >= '2020-01-01') AND has(arrayFilter(t -> (t != ''), splitByChar('|', Tags)), 'java')
))

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 0.383 sec. Processed 99.64 million rows, 804.55 MB (259.85 million rows/s., 2.10 GB/s.)
Peak memory usage: 250.66 MiB.
```

## Выбор алгоритма объединения {#choosing-a-join-algorithm}

ClickHouse поддерживает несколько [алгоритмов объединения](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1). Эти алгоритмы обычно жертвуют использованием памяти ради производительности. Ниже представлено общее описание алгоритмов объединения ClickHouse на основе их относительного потребления памяти и времени выполнения:

<br />

<Image img={joins_2} size="lg" alt="speed by memory for joins"/>

<br />

Эти алгоритмы определяют способ, которым планируется и выполняется запрос для объединения. По умолчанию ClickHouse использует прямой или хеш-алгоритм для объединения в зависимости от используемого типа объединения, строгости и движка объединяемых таблиц. В качестве альтернативы ClickHouse может быть настроен на адаптивный выбор и динамическое изменение алгоритма объединения во время выполнения, в зависимости от доступности и использования ресурсов: Когда `join_algorithm=auto`, ClickHouse сначала пробует хеш-алгоритм, и если лимит памяти этого алгоритма нарушается, алгоритм переключается в процессе выполнения на частичное слияние. Вы можете наблюдать, какой алгоритм был выбран, через трассировку логирования. ClickHouse также позволяет пользователям самостоятельно указывать желаемый алгоритм объединения с помощью настройки `join_algorithm`.

Поддерживаемые типы `JOIN` для каждого алгоритма объединения показаны ниже и должны быть учтены перед оптимизацией:

<br />

<Image img={joins_3} size="lg" alt="join features"/>

<br />

Подробное описание каждого алгоритма `JOIN` можно найти [здесь](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2), включая их плюсы, минусы и свойства масштабирования.

Выбор подходящих алгоритмов объединения зависит от того, хотите ли вы оптимизировать использование памяти или производительность.

## Оптимизация производительности JOIN {#optimizing-join-performance}

Если вашим ключевым показателем оптимизации является производительность, и вы хотите выполнить объединение как можно быстрее, вы можете использовать следующее дерево решений для выбора правильного алгоритма объединения:

<br />

<Image img={joins_4} size="lg" alt="join flowchart"/>

<br />

- **(1)** Если данные из правой таблицы могут быть предварительно загружены в структуру данных ключ-значение в памяти с низкой задержкой, например, в словарь, и если ключ объединения соответствует атрибуту ключа подлежащего хранилища ключ-значение, и если семантика `LEFT ANY JOIN` подходящая, то применяется **прямое объединение** и предлагает самый быстрый подход.

- **(2)** Если физический порядок строк вашей таблицы [соответствует](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order) порядку сортировки ключа объединения, тогда это зависит. В этом случае **полное сортировочное слияние** [пропускает](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order) фазу сортировки, что приводит к значительно уменьшенному потреблению памяти, плюс, в зависимости от объема данных и распределения значений ключа объединения, более быстрые времена выполнения, чем некоторые алгоритмы хеширования.

- **(3)** Если правая таблица помещается в память, даже с [дополнительными затратами на использование памяти](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#summary) **параллельного хеш-объединения**, тогда этот алгоритм или хеш-объединение может быть быстрее. Это зависит от объема данных, типов данных и распределения значений столбцов ключа объединения.

- **(4)** Если правая таблица не помещается в память, то это опять зависит. ClickHouse предлагает три алгоритма объединения, не привязанные к памяти. Все три временно выполняют выгрузку данных на диск. **Полное сортировочное слияние** и **частичное слияние** требуют предварительной сортировки данных. **Grace hash join** строит хеш-таблицы на основе данных вместо этого. В зависимости от объема данных, типов данных и распределения значений столбцов ключа объединения могут быть сценарии, когда создание хеш-таблиц из данных быстрее, чем сортировка данных. И наоборот.

Частичное слияние оптимизировано для минимизации использования памяти при объединении больших таблиц, за счет скорости объединения, которая довольно медленная. Это особенно актуально, когда физический порядок строк левой таблицы не соответствует порядку сортировки ключа объединения.

Grace hash join является самым универсальным из трех алгоритмов объединения, не привязанных к памяти, и предлагает хороший контроль использования памяти по сравнению со скоростью объединения с настройкой [grace_hash_join_initial_buckets](https://github.com/ClickHouse/ClickHouse/blob/23.5/src/Core/Settings.h#L759). В зависимости от объема данных grace hash может быть быстрее или медленнее, чем частичное слияние, когда количество [ведер](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#description-2) выбрано так, чтобы использование памяти обоих алгоритмов было примерно одинаковым. Когда использование памяти grace hash join настроено так, чтобы оно примерно совпадало с использованием памяти полного сортировочного слияния, тогда полное сортировочное слияние всегда было быстрее в наших тестах.

Какой из трех алгоритмов, не привязанных к памяти, является самым быстрым, зависит от объема данных, типов данных и распределения значений столбцов ключа объединения. Всегда лучше провести несколько бенчмарков с реальными объемами данных, чтобы определить, какой алгоритм является самым быстрым.

## Оптимизация для использования памяти {#optimizing-for-memory}

Если вы хотите оптимизировать объединение для минимального использования памяти вместо самой быстрой вероятной скорости выполнения, тогда вы можете использовать это дерево решений:

<br />

<Image img={joins_5} size="lg" alt="Join memory optimization decision tree" />

<br />

- **(1)** Если физический порядок строк вашей таблицы соответствует порядку сортировки ключа объединения, тогда использование памяти **полного сортировочного слияния** минимально. С дополнительным преимуществом хорошей скорости объединения, так как фаза сортировки [отключена](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order).
- **(2)** **Grace hash join** может быть настроен для очень низкого использования памяти, путем [конфигурации](https://github.com/ClickHouse/ClickHouse/blob/23.5/src/Core/Settings.h#L759) большого числа [ведер](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#description-2) за счет скорости объединения. **Частичное слияние** намеренно использует мало основной памяти. **Полное сортировочное слияние** с включенной внешней сортировкой обычно использует больше памяти, чем частичное слияние (при условии, что порядок строк не соответствует порядку сортировки ключа), с преимуществом значительно лучшего времени выполнения объединения.

Для пользователей, которым нужны более подробные сведения по вышеупомянутому, мы рекомендуем следующую [серии блогов](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1).
