---
description: 'Рекомендации по стилю кодирования для разработки на C++ в ClickHouse'
sidebar_label: 'C++ Рекомендации по стилю'
sidebar_position: 70
slug: /development/style
title: 'C++ Рекомендации по стилю'
---


# C++ Рекомендации по стилю

## Общие рекомендации {#general-recommendations}

Следующие рекомендации не являются обязательными.
Если вы редактируете код, имеет смысл следовать форматированию существующего кода.
Стиль кода необходим для согласованности. Согласованность облегчает чтение кода, а также упрощает поиск кода.
Многие из правил не имеют логических обоснований; они продиктованы установленными практиками.

## Форматирование {#formatting}

**1.** Большая часть форматирования выполняется автоматически с помощью `clang-format`.

**2.** Ширина отступа составляет 4 пробела. Настройте вашу среду разработки так, чтобы табуляция добавляла четыре пробела.

**3.** Открывающая и закрывающая фигурные скобки должны быть на отдельной строке.

```cpp
inline void readBoolText(bool & x, ReadBuffer & buf)
{
    char tmp = '0';
    readChar(tmp, buf);
    x = tmp != '0';
}
```

**4.** Если весь код функции состоит из одного `оператора`, его можно разместить в одной строке. Разместите пробелы вокруг фигурных скобок (помимо пробела в конце строки).

```cpp
inline size_t mask() const                { return buf_size() - 1; }
inline size_t place(HashValue x) const    { return x & mask(); }
```

**5.** Для функций. Не ставьте пробелов вокруг скобок.

```cpp
void reinsert(const Value & x)
```

```cpp
memcpy(&buf[place_value], &x, sizeof(x));
```

**6.** В выражениях `if`, `for`, `while` и других, перед открывающей скобкой должен быть пробел (в отличие от вызовов функций).

```cpp
for (size_t i = 0; i < rows; i += storage.index_granularity)
```

**7.** Добавьте пробелы вокруг бинарных операторов (`+`, `-`, `*`, `/`, `%`, ...) и тернарного оператора `?:`.

```cpp
UInt16 year = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
UInt8 month = (s[5] - '0') * 10 + (s[6] - '0');
UInt8 day = (s[8] - '0') * 10 + (s[9] - '0');
```

**8.** Если введен перенос строки, перенесите оператор на новую строку и увеличьте отступ перед ним.

```cpp
if (elapsed_ns)
    message << " ("
        << rows_read_on_server * 1000000000 / elapsed_ns << " rows/s., "
        << bytes_read_on_server * 1000.0 / elapsed_ns << " MB/s.) ";
```

**9.** Вы можете использовать пробелы для выравнивания внутри строки, если это необходимо.

```cpp
dst.ClickLogID         = click.LogID;
dst.ClickEventID       = click.EventID;
dst.ClickGoodEvent     = click.GoodEvent;
```

**10.** Не используйте пробелы вокруг операторов `.`, `->`.

При необходимости оператор может быть перенесен на следующую строку. В этом случае увеличивается отступ перед ним.

**11.** Не ставьте пробел для разделения унарных операторов (`--`, `++`, `*`, `&`, ...) и аргумента.

**12.** Ставьте пробел после запятой, но не перед ней. То же правило применяется для точки с запятой внутри выражения `for`.

**13.** Не используйте пробелы для разделения оператора `[]`.

**14.** В выражении `template <...>` ставьте пробел между `template` и `<`; не ставьте пробелов после `<` или перед `>`.

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
{}
```

**15.** В классах и структурах пишите `public`, `private` и `protected` на том же уровне, что и `class/struct`, и отступайте остальной код.

```cpp
template <typename T>
class MultiVersion
{
public:
    /// Версия объекта для использования. shared_ptr управляет временем жизни версии.
    using Version = std::shared_ptr<const T>;
    ...
}
```

**16.** Если одно и то же `namespace` используется для всего файла, и в нем нет ничего другого значительного, отступ внутри `namespace` не требуется.

**17.** Если блок для `if`, `for`, `while` или другого выражения состоит из одного `оператора`, фигурные скобки необязательны. Разместите `оператор` на отдельной строке. Это правило также актуально для вложенных `if`, `for`, `while` ...

Но если внутренний `оператор` содержит фигурные скобки или `else`, внешний блок должен быть записан в фигурных скобках.

```cpp
/// Завершить запись.
for (auto & stream : streams)
    stream.second->finalize();
```

**18.** В конце строк не должно быть пробелов.

**19.** Исходные файлы кодируются в UTF-8.

**20.** Не-ASCII символы могут использоваться в строковых литералах.

```cpp
<< ", " << (timer.elapsed() / chunks_stats.hits) << " μsec/hit.";
```

**21.** Не пишите несколько выражений в одной строке.

**22.** Группируйте секции кода внутри функций и разделяйте их не более чем одной пустой строкой.

**23.** Разделяйте функции, классы и так далее одной или двумя пустыми строками.

**24.** `A const` (относящийся к значению) должен быть написан перед именем типа.

```cpp
//верно
const char * pos
const std::string & s
//неверно
char const * pos
```

**25.** При объявлении указателя или ссылки символы `*` и `&` должны быть разделены пробелами с обеих сторон.

```cpp
//верно
const char * pos
//неверно
const char* pos
const char *pos
```

**26.** При использовании типов шаблонов используйте их с ключевым словом `using` (за исключением самых простых случаев).

Иными словами, параметры шаблона указываются только в `using` и не повторяются в коде.

`using` можно объявить локально, например, внутри функции.

```cpp
//верно
using FileStreams = std::map<std::string, std::shared_ptr<Stream>>;
FileStreams streams;
//неверно
std::map<std::string, std::shared_ptr<Stream>> streams;
```

**27.** Не объявляйте несколько переменных разных типов в одном операторе.

```cpp
//неверно
int x, *y;
```

**28.** Не используйте приведение типов в стиле C.

```cpp
//неверно
std::cerr << (int)c <<; std::endl;
//верно
std::cerr << static_cast<int>(c) << std::endl;
```

**29.** В классах и структурах группируйте члены и функции отдельно внутри каждой области видимости.

**30.** Для небольших классов и структур нет необходимости разделять объявление метода от реализации.

То же самое касается небольших методов в любых классах или структурах.

Для шаблонных классов и структур не разделяйте объявления методов от реализации (иначе они должны быть определены в одном и том же единичном переводе).

**31.** Вы можете переносить строки на 140 символов вместо 80.

**32.** Всегда используйте префиксные инкременты/декременты, если постфикс не требуется.

```cpp
for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)
```

## Комментарии {#comments}

**1.** Обязательно добавляйте комментарии ко всем нетривиальным частям кода.

Это очень важно. Написание комментария может помочь вам осознать, что код не нужен, или что он спроектирован неправильно.

```cpp
/** Часть выделенной памяти, которая может быть использована.
  * Например, если internal_buffer составляет 1 МБ, и в буфер было загружено только 10 байтов из файла для чтения,
  * то working_buffer будет иметь размер только 10 байт
  * (working_buffer.end() будет указывать на позицию сразу после тех 10 байтов, доступных для чтения).
  */
```

**2.** Комментарии могут быть столь подробными, как это необходимо.

**3.** Помещайте комментарии перед кодом, который они описывают. В редких случаях комментарии могут идти после кода, на той же строке.

```cpp
/** Парсит и выполняет запрос.
*/
void executeQuery(
    ReadBuffer & istr, /// Откуда читать запрос (и данные для INSERT, если применимо)
    WriteBuffer & ostr, /// Куда записывать результат
    Context & context, /// БД, таблицы, типы данных, движки, функции, агрегатные функции...
    BlockInputStreamPtr & query_plan, /// Здесь можно записать описание того, как выполнялся запрос
    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// До какого этапа обрабатывать запрос SELECT
    )
```

**4.** Комментарии должны быть написаны только на английском.

**5.** Если вы пишете библиотеку, включите подробные комментарии, объясняющие ее в основном заголовочном файле.

**6.** Не добавляйте комментарии, которые не предоставляют дополнительной информации. В частности, не оставляйте пустых комментариев, таких как:

```cpp
/*
* Имя процедуры:
* Исходное имя процедуры:
* Автор:
* Дата создания:
* Даты модификации:
* Авторы модификаций:
* Исходное имя файла:
* Цель:
* Намерение:
* Обозначение:
* Используемые классы:
* Константы:
* Локальные переменные:
* Параметры:
* Дата создания:
* Цель:
*/
```

Данный пример заимствован из ресурса http://home.tamk.fi/~jaalto/course/coding-style/doc/unmaintainable-code/.

**7.** Не пишите ненужные комментарии (автор, дата создания и т.д.) в начале каждого файла.

**8.** Однострочные комментарии начинаются с трех косых черт: `///`, а многострочные комментарии начинаются с `/**`. Эти комментарии считаются "документацией".

Примечание: вы можете использовать Doxygen для генерации документации из этих комментариев. Однако Doxygen обычно не используется, поскольку удобнее ориентироваться в коде в IDE.

**9.** Многострочные комментарии не должны содержать пустых строк в начале и конце (за исключением строки, закрывающей многострочный комментарий).

**10.** Для закомментирования кода используйте обычные комментарии, а не "документирующие" комментарии.

**11.** Удаляйте закомментированные части кода перед коммитом.

**12.** Не используйте нецензурные слова в комментариях или коде.

**13.** Не используйте заглавные буквы. Не используйте чрезмерную пунктуацию.

```cpp
/// ЧТО ЗА ФИАЛ???
```

**14.** Не используйте комментарии для обозначения разделителей.

```cpp
///******************************************************
```

**15.** Не начинайте обсуждения в комментариях.

```cpp
/// Почему вы сделали это?
```

**16.** Не нужно писать комментарий в конце блока, описывающий, о чем он был.

```cpp
/// для
```

## Имена {#names}

**1.** Используйте строчные буквы с подчеркиваниями в именах переменных и членов классов.

```cpp
size_t max_block_size;
```

**2.** Для имен функций (методов) используйте camelCase, начиная с маленькой буквы.

```cpp
std::string getName() const override { return "Memory"; }
```

**3.** Для имен классов (структур) используйте CamelCase, начиная с заглавной буквы. Префиксы, кроме I, не используются для интерфейсов.

```cpp
class StorageMemory : public IStorage
```

**4.** `using` называют так же, как классы.

**5.** Имена параметров шаблонов: в простых случаях используйте `T`; `T`, `U`; `T1`, `T2`.

Для более сложных случаев следуйте правилам имен классов или добавляйте префикс `T`.

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
```

**6.** Имена аргументов константы для шаблонов: следуйте правилам имен переменных или используйте `N` в простых случаях.

```cpp
template <bool without_www>
struct ExtractDomain
```

**7.** Для абстрактных классов (интерфейсов) можно добавить префикс `I`.

```cpp
class IProcessor
```

**8.** Если вы используете переменную локально, вы можете использовать короткое имя.

В остальных случаях используйте имя, описывающее его значение.

```cpp
bool info_successfully_loaded = false;
```

**9.** Имена `define` и глобальных констант пишутся ЗАГЛАВНЫМИ БУКВАМИ с подчеркиваниями.

```cpp
#define MAX_SRC_TABLE_NAMES_TO_STORE 1000
```

**10.** Имена файлов должны использовать тот же стиль, что и их содержимое.

Если файл содержит один класс, назовите файл так же, как класс (CamelCase).

Если файл содержит одну функцию, назовите файл так же, как функция (camelCase).

**11.** Если имя содержит аббревиатуру, тогда:

- Для имен переменных аббревиатура должна использовать строчные буквы `mysql_connection` (не `mySQL_connection`).
- Для имен классов и функций сохраняйте заглавные буквы в аббревиатуре `MySQLConnection` (не `MySqlConnection`).

**12.** Аргументы конструктора, которые используются только для инициализации членов класса, должны называться так же, как члены класса, но с подчеркиванием в конце.

```cpp
FileQueueProcessor(
    const std::string & path_,
    const std::string & prefix_,
    std::shared_ptr<FileHandler> handler_)
    : path(path_),
    prefix(prefix_),
    handler(handler_),
    log(&Logger::get("FileQueueProcessor"))
{
}
```

Суффикс подчеркивания может быть опущен, если аргумент не используется в теле конструктора.

**13.** Нет различия между именами локальных переменных и членами класса (префиксы не требуются).

```cpp
timer (не m_timer)
```

**14.** Для констант в `enum` используйте CamelCase с заглавной буквой. ЗАГЛАВНЫЕ БУКВЫ также допустимы. Если `enum` не локальный, используйте `enum class`.

```cpp
enum class CompressionMethod
{
    QuickLZ = 0,
    LZ4     = 1,
};
```

**15.** Все имена должны быть на английском. Транслитерация ивритских слов не допускается.

    not T_PAAMAYIM_NEKUDOTAYIM

**16.** Аббревиатуры допустимы, если они хорошо известны (когда вы легко можете найти значение аббревиатуры на Википедии или в поисковой системе).

    `AST`, `SQL`.

    Не `NVDH` (какие-то случайные буквы)

Неполные слова допустимы, если сокращенная версия является общепринятой.

Вы также можете использовать аббревиатуру, если полное название указано рядом с ней в комментариях.

**17.** Имена файлов с исходным кодом C++ должны иметь расширение `.cpp`. Заголовочные файлы должны иметь расширение `.h`.

## Как писать код {#how-to-write-code}

**1.** Управление памятью.

Ручное освобождение памяти (`delete`) может использоваться только в библиотечном коде.

В библиотечном коде оператор `delete` может использоваться только в деструкторах.

В прикладном коде память должна освобождаться объектом, который ее владеет.

Примеры:

- Самый простой способ – поместить объект в стек или сделать его членом другого класса.
- Для большого количества небольших объектов используйте контейнеры.
- Для автоматического освобождения небольшого количества объектов, находящихся в куче, используйте `shared_ptr/unique_ptr`.

**2.** Управление ресурсами.

Используйте `RAII` и смотрите выше.

**3.** Обработка ошибок.

Используйте исключения. В большинстве случаев вам нужно только выбросить исключение и не нужно его обрабатывать (из-за `RAII`).

В приложениях для офлайн-обработки данных часто приемлемо не обрабатывать исключения.

На серверах, обрабатывающих пользовательские запросы, обычно достаточно обрабатывать исключения на верхнем уровне обработчика подключения.

В функциях потоков вы должны поймать и сохранить все исключения, чтобы повторно бросить их в основном потоке после `join`.

```cpp
/// Если расчетов еще не было, рассчитайте первый блок синхронно
if (!started)
{
    calculate();
    started = true;
}
else /// Если расчеты уже ведутся, ждите результат
    pool.wait();

if (exception)
    exception->rethrow();
```

Никогда не прячьте исключения без обработки. Никогда просто слепо не записывайте все исключения в журнал.

```cpp
//Неправильно
catch (...) {}
```

Если вам нужно игнорировать некоторые исключения, делайте это только для определенных и повторно бросайте остальные.

```cpp
catch (const DB::Exception & e)
{
    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)
        return nullptr;
    else
        throw;
}
```

При использовании функций с кодами ответов или `errno` всегда проверяйте результат и выбрасывайте исключение в случае ошибки.

```cpp
if (0 != close(fd))
    throw ErrnoException(ErrorCodes::CANNOT_CLOSE_FILE, "Cannot close file {}", file_name);
```

Вы можете использовать assert для проверки инварианта в коде.

**4.** Типы исключений.

Нет необходимости использовать сложную иерархию исключений в прикладном коде. Текст исключения должен быть понятен системному администратору.

**5.** Выбрасывание исключений из деструкторов.

Это не рекомендуется, но допускается.

Используйте следующие варианты:

- Создайте функцию (`done()` или `finalize()`), которая выполнит всю работу заранее, которая может привести к исключению. Если эта функция была вызвана, затем никаких исключений в деструкторе быть не должно.
- Сложные задачи (например, отправка сообщений по сети) можно поместить в отдельный метод, который пользователь класса должен будет вызвать перед разрушением.
- Если в деструкторе возникло исключение, лучше его зарегистрировать, чем скрыть (если логгер доступен).
- В простых приложениях приемлемо полагаться на `std::terminate` (для случаев `noexcept` по умолчанию в C++11) для обработки исключений.

**6.** Анонимные блоки кода.

Вы можете создать отдельный блок кода внутри одной функции, чтобы сделать определенные переменные локальными, так что деструкторы будут вызываться при выходе из блока.

```cpp
Block block = data.in->read();

{
    std::lock_guard<std::mutex> lock(mutex);
    data.ready = true;
    data.block = block;
}

ready_any.set();
```

**7.** Многопоточность.

В офлайн-программах для обработки данных:

- Пытайтесь достигнуть максимально возможной производительности на одном ядре CPU. Затем вы можете распараллелить свой код, если это необходимо.

В серверных приложениях:

- Используйте пул потоков для обработки запросов. На данный момент у нас не было задач, которые требовали бы переключения контекста пользовательского пространства.

Fork не используется для параллелизации.

**8.** Синхронизация потоков.

Часто можно сделать так, чтобы разные потоки использовали разные ячейки памяти (что еще лучше: разные кэш-линии) и не использовали никакую синхронизацию потоков (кроме `joinAll`).

Если синхронизация необходима, в большинстве случаев достаточно использовать мьютекс под `lock_guard`.

В других случаях используйте системные примитивы синхронизации. Не используйте busy wait.

Атомарные операции должны использоваться только в самых простых случаях.

Не пытайтесь реализовать структуры данных без блокировок, если это не ваша основная область экспертизы.

**9.** Указатели против ссылок.

В большинстве случаев предпочтительней ссылки.

**10.** `const`.

Используйте постоянные ссылки, указатели на константы, `const_iterator` и `const` методы.

Считайте `const` значением по умолчанию и используйте не-`const` только когда это необходимо.

При передаче переменных по значению использование `const` обычно не имеет смысла.

**11.** unsigned.

Используйте `unsigned`, если необходимо.

**12.** Числовые типы.

Используйте типы `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32` и `Int64`, а также `size_t`, `ssize_t` и `ptrdiff_t`.

Не используйте эти типы для чисел: `signed/unsigned long`, `long long`, `short`, `signed/unsigned char`, `char`.

**13.** Передача аргументов.

Передавайте сложные значения по значению, если собираетесь их перемещать и используйте std::move; передавайте по ссылке, если хотите обновить значение в цикле.

Если функция захватывает владение объектом, созданным в куче, сделайте тип аргумента `shared_ptr` или `unique_ptr`.

**14.** Возврат значений.

В большинстве случаев просто используйте `return`. Не пишите `return std::move(res)`.

Если функция выделяет объект в куче и возвращает его, используйте `shared_ptr` или `unique_ptr`.

В редких случаях (обновление значения в цикле) вам может понадобиться вернуть значение через аргумент. В этом случае аргумент должен быть ссылкой.

```cpp
using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;

/** Позволяет создать агрегатную функцию по ее имени.
  */
class AggregateFunctionFactory
{
public:
    AggregateFunctionFactory();
    AggregateFunctionPtr get(const String & name, const DataTypes & argument_types) const;
```

**15.** `namespace`.

Нет необходимости использовать отдельный `namespace` для прикладного кода.

Небольшим библиотекам это также не нужно.

Для средних и больших библиотек поместите все в `namespace`.

В заголовочном файле библиотеки вы можете использовать `namespace detail`, чтобы скрыть детали реализации, не нужные для прикладного кода.

В файле `.cpp` вы можете использовать `static` или анонимный `namespace` для сокрытия символов.

Также `namespace` можно использовать для `enum`, чтобы предотвратить попадание соответствующих имен во внешний `namespace` (но лучше использовать `enum class`).

**16.** Отложенная инициализация.

Если аргументы необходимы для инициализации, тогда вам обычно не следует писать конструктор по умолчанию.

Если в дальнейшем вам потребуется отложить инициализацию, вы можете добавить конструктор по умолчанию, который создаст недопустимый объект. Или, для небольшого количества объектов, вы можете использовать `shared_ptr/unique_ptr`.

```cpp
Loader(DB::Connection * connection_, const std::string & query, size_t max_block_size_);

/// Для отложенной инициализации
Loader() {}
```

**17.** Виртуальные функции.

Если класс не предназначен для полиморфного использования, вам не нужно делать функции виртуальными. Это также относится к деструктору.

**18.** Кодировки.

Используйте UTF-8 повсюду. Используйте `std::string` и `char *`. Не используйте `std::wstring` и `wchar_t`.

**19.** Логирование.

Смотрите примеры повсюду в коде.

Перед коммитом удалите все бесполезные и отладочные сообщения, а также любые другие типы отладочного вывода.

Логирование в циклах следует избегать, даже на уровне Trace.

Логи должны быть читаемыми на любом уровне логирования.

Логирование должно использоваться главным образом в прикладном коде.

Сообщения журналов должны быть написаны на английском.

Журнал должен быть желательно понятен для системного администратора.

Не используйте нецензурные слова в журнале.

Используйте кодировку UTF-8 в журнале. В редких случаях вы можете использовать не-ASCII символы в журнале.

**20.** Ввод-вывод.

Не используйте `iostreams` в внутренних циклах, которые критичны для производительности приложения (и никогда не используйте `stringstream`).

Вместо этого используйте библиотеку `DB/IO`.

**21.** Дата и время.

Смотрите библиотеку `DateLUT`.

**22.** include.

Всегда используйте `#pragma once` вместо охранников включения.

**23.** using.

`using namespace` не используется. Вы можете использовать `using` с чем-то конкретным. Но делайте это локально внутри класса или функции.

**24.** Не используйте `trailing return type` для функций, если это не необходимо.

```cpp
auto f() -> void
```

**25.** Объявление и инициализация переменных.

```cpp
//правильный способ
std::string s = "Hello";
std::string s{"Hello"};

//неправильный способ
auto s = std::string{"Hello"};
```

**26.** Для виртуальных функций пишите `virtual` в базовом классе, но вместо `virtual` пишите `override` в дочерних классах.

## Неиспользуемые возможности C++ {#unused-features-of-c}

**1.** Виртуальное наследование не используется.

**2.** Конструкции, которые имеют удобный синтаксический сахар в современном C++, например:

```cpp
// Традиционный способ без синтаксического сахара
template <typename G, typename = std::enable_if_t<std::is_same<G, F>::value, void>> // SFINAE через std::enable_if, использование ::value
std::pair<int, int> func(const E<G> & e) // явно указанный возвращаемый тип
{
    if (elements.count(e)) // .count() тест членства
    {
        // ...
    }

    elements.erase(
        std::remove_if(
            elements.begin(), elements.end(),
            [&](const auto x){
                return x == 1;
            }),
        elements.end()); // идиома remove-erase

    return std::make_pair(1, 2); // создать пару через make_pair()
}

// С синтаксическим сахаром (C++14/17/20)
template <typename G>
requires std::same_v<G, F> // SFINAE через концепт C++20, использование шаблонных алиасов C++14
auto func(const E<G> & e) // авто возвращаемого типа (C++14)
{
    if (elements.contains(e)) // C++20 .contains тест членства
    {
        // ...
    }

    elements.erase_if(
        elements,
        [&](const auto x){
            return x == 1;
        }); // C++20 std::erase_if

    return {1, 2}; // или: return std::pair(1, 2); // создать пару через инициализационный список или инициализацию значением (C++17)
}
```

## Платформа {#platform}

**1.** Мы пишем код для конкретной платформы.

Но при прочих равных предпочтение отдается кроссплатформенному или портируемому коду.

**2.** Язык: C++20 (см. список доступных [возможностей C++20](https://en.cppreference.com/w/cpp/compiler_support#C.2B.2B20_features)).

**3.** Компилятор: `clang`. На момент написания (март 2025 года) код компилируется с использованием clang версии >= 19.

Используется стандартная библиотека (`libc++`).

**4.** ОС: Linux Ubuntu, не старше Precise.

**5.** Код написан для архитектуры процессора x86_64.

Набор инструкций процессора является минимально поддерживаемым набором среди наших серверов. В настоящее время это SSE 4.2.

**6.** Используйте флаги компиляции `-Wall -Wextra -Werror -Weverything` с несколькими исключениями.

**7.** Используйте статическую компоновку со всеми библиотеками, кроме тех, которые сложно подключить статически (см. вывод команды `ldd`).

**8.** Код разрабатывается и отлаживается с настройками релиза.

## Инструменты {#tools}

**1.** KDevelop – хорошая IDE.

**2.** Для отладки используйте `gdb`, `valgrind` (`memcheck`), `strace`, `-fsanitize=...` или `tcmalloc_minimal_debug`.

**3.** Для профилирования используйте `Linux Perf`, `valgrind` (`callgrind`) или `strace -cf`.

**4.** Исходники находятся в Git.

**5.** Ассемблер использует `CMake`.

**6.** Программы выпускаются с использованием пакетов `deb`.

**7.** Коммиты в мастер не должны ломать сборку.

Хотя только выбранные ревизии считаются рабочими.

**8.** Делайте коммиты как можно чаще, даже если код готов лишь частично.

Используйте ветки для этой цели.

Если ваш код в ветке `master` еще не компилируется, исключите его из сборки перед `push`. Вам нужно будет завершить его или удалить в течение нескольких дней.

**9.** Для нетривиальных изменений используйте ветки и публикуйте их на сервере.

**10.** Неиспользуемый код удаляется из репозитория.

## Библиотеки {#libraries}

**1.** Используется стандартная библиотека C++20 (экспериментальные расширения допускаются), а также фреймворки `boost` и `Poco`.

**2.** Не разрешается использовать библиотеки из пакетов ОС. Также запрещается использовать предустановленные библиотеки. Все библиотеки должны быть размещены в виде исходного кода в директории `contrib` и собраны вместе с ClickHouse. См. [Руководство по добавлению новых сторонних библиотек](/development/contrib#adding-and-maintaining-third-party-libraries) для подробностей.

**3.** Всегда отдается предпочтение библиотекам, которые уже используются.

## Общие рекомендации {#general-recommendations-1}

**1.** Пишите как можно меньше кода.

**2.** Попробуйте самое простое решение.

**3.** Не пишите код, пока не знаете, как он будет работать и как будет функционировать внутренний цикл.

**4.** В самых простых случаях используйте `using` вместо классов или структур.

**5.** Если возможно, не пишите конструкторы копирования, операторы присваивания, деструкторы (кроме виртуального, если в классе есть хотя бы одна виртуальная функция), конструкторы перемещения или операторы перемещения. Иными словами, функции, сгенерированные компилятором, должны работать корректно. Вы можете использовать `default`.

**6.** Ободряется упрощение кода. Сокращайте размер вашего кода, где это возможно.

## Дополнительные рекомендации {#additional-recommendations}

**1.** Явно указывать `std::` для типов из `stddef.h` не рекомендуется. Другими словами, мы рекомендуем писать `size_t` вместо `std::size_t`, так как это короче.

Приемлемо добавлять `std::`.

**2.** Явно указывать `std::` для функций из стандартной библиотеки C не рекомендуется. Другими словами, пишите `memcpy` вместо `std::memcpy`.

Причина в том, что существуют аналогичные нестандартные функции, такие как `memmem`. Мы иногда используем эти функции. Эти функции не существуют в `namespace std`.

Если вы будете писать `std::memcpy` вместо `memcpy` повсюду, то функция `memmem` без `std::` будет выглядеть странно.

Тем не менее, вы все равно можете использовать `std::`, если предпочитаете это.

**3.** Использование функций из C, когда те же самые доступны в стандартной библиотеке C++.

Это приемлемо, если это более эффективно.

Например, используйте `memcpy` вместо `std::copy` для копирования больших объемов памяти.

**4.** Многострочные аргументы функций.

Любой из следующих стилей обертывания допустим:

```cpp
function(
  T1 x1,
  T2 x2)
```

```cpp
function(
  size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

```cpp
function(size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

```cpp
function(size_t left, size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```

```cpp
function(
      size_t left,
      size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```
