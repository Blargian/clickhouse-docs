---
slug: /cloud/bestpractices/multi-tenancy
sidebar_label: 'Реализация многослойности'
title: 'Многослойность'
description: 'Лучшие практики для реализации многослойности'
---

На платформе SaaS для аналитики данных часто несколько арендаторов, таких как организации, клиенты или бизнес-единицы, используют одну и ту же инфраструктуру базы данных, сохраняя при этом логическое разделение своих данных. Это позволяет различным пользователям безопасно получать доступ к своим данным в рамках одной платформы.

В зависимости от требований существуют разные способы реализации многослойности. Ниже приведено руководство о том, как реализовать это с помощью ClickHouse Cloud.

## Общая таблица  {#shared-table}

В этом подходе данные всех арендаторов хранятся в одной общей таблице, с полем (или набором полей), используемым для идентификации данных каждого арендатора. Для максимизации производительности это поле должно быть включено в [первичный ключ](/sql-reference/statements/create/table#primary-key). Чтобы гарантировать, что пользователи могут получать доступ только к данным, принадлежащим их соответствующим арендаторам, мы используем [контроль доступа на основе ролей](/operations/access-rights), реализованный через [политики строк](/operations/access-rights#row-policy-management).

> **Мы рекомендуем этот подход, так как он является самым простым в управлении, особенно когда все арендаторы используют одну и ту же схему данных, а объемы данных являются умеренными (< ТБ)**

Объединив все данные арендаторов в одну таблицу, мы улучшаем эффективность хранения за счет оптимизированного сжатия данных и уменьшения накладных расходов на метаданные. Кроме того, обновления схемы упрощаются, так как все данные централизованно управляются.

Этот метод особенно эффективен для работы с большим количеством арендаторов (потенциально миллионами).

Однако альтернативные подходы могут быть более подходящими, если у арендаторов разные схемы данных или ожидается, что они будут расходиться со временем.

В случаях, когда существует значительный разрыв в объеме данных между арендаторами, меньшие арендаторы могут испытывать ненужные негативные последствия для производительности запросов. Обратите внимание, что эта проблема в значительной степени устраняется за счет включения поля арендатора в первичный ключ.

### Пример {#shared-table-example}

Это пример реализации модели многослойности с общей таблицей.

Сначала создадим общую таблицу с полем `tenant_id`, включенным в первичный ключ.

```sql
--- Создание таблицы events. Используя tenant_id как часть первичного ключа
CREATE TABLE events
(
    tenant_id UInt32,                 -- Идентификатор арендатора
    id UUID,                    -- Уникальный ID события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (tenant_id, timestamp)
```

Теперь вставим фиктивные данные.

```sql
-- Вставка некоторых фиктивных строк
INSERT INTO events (tenant_id, id, type, timestamp, user_id, data)
VALUES
(1, '7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
(1, '846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
(1, '6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
(2, '7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
(2, '6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
(2, '43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
(1, '83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
(1, '975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}'),
(2, 'f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
(2, '5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}'),
```

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создание пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
```

Мы [создаем политики строк](/sql-reference/statements/create/row-policy), которые ограничивают доступ `user_1` и `user_2` только к данным их арендаторов. 

```sql
-- Создание политик строк
CREATE ROW POLICY user_filter_1 ON default.events USING tenant_id=1 TO user_1
CREATE ROW POLICY user_filter_2 ON default.events USING tenant_id=2 TO user_2
```

Затем [`GRANT SELECT`](/sql-reference/statements/grant#usage) привилегии на общую таблицу, используя общую роль. 

```sql
-- Создать роль
CREATE ROLE user_role

-- Предоставить доступ только для чтения к таблице событий.
GRANT SELECT ON default.events TO user_role
GRANT user_role TO user_1
GRANT user_role TO user_2
```

Теперь вы можете подключиться как `user_1` и выполнить простой запрос. Вернутся только строки от первого арендатора. 

```sql
-- Вход как user_1
SELECT *
FROM events

   ┌─tenant_id─┬─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │         1 │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │         1 │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │         1 │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │         1 │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │         1 │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └───────────┴──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```

## Отдельные таблицы {#separate-tables}

В этом подходе данные каждого арендатора хранятся в отдельной таблице в одной и той же базе данных, что устраняет необходимость в определенном поле для идентификации арендаторов. Доступ пользователей обеспечивается с помощью инструкций [GRANT](/sql-reference/statements/grant), что позволяет каждому пользователю получать доступ только к таблицам, содержащим данные его арендатора.

> **Использование отдельных таблиц является хорошим выбором, когда арендаторы имеют разные схемы данных.**

Для сценариев с несколькими арендаторами с очень большими наборами данных, где производительность запросов критична, этот подход может опередить модель общей таблицы. Поскольку нет необходимости фильтровать данные других арендаторов, запросы могут быть более эффективными. Кроме того, первичные ключи могут быть дополнительно оптимизированы, так как нет необходимости включать дополнительное поле (такое как ID арендатора) в первичный ключ. 

Обратите внимание, что этот подход не масштабируется для тысяч арендаторов. См. [ограничения по использованию](/cloud/bestpractices/usage-limits).

### Пример {#separate-tables-example}

Это пример реализации модели многослойности с отдельными таблицами. 

Сначала создадим две таблицы, одну для событий от `tenant_1` и одну для событий от `tenant_2`.

```sql
-- Создать таблицу для арендатора 1 
CREATE TABLE events_tenant_1
(
    id UUID,                    -- Уникальный ID события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id) -- Первичный ключ может сосредоточиться на других атрибутах

-- Создать таблицу для арендатора 2 
CREATE TABLE events_tenant_2
(
    id UUID,                    -- Уникальный ID события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id) -- Первичный ключ может сосредоточиться на других атрибутах
```

Теперь вставим фиктивные данные.

```sql
INSERT INTO events_tenant_1 (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')

INSERT INTO events_tenant_2 (id, type, timestamp, user_id, data)
VALUES
('7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
('6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
('43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
('f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
('5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}')
```

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создание пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
```

Затем предоставьте `GRANT SELECT` привилегии на соответствующую таблицу.

```sql
-- Предоставить доступ только для чтения к таблице событий.
GRANT SELECT ON default.events_tenant_1 TO user_1
GRANT SELECT ON default.events_tenant_2 TO user_2
```

Теперь вы можете подключиться как `user_1` и выполнить простой запрос из таблицы, соответствующей этому пользователю. Вернутся только строки от первого арендатора. 

```sql
-- Вход как user_1
SELECT *
FROM default.events_tenant_1

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```

## Отдельные базы данных {#separate-databases}

Данные каждого арендатора хранятся в отдельной базе данных в одном и том же сервисе ClickHouse.

> **Этот подход полезен, если каждому арендатору требуется много таблиц и возможно материализованных представлений, и у них разные схемы данных. Однако управлять им может быть сложно, если число арендаторов велико.**

Исполнение аналогично подходу с отдельными таблицами, но вместо предоставления привилегий на уровне таблицы привилегии предоставляются на уровне базы данных.

Обратите внимание, что этот подход не масштабируется для тысяч арендаторов. См. [ограничения по использованию](/cloud/bestpractices/usage-limits).

### Пример {#separate-databases-example}

Это пример реализации модели многослойности с отдельными базами данных. 

Сначала создадим две базы данных, одну для `tenant_1` и одну для `tenant_2`.

```sql
-- Создать базу данных для арендатора_1
CREATE DATABASE tenant_1;

-- Создать базу данных для арендатора_2
CREATE DATABASE tenant_2;
```

```sql
-- Создать таблицу для арендатора_1
CREATE TABLE tenant_1.events
(
    id UUID,                    -- Уникальный ID события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);

-- Создать таблицу для арендатора_2
CREATE TABLE tenant_2.events
(
    id UUID,                    -- Уникальный ID события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);
```

Теперь вставим фиктивные данные.

```sql
INSERT INTO tenant_1.events (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')

INSERT INTO tenant_2.events (id, type, timestamp, user_id, data)
VALUES
('7162f8ea-8bfd-486a-a45e-edfc3398ca93', 'user_login', '2025-03-19 08:12:00', 2001, '{"device": "mobile", "location": "SF"}'),
('6b5f3e55-5add-479e-b89d-762aa017f067', 'purchase', '2025-03-19 08:15:00', 2002, '{"item": "headphones", "amount": 199}'),
('43ad35a1-926c-4543-a133-8672ddd504bf', 'user_logout', '2025-03-19 08:20:00', 2001, '{"device": "mobile", "location": "SF"}'),
('f50aa430-4898-43d0-9d82-41e7397ba9b8', 'purchase', '2025-03-19 08:55:00', 2003, '{"item": "laptop", "amount": 1200}'),
('5c150ceb-b869-4ebb-843d-ab42d3cb5410', 'user_login', '2025-03-19 09:00:00', 2004, '{"device": "mobile", "location": "SF"}')
```

Теперь создадим двух пользователей `user_1` и `user_2`.

```sql
-- Создание пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
CREATE USER user_2 IDENTIFIED BY '<password>'
```

Затем предоставьте `GRANT SELECT` привилегии на соответствующую таблицу.

```sql
-- Предоставить доступ только для чтения к таблице событий.
GRANT SELECT ON tenant_1.events TO user_1
GRANT SELECT ON tenant_2.events TO user_2
```

Теперь вы можете подключиться как `user_1` и выполнить простой запрос к таблице событий соответствующей базы данных. Вернутся только строки от первого арендатора. 

```sql
-- Вход как user_1
SELECT *
FROM tenant_1.events

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```

## Разделение вычислений {#compute-compute-separation}

Три подхода, описанные выше, также могут быть дополнительно изолированы с помощью [Хранилищ](/cloud/reference/warehouses#what-is-a-warehouse). Данные обмениваются через общее объектное хранилище, но каждый арендатор может иметь свою собственную вычислительную службу благодаря [разделению вычислений](/cloud/reference/warehouses#what-is-compute-compute-separation) с различным соотношением CPU/Памяти. 

Управление пользователями аналогично подходам, описанным ранее, так как все сервисы в хранилище [разделяют контроль доступа](/cloud/reference/warehouses#database-credentials). 

Обратите внимание, что количество дочерних служб в одном хранилище ограничено небольшим числом. См. [Ограничения хранилища](/cloud/reference/warehouses#limitations).

## Отдельный облачный сервис {#separate-service}

Самый радикальный подход - использовать отдельный сервис ClickHouse для каждого арендатора. 

> **Этот менее распространенный метод будет решением, если данные арендаторов должны храниться в разных регионах - по юридическим, безопасности или близости.**

Учетная запись пользователя должна быть создана на каждом сервисе, где пользователь может получать доступ к данным своего арендатора.

Этот подход сложнее в управлении и требует дополнительных ресурсов для каждого сервиса, так как каждый из них требует своей инфраструктуры. Управлять сервисами можно через [API ClickHouse Cloud](/cloud/manage/api/api-overview), а также проводить оркестрацию через [официальный провайдер Terraform](https://registry.terraform.io/providers/ClickHouse/clickhouse/latest/docs).

### Пример {#separate-service-example}

Это пример реализации модели многослойности с отдельным сервисом. Обратите внимание, что пример показывает создание таблиц и пользователей на одном сервисе ClickHouse, то же самое будет необходимо воспроизвести на всех сервисах. 

Сначала создадим таблицу `events`

```sql
-- Создание таблицы для арендатора_1
CREATE TABLE events
(
    id UUID,                    -- Уникальный ID события
    type LowCardinality(String), -- Тип события
    timestamp DateTime,          -- Временная метка события
    user_id UInt32,               -- ID пользователя, который инициировал событие
    data String,                 -- Данные события
)
ORDER BY (timestamp, user_id);
```

Теперь вставим фиктивные данные.

```sql
INSERT INTO events (id, type, timestamp, user_id, data)
VALUES
('7b7e0439-99d0-4590-a4f7-1cfea1e192d1', 'user_login', '2025-03-19 08:00:00', 1001, '{"device": "desktop", "location": "LA"}'),
('846aa71f-f631-47b4-8429-ee8af87b4182', 'purchase', '2025-03-19 08:05:00', 1002, '{"item": "phone", "amount": 799}'),
('6b4d12e4-447d-4398-b3fa-1c1e94d71a2f', 'user_logout', '2025-03-19 08:10:00', 1001, '{"device": "desktop", "location": "LA"}'),
('83b5eb72-aba3-4038-bc52-6c08b6423615', 'purchase', '2025-03-19 08:45:00', 1003, '{"item": "monitor", "amount": 450}'),
('975fb0c8-55bd-4df4-843b-34f5cfeed0a9', 'user_login', '2025-03-19 08:50:00', 1004, '{"device": "desktop", "location": "LA"}')
```

Теперь создадим двух пользователей `user_1`

```sql
-- Создание пользователей 
CREATE USER user_1 IDENTIFIED BY '<password>'
```

Затем предоставьте `GRANT SELECT` привилегии на соответствующую таблицу.

```sql
-- Предоставить доступ только для чтения к таблице событий.
GRANT SELECT ON events TO user_1
```

Теперь вы можете подключиться как `user_1` на сервисе для арендатора 1 и выполнить простой запрос. Вернутся только строки от первого арендатора. 

```sql
-- Вход как user_1
SELECT *
FROM events

   ┌─id───────────────────────────────────┬─type────────┬───────────timestamp─┬─user_id─┬─data────────────────────────────────────┐
1. │ 7b7e0439-99d0-4590-a4f7-1cfea1e192d1 │ user_login  │ 2025-03-19 08:00:00 │    1001 │ {"device": "desktop", "location": "LA"} │
2. │ 846aa71f-f631-47b4-8429-ee8af87b4182 │ purchase    │ 2025-03-19 08:05:00 │    1002 │ {"item": "phone", "amount": 799}        │
3. │ 6b4d12e4-447d-4398-b3fa-1c1e94d71a2f │ user_logout │ 2025-03-19 08:10:00 │    1001 │ {"device": "desktop", "location": "LA"} │
4. │ 83b5eb72-aba3-4038-bc52-6c08b6423615 │ purchase    │ 2025-03-19 08:45:00 │    1003 │ {"item": "monitor", "amount": 450}      │
5. │ 975fb0c8-55bd-4df4-843b-34f5cfeed0a9 │ user_login  │ 2025-03-19 08:50:00 │    1004 │ {"device": "desktop", "location": "LA"} │
   └──────────────────────────────────────┴─────────────┴─────────────────────┴─────────┴─────────────────────────────────────────┘
```
