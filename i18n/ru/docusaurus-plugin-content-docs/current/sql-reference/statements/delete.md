---
description: 'Легковесные удаления упрощают процесс удаления данных из базы данных.'
keywords: ['delete']
sidebar_label: 'DELETE'
sidebar_position: 36
slug: /sql-reference/statements/delete
title: 'Легковесное DELETE выражение'
---

Легковесное `DELETE` выражение удаляет строки из таблицы `[db.]table`, которые соответствуют выражению `expr`. Оно доступно только для семейства *движков таблиц MergeTree*.

```sql
DELETE FROM [db.]table [ON CLUSTER cluster] [IN PARTITION partition_expr] WHERE expr;
```

Это выражение называется "легковесным `DELETE`", чтобы отличить его от команды [ALTER TABLE ... DELETE](/sql-reference/statements/alter/delete), которая является тяжелым процессом.

## Примеры {#examples}

```sql
-- Удаляет все строки из таблицы `hits`, где столбец `Title` содержит текст `hello`
DELETE FROM hits WHERE Title LIKE '%hello%';
```

## Легковесное `DELETE` не удаляет данные немедленно {#lightweight-delete-does-not-delete-data-immediately}

Легковесное `DELETE` реализуется как [мутация](/sql-reference/statements/alter#mutations), которая помечает строки как удаленные, но не удаляет их физически немедленно.

По умолчанию команды `DELETE` ожидают завершения маркировки строк как удаленных перед возвратом результата. Это может занять много времени, если объем данных велик. В качестве альтернативы вы можете запустить его асинхронно в фоновом режиме, используя настройку [`lightweight_deletes_sync`](/operations/settings/settings#lightweight_deletes_sync). Если это отключено, команда `DELETE` вернется немедленно, но данные могут все еще быть видимы для запросов до завершения фоновой мутации.

Мутация не удаляет физически строки, которые были помечены как удаленные; это произойдет только во время следующего слияния. В результате может произойти так, что в течение неопределенного времени данные не будут фактически удалены из хранилища и будут только помечены как удаленные.

Если вам нужно гарантировать, что ваши данные удалены из хранилища за предсказуемое время, рассмотрите возможность использования настройки таблицы [`min_age_to_force_merge_seconds`](/operations/settings/merge-tree-settings#min_age_to_force_merge_seconds). Или вы можете использовать команду [ALTER TABLE ... DELETE](/sql-reference/statements/alter/delete). Обратите внимание, что удаление данных с помощью `ALTER TABLE ... DELETE` может потребовать значительных ресурсов, так как оно воссоздает все затронутые части.

## Удаление большого объема данных {#deleting-large-amounts-of-data}

Удаления большого объема могут негативно сказаться на производительности ClickHouse. Если вы пытаетесь удалить все строки из таблицы, рассмотрите возможность использования команды [`TRUNCATE TABLE`](/sql-reference/statements/truncate).

Если вы ожидаете частые удаления, рассмотрите возможность использования [пользовательского ключа партиционирования](/engines/table-engines/mergetree-family/custom-partitioning-key). Вы сможете использовать команду [`ALTER TABLE ... DROP PARTITION`](/sql-reference/statements/alter/partition#drop-partitionpart) для быстрого удаления всех строк, связанных с этой частью.

## Ограничения легковесного `DELETE` {#limitations-of-lightweight-delete}

### Легковесные `DELETE` с проекциями {#lightweight-deletes-with-projections}

По умолчанию `DELETE` не работает для таблиц с проекциями. Это связано с тем, что строки в проекции могут быть затронуты операцией `DELETE`. Однако существует [настройка MergeTree](/operations/settings/merge-tree-settings) `lightweight_mutation_projection_mode`, чтобы изменить это поведение.

## Учет производительности при использовании легковесного `DELETE` {#performance-considerations-when-using-lightweight-delete}

**Удаление больших объемов данных с помощью легковесного `DELETE` может отрицательно повлиять на производительность запросов SELECT.**

Следующее также может негативно сказаться на производительности легковесного `DELETE`:

- Тяжелое условие `WHERE` в запросе `DELETE`.
- Если очередь мутаций заполнена многими другими мутациями, это может привести к проблемам с производительностью, так как все мутации в таблице выполняются последовательно.
- Затронутая таблица имеет очень большое количество частей данных.
- Наличие большого объема данных в компактных частях. В компактной части все столбцы хранятся в одном файле.

## Права на удаление {#delete-permissions}

`DELETE` требует привилегии `ALTER DELETE`. Чтобы включить команды `DELETE` для конкретной таблицы для данного пользователя, выполните следующую команду:

```sql
GRANT ALTER DELETE ON db.table to username;
```

## Как легковесные DELETE работают в ClickHouse {#how-lightweight-deletes-work-internally-in-clickhouse}

1. **Применяется "маска" к затронутым строкам**

   Когда выполняется запрос `DELETE FROM table ...`, ClickHouse сохраняет маску, где каждая строка помечена как "существующая" или как "удаленная". Эти "удаленные" строки исключаются из последующих запросов. Однако строки фактически удаляются позже при последующих слияниях. Запись этой маски намного легче, чем то, что выполняет запрос `ALTER TABLE ... DELETE`.

   Маска реализуется как скрытый системный столбец `_row_exists`, который хранит `True` для всех видимых строк и `False` для удаленных. Этот столбец присутствует в части только если в части были удалены некоторые строки. Этот столбец не существует, когда все значения в части равны `True`.

2. **Запросы `SELECT` трансформируются, чтобы включить маску**

   Когда маскированный столбец используется в запросе, запрос `SELECT ... FROM table WHERE condition` внутренне расширяется предикатом на `_row_exists` и преобразуется в:
   ```sql
   SELECT ... FROM table PREWHERE _row_exists WHERE condition
   ```
   Во время выполнения читается столбец `_row_exists`, чтобы определить, какие строки не должны возвращаться. Если много удаленных строк, ClickHouse может определить, какие гранулы можно полностью пропустить при чтении остальных столбцов.

3. **Запросы `DELETE` трансформируются в запросы `ALTER TABLE ... UPDATE`**

   Запрос `DELETE FROM table WHERE condition` переводится в мутацию `ALTER TABLE table UPDATE _row_exists = 0 WHERE condition`.

   Внутренне эта мутация выполняется в два этапа:

   1. Выполняется команда `SELECT count() FROM table WHERE condition` для каждой отдельной части, чтобы определить, затронута ли эта часть.

   2. На основе вышеуказанных команд затронутые части подвергаются мутации, а для незатронутых частей создаются жесткие ссылки. В случае широких частей столбец `_row_exists` для каждой строки обновляется, и все файлы других столбцов жестко связываются. Для компактных частей все столбцы переписываются, так как они все хранятся вместе в одном файле.

   Из вышеизложенных шагов видно, что легковесное `DELETE`, использующее технику маскирования, улучшает производительность по сравнению с традиционным `ALTER TABLE ... DELETE`, так как оно не переписывает все файлы столбцов для затронутых частей.

## Связанный контент {#related-content}

- Блог: [Обработка обновлений и удалений в ClickHouse](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)
