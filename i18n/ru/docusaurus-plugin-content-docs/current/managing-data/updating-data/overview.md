---
slug: /updating-data/overview
title: 'Обзор'
description: 'Как обновлять данные в ClickHouse'
keywords: ['обновление', 'обновление данных']
---

## Различия между обновлением данных в ClickHouse и OLTP базах данных {#differences-between-updating-data-in-clickhouse-and-oltp-databases}

Когда речь заходит об обновлении данных, ClickHouse и OLTP базы данных значительно различаются из-за своих основных принципов проектирования и целевых сценариев использования. Например, PostgreSQL, реляционная база данных с поддержкой ACID и ориентированная на строки, поддерживает надежные и транзакционные операции обновления и удаления, обеспечивая согласованность и целостность данных с помощью таких механизмов, как управление многоверсионной параллельностью (MVCC). Это позволяет безопасно и надежно вносить изменения даже в условиях высокой конкурентности.

В то время как ClickHouse — это столбцовая база данных, оптимизированная для аналитики с высокой нагрузкой на чтение и операций только на добавление с высокой производительностью. Хотя она нативно поддерживает обновления и удаление на месте, их следует использовать осторожно, чтобы избежать высокой нагрузки на ввод-вывод. В качестве альтернативы, таблицы можно перестраивать, чтобы конвертировать удаление и обновление в операции добавления, где они обрабатываются асинхронно и/или во время чтения, таким образом отражая акцент на высокой пропускной способности приема данных и эффективном выполнении запросов, а не на манипуляциях с реальными данными.

## Методы обновления данных в ClickHouse {#methods-to-update-data-in-clickhouse}

Существует несколько способов обновления данных в ClickHouse, каждый из которых имеет свои преимущества и характеристики производительности. Вам следует выбрать подходящий метод в зависимости от вашей модели данных и объема данных, которые вы собираетесь обновить.

Для обеих операций, если количество поданных мутаций постоянно превышает количество мутаций, которые обрабатываются в фоновом режиме за некоторый промежуток времени, очередь нематериализованных мутаций, которые необходимо применить, будет продолжать расти. Это приведет к ухудшению производительности запросов `SELECT`.

В общем, операции обновления следует выполнять осторожно, и очередь мутаций следует внимательно отслеживать с помощью таблицы `system.mutations`. Не выполняйте обновления слишком часто, как это делается в OLTP базах данных. Если у вас есть необходимость в частых обновлениях, смотрите [ReplacingMergeTree](/engines/table-engines/mergetree-family/replacingmergetree).

| Метод                                                                                | Синтаксис                           | Когда использовать                                                                                                                                                                                                                              |
|---------------------------------------------------------------------------------------|--------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [Обновление мутаций](/sql-reference/statements/alter/update)                          | `ALTER TABLE [table] UPDATE`         | Используйте, когда данные необходимо немедленно обновить на диске (например, для соблюдения норм). Негативно влияет на производительность `SELECT`.                                                                                                                        |
| [Легковесное обновление](/guides/developer/lightweight-update)                         | `ALTER TABLE [table] UPDATE`         | Включите, использовав `SET apply_mutations_on_fly = 1;`. Используйте при обновлении небольшого количества данных. Строки немедленно возвращаются с обновленными данными во всех последующих запросах `SELECT`, но изначально только внутренне помечены как обновленные на диске. |
| [ReplacingMergeTree](/engines/table-engines/mergetree-family/replacingmergetree)   | `ENGINE = ReplacingMergeTree`        | Используйте при обновлении больших объемов данных. Этот движок таблиц оптимизирован для дедупликации данных при слиянии.                                                                                                                                |
| [CollapsingMergeTree](/engines/table-engines/mergetree-family/collapsingmergetree) | `ENGINE = CollapsingMergeTree(Sign)` | Используйте при частом обновлении отдельных строк или для сценариев, где необходимо поддерживать актуальное состояние объектов, которые меняются со временем. Например, для отслеживания активности пользователей или статистики статей.                                       |

Вот краткий обзор различных способов обновления данных в ClickHouse:

## Обновление мутаций {#update-mutations}

Обновления мутаций могут быть выполнены с помощью команды `ALTER TABLE ... UPDATE`, например:

```sql
ALTER TABLE posts_temp
        (UPDATE AnswerCount = AnswerCount + 1 WHERE AnswerCount = 0)
```
Эти операции требуют значительных ресурсов ввода-вывода, переписывая все части, которые соответствуют выражению `WHERE`. У этого процесса нет атомарности — части заменяются измененными частями, как только они готовы, и запрос `SELECT`, который начинает выполняться во время мутации, увидит данные из частей, которые уже были изменены, вместе с данными из частей, которые еще не были изменены. Пользователи могут отслеживать состояние прогресса через таблицу [systems.mutations](/operations/system-tables/mutations). Эти операции требуют высоких ресурсов ввода-вывода и должны использоваться экономно, так как они могут влиять на производительность `SELECT` в кластере.

Читайте далее о [мутациях обновлений](/sql-reference/statements/alter/update).

## Легковесные обновления {#lightweight-updates}

Легковесные обновления предоставляют механизм для обновления строк таким образом, чтобы они обновлялись немедленно, и последующие запросы `SELECT` автоматически возвращали измененные значения (это влечет за собой накладные расходы и замедляет запросы). Это эффективно решает проблему атомарности стандартных мутаций. Приведем пример:

```sql
SET apply_mutations_on_fly = 1;

SELECT ViewCount
FROM posts
WHERE Id = 404346

┌─ViewCount─┐
│       26762   │
└───────────┘

1 row in set. Elapsed: 0.115 sec. Processed 59.55 million rows, 238.25 MB (517.83 million rows/s., 2.07 GB/s.)
Peak memory usage: 113.65 MiB.

- увеличение счетчика
ALTER TABLE posts
        (UPDATE ViewCount = ViewCount + 1 WHERE Id = 404346)

SELECT ViewCount
FROM posts
WHERE Id = 404346

┌─ViewCount─┐
│       26763   │
└───────────┘

1 row in set. Elapsed: 0.149 sec. Processed 59.55 million rows, 259.91 MB (399.99 million rows/s., 1.75 GB/s.)
```

Обратите внимание, что для легковесных обновлений все равно используется мутация для обновления данных; она просто не материализуется немедленно и применяется во время запросов `SELECT`. Она все равно будет применяться в фоне в качестве асинхронного процесса и будет влечь за собой такие же значительные накладные расходы, как и мутация, и, следовательно, является операцией, требующей высоких ресурсов ввода-вывода, которая должна использоваться осторожно. Выражения, которые могут быть использованы с этой операцией, также ограничены (см. здесь для [подробностей](/guides/developer/lightweight-update#support-for-subqueries-and-non-deterministic-functions)).

Читайте далее о [легковесных обновлениях](/guides/developer/lightweight-update).

## Collapsing Merge Tree {#collapsing-merge-tree}

Исходя из идеи о том, что обновление дорогостоящее, но вставки могут быть использованы для выполнения обновлений, 
движок таблиц [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree) 
можно использовать вместе со столбцом `sign` как способом указать ClickHouse обновить конкретную строку, объединив (удалив) 
пару строк со знаками `1` и `-1`. 
Если для столбца `sign` вставляется `-1`, вся строка будет удалена. 
Если для столбца `sign` вставляется `1`, ClickHouse сохранит строку. 
Строки для обновления идентифицируются на основе ключа сортировки, использованного в предложении `ORDER BY ()` при создании таблицы.

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8 -- Специальный столбец, используемый с движком таблиц CollapsingMergeTree
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID

INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1) -- sign = -1 сигнализирует об обновлении состояния этой строки
INSERT INTO UAct VALUES (4324182021466249494, 6, 185, 1) -- строка заменяется новым состоянием

SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration
FROM UAct
GROUP BY UserID
HAVING sum(Sign) > 0

┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

:::note
Вышеуказанный подход к обновлению требует от пользователей поддерживать состояние на стороне клиента. 
Хотя это наиболее эффективно с точки зрения ClickHouse, с этим может быть сложно работать в большом масштабе.

Рекомендуем ознакомиться с документацией 
по [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree)
для более полного обзора.
:::

## Дополнительные ресурсы {#more-resources}

- [Обработка обновлений и удалений в ClickHouse](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)
