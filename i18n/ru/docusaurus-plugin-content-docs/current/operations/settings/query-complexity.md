---
description: 'Настройки, которые ограничивают сложность запросов.'
sidebar_label: 'Ограничения на сложность запросов'
sidebar_position: 59
slug: /operations/settings/query-complexity
title: 'Ограничения на сложность запросов'
---


# Ограничения на сложность запросов

Ограничения на сложность запросов являются частью настроек. 
Они используются для обеспечения более безопасного выполнения через пользовательский интерфейс. 
Практически все ограничения применяются только к `SELECT`. Для распределенной обработки запросов ограничения применяются на каждом сервере отдельно.

ClickHouse проверяет ограничения для частей данных, а не для каждой строки. Это означает, что вы можете превышать значение ограничения с размерами части данных.

Ограничения на "максимальное количество чего-либо" могут принимать значение 0, что означает "без ограничений". 
Большинство ограничений также имеют настройку 'overflow_mode', которая указывает, что делать при превышении лимита. 
Она может принимать одно из двух значений: `throw` или `break`. Ограничения на агрегацию (group_by_overflow_mode) также имеют значение `any`.

`throw` – выбрасывает исключение (по умолчанию).

`break` – прекращает выполнение запроса и возвращает частичный результат, как если бы исходные данные исчерпались.

`any (только для group_by_overflow_mode)` – продолжает агрегацию для ключей, попавших в набор, но не добавляет новые ключи.

## max_memory_usage {#settings_max_memory_usage}

Максимальное количество оперативной памяти, используемое для выполнения запроса на одном сервере.

Настройка по умолчанию – неограниченная (установлено в `0`).

Значение по умолчанию в облаке: зависит от объема оперативной памяти на реплике.

Настройка не учитывает объем доступной памяти или общий объем памяти на машине. 
Ограничение применяется к одному запросу внутри одного сервера. 
Вы можете использовать `SHOW PROCESSLIST`, чтобы увидеть текущее потребление памяти для каждого запроса. 
Кроме того, пик потребления памяти отслеживается для каждого запроса и записывается в журнал.

Использование памяти не отслеживается для состояний определенных агрегатных функций.

Использование памяти не полностью отслеживается для состояний агрегатных функций `min`, `max`, `any`, `anyLast`, `argMin`, `argMax` из аргументов `String` и `Array`.

Потребление памяти также ограничивается параметрами `max_memory_usage_for_user` и [max_server_memory_usage](../../operations/server-configuration-parameters/settings.md#max_server_memory_usage).

## max_memory_usage_for_user {#max-memory-usage-for-user}

Максимальное количество оперативной памяти, используемое для выполнения запросов пользователей на одном сервере.

Значения по умолчанию определены в [Settings.h](https://github.com/ClickHouse/ClickHouse/blob/master/src/Core/Settings.h#L288). По умолчанию объем не ограничен (`max_memory_usage_for_user = 0`).

Смотрите также описание [max_memory_usage](#settings_max_memory_usage).

Например, если вы хотите установить `max_memory_usage_for_user` на 1000 байт для пользователя по имени `clickhouse_read`, вы можете использовать оператор

```sql
ALTER USER clickhouse_read SETTINGS max_memory_usage_for_user = 1000;
```

Вы можете проверить, что это сработало, выйдя из своей учетной записи, затем войдите снова и используйте функцию `getSetting`:

```sql
SELECT getSetting('max_memory_usage_for_user');
```

## max_rows_to_read {#max-rows-to-read}

Следующие ограничения могут проверяться для каждого блока (вместо каждой строки). То есть ограничения могут быть немного нарушены.

Максимальное количество строк, которые могут быть прочитаны из таблицы при выполнении запроса.

## max_bytes_to_read {#max-bytes-to-read}

Максимальное количество байт (несжатых данных), которое может быть прочитано из таблицы при выполнении запроса.

## read_overflow_mode {#read-overflow-mode}

Что делать, когда объем прочитанных данных превышает один из лимитов: 'throw' или 'break'. По умолчанию – выбрасывать.

## max_rows_to_read_leaf {#max-rows-to-read-leaf}

Следующие ограничения могут проверяться для каждого блока (вместо каждой строки). То есть ограничения могут быть немного нарушены.

Максимальное количество строк, которые могут быть прочитаны из локальной таблицы на узле листа при выполнении распределенного запроса. Хотя распределенные запросы могут выдавать множество подзапросов для каждого шарда (листа) – этот лимит будет проверяться только на этапе чтения на узлах листах и игнорироваться на этапе объединения результатов на корневом узле. Например, если кластер состоит из 2 шардов, и каждый шард содержит таблицу с 100 строками. Тогда распределенный запрос, который должен прочитать все данные из обеих таблиц с настройкой `max_rows_to_read=150`, завершится неудачей, так как в общей сложности будет 200 строк. В то время как запрос с `max_rows_to_read_leaf=150` будет успешным, так как узлы листов прочитают не более 100 строк.

## max_bytes_to_read_leaf {#max-bytes-to-read-leaf}

Максимальное количество байт (несжатых данных), которое может быть прочитано из локальной таблицы на узле листа при выполнении распределенного запроса. Хотя распределенные запросы могут выдавать множество подзапросов для каждого шарда (листа) – этот лимит будет проверяться только на этапе чтения на узлах листах и игнорироваться на этапе объединения результатов на корневом узле. Например, если кластер состоит из 2 шардов, и каждый шард содержит таблицу с 100 байтами данных. Тогда распределенный запрос, который должен прочитать все данные из обеих таблиц с настройкой `max_bytes_to_read=150`, завершится неудачей, так как в общей сложности будет 200 байт. В то время как запрос с `max_bytes_to_read_leaf=150` будет успешным, так как узлы листов прочитают не более 100 байт.

## read_overflow_mode_leaf {#read-overflow-mode-leaf}

Что делать, когда объем прочитанных данных превышает один из ограничений для листа: 'throw' или 'break'. По умолчанию – выбрасывать.

## max_rows_to_group_by {#settings-max-rows-to-group-by}

Максимальное количество уникальных ключей, полученных из агрегации. Эта настройка позволяет ограничить потребление памяти при агрегации.

## group_by_overflow_mode {#group-by-overflow-mode}

Что делать, когда количество уникальных ключей для агрегации превышает лимит: 'throw', 'break' или 'any'. По умолчанию – выбрасывать.
Использование значения 'any' позволяет запустить приближенную агрегацию GROUP BY. Качество этого приближения зависит от статистической природы данных.

## max_bytes_before_external_group_by {#settings-max_bytes_before_external_group_by}

Включает или отключает выполнение `GROUP BY` в внешней памяти. См. [GROUP BY в внешней памяти](/sql-reference/statements/select/group-by#group-by-in-external-memory).

Возможные значения:

- Максимальный объем оперативной памяти (в байтах), который может быть использован одной операцией [GROUP BY](/sql-reference/statements/select/group-by).
- 0 — `GROUP BY` во внешней памяти отключен.

Значение по умолчанию: `0`.

Значение по умолчанию в облаке: половина объема памяти на реплике.

## max_bytes_ratio_before_external_group_by {#settings-max_bytes_ratio_before_external_group_by}

Соотношение доступной памяти, разрешенной для `GROUP BY`. Достигнув этого значения, будет использоваться внешняя память для агрегации.

Например, если установить значение `0.6`, `GROUP BY` будет разрешать использовать `60%` доступной памяти (для сервера/пользователя/слияний) в начале выполнения, после чего он начнет использовать внешнюю агрегацию.

Значение по умолчанию: `0.5`.

## max_bytes_before_external_sort {#settings-max_bytes_before_external_sort}

Включает или отключает выполнение `ORDER BY` в внешней памяти. См. [Детали реализации ORDER BY](../../sql-reference/statements/select/order-by.md#implementation-details)

- Максимальный объем оперативной памяти (в байтах), который может быть использован одной операцией [ORDER BY](../../sql-reference/statements/select/order-by.md). Рекомендуемое значение – половина доступной системной памяти.
- 0 — `ORDER BY` во внешней памяти отключен.

Значение по умолчанию: 0.

Значение по умолчанию в облаке: половина объема памяти на реплике.

## max_bytes_ratio_before_external_sort {#settings-max_bytes_ratio_before_external_sort}

Соотношение доступной памяти, разрешенной для `ORDER BY`. Достигнув этого значения, будет использоваться внешняя сортировка.

Например, если установить значение `0.6`, `ORDER BY` будет позволять использовать `60%` доступной памяти (для сервера/пользователя/слияний) в начале выполнения, после чего он начнет использовать внешнюю сортировку.

Значение по умолчанию: `0.5`.

## max_rows_to_sort {#max-rows-to-sort}

Максимальное количество строк перед сортировкой. Это позволяет ограничить потребление памяти при сортировке.

## max_bytes_to_sort {#max-bytes-to-sort}

Максимальное количество байт перед сортировкой.

## sort_overflow_mode {#sort-overflow-mode}

Что делать, если количество строк, полученных перед сортировкой, превышает одно из ограничений: 'throw' или 'break'. По умолчанию – выбрасывать.

## max_result_rows {#setting-max_result_rows}

Ограничение на количество строк в результате. Также проверяется для подзапросов и на удаленных серверах при выполнении частей распределенного запроса. Ограничение не применяется, когда значение равно `0`.

Значение по умолчанию: `0`.

Значение по умолчанию в облаке: `0`.

## max_result_bytes {#max-result-bytes}

Ограничение на количество байт в результате. То же самое, что и предыдущее значение.

## result_overflow_mode {#result-overflow-mode}

Что делать, если объем результата превышает одно из ограничений: 'throw' или 'break'.

Использование 'break' похоже на использование LIMIT. `Break` прерывает выполнение только на уровне блока. Это означает, что количество возвращаемых строк больше, чем [max_result_rows](#setting-max_result_rows), множитель [max_block_size](/operations/settings/settings#max_block_size) и зависит от [max_threads](../../operations/settings/settings.md#max_threads).

Значение по умолчанию: `throw`.

Значение по умолчанию в облаке: `throw`.

Пример:

```sql
SET max_threads = 3, max_block_size = 3333;
SET max_result_rows = 3334, result_overflow_mode = 'break';

SELECT *
FROM numbers_mt(100000)
FORMAT Null;
```

Результат:

```text
6666 строк в наборе. ...
```

## max_execution_time {#max-execution-time}

Максимальное время выполнения запроса в секундах.
В это время оно не проверяется для одной из стадий сортировки, или при объединении и завершении агрегатных функций.

Параметр `max_execution_time` может быть немного сложным для понимания. 
Он работает на основе интерполяции относительно текущей скорости выполнения запроса (это поведение контролируется [timeout_before_checking_execution_speed](#timeout-before-checking-execution-speed)). 
ClickHouse прерывает запрос, если предполагаемое время выполнения превышает установленный `max_execution_time`. 
По умолчанию timeout_before_checking_execution_speed установлен на 10 секунд. Это означает, что после 10 секунд выполнения запроса ClickHouse начнет оценивать общее время выполнения. 
Если, например, `max_execution_time` установлен на 3600 секунд (1 час), ClickHouse завершит запрос, если оцениваемое время превысит этот лимит в 3600 секунд.
Если вы установите `timeout_before_checking_execution_speed ` в 0, ClickHouse будет использовать время часов в качестве основы для `max_execution_time`.

## timeout_overflow_mode {#timeout-overflow-mode}

Что делать, если запрос выполняется дольше, чем `max_execution_time`, или предполагаемое время выполнения дольше, чем `max_estimated_execution_time`: `throw` или `break`. По умолчанию – `throw`.

## max_execution_time_leaf {#max_execution_time_leaf}

Аналогичный смысл как `max_execution_time`, но применяется только на узле листа для распределенных или удаленных запросов.

Например, если мы хотим ограничить время выполнения на узле листа до `10s`, но не ограничивать на начальном узле, вместо того, чтобы иметь `max_execution_time` в настройках вложенного подзапроса:

```sql
SELECT count() FROM cluster(cluster, view(SELECT * FROM t SETTINGS max_execution_time = 10));
```

Мы можем использовать `max_execution_time_leaf` как настройки запроса:

```sql
SELECT count() FROM cluster(cluster, view(SELECT * FROM t)) SETTINGS max_execution_time_leaf = 10;
```

## timeout_overflow_mode_leaf {#timeout_overflow_mode_leaf}

Что делать, когда запрос на узле листа выполняется дольше, чем `max_execution_time_leaf`: `throw` или `break`. По умолчанию – `throw`.

## min_execution_speed {#min-execution-speed}

Минимальная скорость выполнения в строках в секунду. Проверяется на каждом блоке данных, когда истекает 'timeout_before_checking_execution_speed'. Если скорость выполнения ниже, выбрасывается исключение.

## min_execution_speed_bytes {#min-execution-speed-bytes}

Минимальное количество выполняемых байт в секунду. Проверяется на каждом блоке данных, когда истекает 'timeout_before_checking_execution_speed'. Если скорость выполнения ниже, выбрасывается исключение.

## max_execution_speed {#max-execution-speed}

Максимальное количество выполняемых строк в секунду. Проверяется на каждом блоке данных, когда истекает 'timeout_before_checking_execution_speed'. Если скорость выполнения высокая, скорость выполнения будет снижена.

## max_execution_speed_bytes {#max-execution-speed-bytes}

Максимальное количество выполняемых байт в секунду. Проверяется на каждом блоке данных, когда истекает 'timeout_before_checking_execution_speed'. Если скорость выполнения высокая, скорость выполнения будет снижена.

## timeout_before_checking_execution_speed {#timeout-before-checking-execution-speed}

Проверяет, чтобы скорость выполнения не была слишком низкой (не ниже 'min_execution_speed'), после того как истечет указанное время в секундах.

## max_estimated_execution_time {#max_estimated_execution_time}

Максимальное предполагаемое время выполнения запроса в секундах. Проверяется на каждом блоке данных, когда истекает 'timeout_before_checking_execution_speed'.

## max_columns_to_read {#max-columns-to-read}

Максимальное количество столбцов, которые могут быть прочитаны из таблицы в одном запросе. Если запрос требует чтения большего количества столбцов, выбрасывается исключение.

## max_temporary_columns {#max-temporary-columns}

Максимальное количество временных столбцов, которые должны сохраняться в оперативной памяти одновременно при выполнении запроса, включая постоянные столбцы. Если временных столбцов больше, чем это количество, выбрасывается исключение.

## max_temporary_non_const_columns {#max-temporary-non-const-columns}

То же самое, что и 'max_temporary_columns', но без учета постоянных столбцов. 
Обратите внимание, что постоянные столбцы образуются довольно часто при выполнении запроса, но требуют примерно нулевых вычислительных ресурсов.

## max_subquery_depth {#max-subquery-depth}

Максимальная глубина вложенности подзапросов. Если подзапросы глубже, выбрасывается исключение. По умолчанию – 100.

## max_pipeline_depth {#max-pipeline-depth}

Максимальная глубина конвейера. Соответствует количеству преобразований, через которые проходит каждый блок данных при обработке запроса. Подсчитывается в пределах одного сервера. Если глубина конвейера больше, выбрасывается исключение. По умолчанию – 1000.

## max_ast_depth {#max-ast-depth}

Максимальная глубина вложенности синтаксического дерева запроса. Если превышена, выбрасывается исключение. 
В настоящее время это не проверяется во время разбора, а только после разбора запроса. То есть слишком глубокое синтаксическое дерево может быть создано во время разбора, но запрос будет завершен неудачей. По умолчанию – 1000.

## max_ast_elements {#max-ast-elements}

Максимальное количество элементов в синтаксическом дереве запроса. Если превышено, выбрасывается исключение. 
Таким же образом, как и в предыдущей настройке, это проверяется только после разбора запроса. По умолчанию – 50,000.

## max_rows_in_set {#max-rows-in-set}

Максимальное количество строк для набора данных в операторе IN, созданном из подзапроса.

## max_bytes_in_set {#max-bytes-in-set}

Максимальное количество байт (несжатых данных), используемых набором в операторе IN, созданном из подзапроса.

## set_overflow_mode {#set-overflow-mode}

Что делать, когда объем данных превышает один из лимитов: 'throw' или 'break'. По умолчанию – выбрасывать.

## max_rows_in_distinct {#max-rows-in-distinct}

Максимальное количество различных строк при использовании DISTINCT.

## max_bytes_in_distinct {#max-bytes-in-distinct}

Максимальное количество байт, используемых хеш-таблицей при использовании DISTINCT.

## distinct_overflow_mode {#distinct-overflow-mode}

Что делать, когда объем данных превышает один из лимитов: 'throw' или 'break'. По умолчанию – выбрасывать.

## max_rows_to_transfer {#max-rows-to-transfer}

Максимальное количество строк, которые могут быть переданы на удаленный сервер или сохранены во временной таблице при использовании GLOBAL IN.

## max_bytes_to_transfer {#max-bytes-to-transfer}

Максимальное количество байт (несжатых данных), которые могут быть переданы на удаленный сервер или сохранены во временной таблице при использовании GLOBAL IN.

## transfer_overflow_mode {#transfer-overflow-mode}

Что делать, когда объем данных превышает один из лимитов: 'throw' или 'break'. По умолчанию – выбрасывать.

## max_rows_in_join {#settings-max_rows_in_join}

Ограничивает количество строк в хеш-таблице, используемой при объединении таблиц.

Эта настройка применяется к операциям [SELECT ... JOIN](/sql-reference/statements/select/join) и движку таблиц [Join](../../engines/table-engines/special/join.md).

Если запрос содержит несколько объединений, ClickHouse проверяет эту настройку для каждого промежуточного результата.

ClickHouse может принимать разные действия, когда лимит достигнут. Используйте настройку [join_overflow_mode](#settings-join_overflow_mode), чтобы выбрать действие.

Возможные значения:

- Положительное целое число.
- 0 — Неограниченное количество строк.

Значение по умолчанию: 0.

## max_bytes_in_join {#settings-max_bytes_in_join}

Ограничивает размер в байтах хеш-таблицы, используемой при объединении таблиц.

Эта настройка применяется к операциям [SELECT ... JOIN](/sql-reference/statements/select/join) и движку таблиц [Join](../../engines/table-engines/special/join.md).

Если запрос содержит объединения, ClickHouse проверяет эту настройку для каждого промежуточного результата.

ClickHouse может принимать разные действия, когда лимит достигнут. Используйте настройки [join_overflow_mode](#settings-join_overflow_mode), чтобы выбрать действие.

Возможные значения:

- Положительное целое число.
- 0 — Контроль памяти отключен.

Значение по умолчанию: 0.

## join_overflow_mode {#settings-join_overflow_mode}

Определяет, какое действие выполняет ClickHouse, когда достигнуто любое из следующих ограничений объединения:

- [max_bytes_in_join](#settings-max_bytes_in_join)
- [max_rows_in_join](#settings-max_rows_in_join)

Возможные значения:

- `THROW` — ClickHouse выбрасывает исключение и прерывает операцию.
- `BREAK` — ClickHouse прерывает операцию и не выбрасывает исключение.

Значение по умолчанию: `THROW`.

**Смотрите также**

- [Клаузула JOIN](/sql-reference/statements/select/join)
- [Движок таблиц Join](../../engines/table-engines/special/join.md)

## max_partitions_per_insert_block {#settings-max_partitions_per_insert_block}

Ограничивает максимальное количество разделов в одном вставляемом блоке.

- Положительное целое число.
- 0 — Неограниченное количество разделов.

Значение по умолчанию: 100.

**Детали**

При вставке данных ClickHouse вычисляет количество разделов в вставляемом блоке. Если количество разделов больше `max_partitions_per_insert_block`, ClickHouse либо записывает предупреждение, либо выбрасывает исключение на основе `throw_on_max_partitions_per_insert_block`. Исключения имеют следующий текст:

> "Слишком много разделов для одного блока INSERT (`partitions_count` разделов, лимит " + toString(max_partitions) + "). Лимит контролируется настройкой 'max_partitions_per_insert_block'. Большое количество разделов — распространенное заблуждение. Это приведет к серьезному негативному влиянию на производительность, включая медленная загрузка сервера, медленные запросы INSERT и медленные запросы SELECT. Рекомендуемое общее количество разделов для таблицы — менее 1000..10000. Обратите внимание, что разделение не предназначено для ускорения запросов SELECT (упорядочение по ключу достаточно для быстрой работы диапазонных запросов). Разделы предназначены для манипуляции данными (DROP PARTITION и т. д.)."

## throw_on_max_partitions_per_insert_block {#settings-throw_on_max_partition_per_insert_block}

Позволяет контролировать поведение, когда достигается `max_partitions_per_insert_block`.

- `true`  - Когда блок вставки достигает `max_partitions_per_insert_block`, выбрасывается исключение.
- `false` - Записывает предупреждение, когда достигается `max_partitions_per_insert_block`.

Значение по умолчанию: `true`

## max_temporary_data_on_disk_size_for_user {#settings_max_temporary_data_on_disk_size_for_user}

Максимальное количество данных, потребляемых временными файлами на диске в байтах для всех одновременно работающих запросов пользователей. 
Ноль означает отсутствие ограничений.

Значение по умолчанию: 0.

## max_temporary_data_on_disk_size_for_query {#settings_max_temporary_data_on_disk_size_for_query}

Максимальное количество данных, потребляемых временными файлами на диске в байтах для всех одновременно работающих запросов. 
Ноль означает отсутствие ограничений.

Значение по умолчанию: 0.

## max_sessions_for_user {#max-sessions-per-user}

Максимальное количество одновременных сеансов для каждого аутентифицированного пользователя на сервере ClickHouse.

Пример:

```xml
<profiles>
    <single_session_profile>
        <max_sessions_for_user>1</max_sessions_for_user>
    </single_session_profile>
    <two_sessions_profile>
        <max_sessions_for_user>2</max_sessions_for_user>
    </two_sessions_profile>
    <unlimited_sessions_profile>
        <max_sessions_for_user>0</max_sessions_for_user>
    </unlimited_sessions_profile>
</profiles>
<users>
     <!-- Пользователь Алиса может подключаться к серверу ClickHouse не более одного раза одновременно. -->
    <Alice>
        <profile>single_session_user</profile>
    </Alice>
    <!-- Пользователь Боб может использовать 2 одновременных сеанса. -->
    <Bob>
        <profile>two_sessions_profile</profile>
    </Bob>
    <!-- Пользователь Чарльз может использовать произвольное количество одновременных сеансов. -->
    <Charles>
       <profile>unlimited_sessions_profile</profile>
    </Charles>
</users>
```

Значение по умолчанию: 0 (бесконечное количество одновременных сеансов).

## max_partitions_to_read {#max-partitions-to-read}

Ограничивает максимальное количество разделов, которые можно получить в одном запросе.

Значение настройки, указанное при создании таблицы, может быть переопределено через настройку на уровне запроса.

Возможные значения:

- Любое положительное целое число.

Значение по умолчанию: -1 (без ограничений).

Вы также можете указать настройку MergeTree [max_partitions_to_read](merge-tree-settings#max-partitions-to-read) в настройках таблиц.
