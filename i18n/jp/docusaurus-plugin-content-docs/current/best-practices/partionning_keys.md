---
slug: /best-practices/choosing-a-partitioning-key
sidebar_position: 10
sidebar_label: 'パーティショニングキーの選択'
title: 'パーティショニングキーの選択'
description: 'パーティショニングキーの選び方を説明するページ'
---

import Image from '@theme/IdealImage';
import partitions from '@site/static/images/bestpractices/partitions.png';
import merges_with_partitions from '@site/static/images/bestpractices/merges_with_partitions.png';

:::note データ管理技術
パーティショニングは主にデータ管理技術であり、クエリ最適化ツールではありません。特定のワークロードにおいてパフォーマンスを改善することはありますが、クエリを加速するための最初のメカニズムとして使用すべきではなく、パーティショニングキーは、その影響を明確に理解した上で慎重に選択し、データライフサイクルのニーズや十分に理解されたアクセスパターンに合致する場合のみ適用するべきです。
:::

ClickHouseでは、パーティショニングは指定されたキーに基づいてデータを論理的なセグメントに整理します。これは、テーブル作成時に `PARTITION BY` 句を使用して定義され、通常、行を時間の間隔、カテゴリ、またはその他のビジネス関連の次元でグループ化するために使用されます。パーティショニング表現の各ユニークな値は、ディスク上に独自の物理パーティションを形成し、ClickHouseはこれらの値ごとに別々のパーツにデータを保存します。パーティショニングはデータ管理を改善し、保持ポリシーを簡略化し、特定のクエリパターンで役立ちます。

例えば、次のUK価格支払データセットテーブルを考えてみましょう。パーティショニングキーは `toStartOfMonth(date)` です。

```sql
CREATE TABLE uk.uk_price_paid_simple_partitioned
(
    date Date,
 town LowCardinality(String),
 street LowCardinality(String),
 price UInt32
)
ENGINE = MergeTree
ORDER BY (town, street)
PARTITION BY toStartOfMonth(date)
```

行セットがテーブルに挿入されると、ClickHouseは（[ここ](/parts)で説明されているように）全ての挿入された行を含む単一のデータパーツを作成する代わりに、挿入された行の中でユニークなパーティションキー値ごとに新しいデータパーツを作成します。

<Image img={partitions} size="lg" alt="Partitions" />


ClickHouseサーバーは、上の図に示された4行の例の挿入から、最初にパーティションキー値 `toStartOfMonth(date)` によって行を分割します。その後、特定された各パーティションに対して、行は[通常通り](/parts)に、いくつかの順次ステップ（① ソート、② カラムへの分割、③ 圧縮、④ ディスクへの書き込み）を行うことで処理されます。

パーティショニングについての詳細な説明については、[こちらのガイド](/partitions)をお勧めします。

パーティショニングが有効になっている場合、ClickHouseはパーティション内のデータパーツのみを[マージ](/merges)し、パーティションを跨いでマージすることはありません。上記の例のテーブルについてそれを示しています。

<Image img={merges_with_partitions} size="md" alt="Partitions" />

## パーティショニングのアプリケーション {#applications-of-partitioning}

パーティショニングはClickHouseにおいて大規模データセットを管理するための強力なツールであり、特に可観測性や分析のユースケースで役立ちます。これは、時間やビジネスロジックに沿った全体のパーティションを単一のメタデータ操作で削除、移動、またはアーカイブできることで、効率的なデータライフサイクルオペレーションを可能にします。これは、行レベルの削除やコピー操作よりもはるかに高速かつリソース効率が良いです。パーティショニングは、TTL や階層ストレージのような ClickHouse の機能とクリーンに統合されるため、カスタムオーケストレーションなしで保持ポリシーやホット/コールドストレージ戦略を実装可能です。例えば、最近のデータは高速なSSDストレージに保持し、古いパーティションは自動的に安価なオブジェクトストレージに移動されます。

パーティショニングは一部のワークロードでクエリのパフォーマンスを改善することがありますが、応答時間に悪影響を与える可能性もあります。

パーティショニングキーが主キーに含まれておらず、それでフィルタリングを行う場合、ユーザーはパーティショニングによるクエリパフォーマンスの改善を見ることができます。[こちら](/partitions#query-optimization)でその例を見てください。

逆に、クエリがパーティションを跨いでクエリを行う必要がある場合、全体のパーツ数が増えるため、パフォーマンスが悪影響を受けることがあります。このため、ユーザーはパーティショニングをクエリ最適化技術と考える前に、自分のアクセスパターンを理解する必要があります。

要約すると、ユーザーは主にパーティショニングをデータ管理技術として考えるべきです。データの管理の例については、可観測性のユースケースガイドの["データの管理"](/observability/managing-data)や、コアコンセプト - テーブルパーティションの["テーブル・パーティションは何に使われるのか？"](/partitions#data-management)を参照してください。

## 低カーディナリティのパーティショニングキーを選択する {#choose-a-low-cardinality-partitioning-key}

重要なのは、パーツの数が多ければ多いほど、クエリパフォーマンスに悪影響を与えるということです。したがって、ClickHouseは、指定された制限を超えた場合に[「パーツが多すぎる」](/knowledgebase/exception-too-many-parts)というエラーで挿入に応答します。制限は、[合計](/operations/settings/merge-tree-settings#max_parts_in_total)または[パーティションごと](/operations/settings/merge-tree-settings#parts_to_throw_insert)によって測定されます。

パーティショニングキーにとって適切な**カーディナリティ**を選ぶことは重要です。多くの異なるパーティション値が存在する高カーディナリティのパーティショニングキーは、データパーツの急増を引き起こす可能性があります。ClickHouseはパーティション間でパーツをマージしないため、パーティションが多すぎると未マージのパーツが増えすぎ、「パーツが多すぎる」エラーの原因となります。[マージは](/merges)ストレージの断片化を軽減し、クエリ速度を最適化するために不可欠ですが、高カーディナリティのパーティションでは、そのマージの可能性が失われます。

対照的に、**低カーディナリティのパーティショニングキー**—ユニークな値が100 - 1,000未満のものが通常最適です。これにより、効率的なパーツのマージが可能になり、メタデータオーバーヘッドが低く抑えられ、ストレージにおける過剰なオブジェクトの作成を避けることができます。さらに、ClickHouseはパーティション列に自動的にMinMaxインデックスを構築し、これによりそれらの列でフィルタリングするクエリを大幅に高速化できます。例えば、テーブルが `toStartOfMonth(date)` でパーティショニングされている場合、月ごとにフィルタリングすることで、エンジンは無関係なパーティションとそのパーツを完全にスキップできるのです。

パーティショニングは一部のクエリパターンでパフォーマンスを改善する場合がありますが、主にデータ管理機能です。多くのケースにおいて、全てのパーティションを跨いでクエリを行うことは、データの断片化が増加し、スキャンされるパーツが多くなるため、非パーティショニングテーブルを使用するよりも遅い可能性があります。パーティショニングは慎重に使用し、選択したキーが低カーディナリティであることと、データライフサイクルポリシー（例：TTLによる保持）に合致することを常に確認してください。パーティショニングが必要かどうかわからない場合は、それなしで始め、観察されたアクセスパターンに基づいて後で最適化することをお勧めします。
