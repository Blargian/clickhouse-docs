---
description: 'Документация по синтаксису'
displayed_sidebar: 'sqlreference'
sidebar_label: 'Синтаксис'
sidebar_position: 2
slug: /sql-reference/syntax
title: 'Синтаксис'
---

В этом разделе мы рассмотрим SQL-синтаксис ClickHouse. 
ClickHouse использует синтаксис на основе SQL, но предлагает ряд расширений и оптимизаций.

## Парсинг запросов {#query-parsing}

В ClickHouse есть два типа парсеров:
- _Полный SQL парсер_ (рекурсивный парсинг).
- _Парсер формата данных_ (быстрый потоковый парсер).

Полный SQL парсер используется во всех случаях, кроме запроса `INSERT`, который использует оба парсера.

Рассмотрим следующий запрос:

```sql
INSERT INTO t VALUES (1, 'Hello, world'), (2, 'abc'), (3, 'def')
```

Как уже упоминалось, запрос `INSERT` использует оба парсера. 
Фрагмент `INSERT INTO t VALUES` обрабатывается полным парсером, 
а данные `(1, 'Hello, world'), (2, 'abc'), (3, 'def')` обрабатываются парсером формата данных или быстрым потоковым парсером.

<details>
<summary>Включение полного парсера</summary>

Вы также можете включить полный парсер для данных 
с помощью настройки [`input_format_values_interpret_expressions`](../operations/settings/settings-formats.md#input_format_values_interpret_expressions). 

Когда указанная настройка установлена в `1`, 
ClickHouse сначала пытается разобрать значения с помощью быстрого потокового парсера. 
Если это не удаётся, ClickHouse пытается использовать полный парсер для данных, рассматривая их как SQL [выражение](#expressions).
</details>

Данные могут иметь любой формат. 
Когда запрос поступает, сервер вычисляет не более чем [max_query_size](../operations/settings/settings.md#max_query_size) байт запроса в ОЗУ 
(по умолчанию 1 МБ), а остальная часть обрабатывается потоковым парсером.
Это делается для предотвращения проблем с большими запросами `INSERT`, что является рекомендуемым способом вставки данных в ClickHouse.

При использовании формата [`Values`](../interfaces/formats.md/#data-format-values) в запросе `INSERT` 
может показаться, что данные обрабатываются так же, как и для выражений в запросе `SELECT`, однако это не так. 
Формат `Values` гораздо более ограниченный.

Остальная часть этого раздела охватывает полный парсер. 

:::note
Для получения дополнительной информации о парсерах формата обратитесь к разделу [Форматы](../interfaces/formats.md).
:::

## Пробелы {#spaces}

- Между синтаксическими конструкциями может быть любое количество пробелов (включая начало и конец запроса). 
- Пробелы включают пробел, табуляцию, перевод строки, возврат каретки и новую страницу.

## Комментарии {#comments}

ClickHouse поддерживает как SQL-стиль, так и C-стиль комментарии:

- SQL-стиль комментарии начинаются с `--`, `#!` или `# ` и продолжаются до конца строки. Пробел после `--` и `#!` может быть опущен.
- C-стиль комментарии охватывают от `/*` до `*/` и могут быть многострочными. Пробелы также не обязательны.

## Ключевые слова {#keywords}

Ключевые слова в ClickHouse могут быть либо _чувствительными к регистру_, либо _ insensitive_, в зависимости от контекста.

Ключевые слова являются **insensitive к регистру** когда они соответствуют:

- Стандарту SQL. Например, `SELECT`, `select` и `SeLeCt` все действительны.
- Реализациям в некоторых популярных СУБД (MySQL или Postgres). Например, `DateTime` равно `datetime`.

:::note
Вы можете проверить, является ли имя типа данных чувствительным к регистру в таблице [system.data_type_families](/operations/system-tables/data_type_families).
:::

В отличие от стандартного SQL, все другие ключевые слова (включая названия функций) являются **чувствительными к регистру**.

Кроме того, ключевые слова не являются зарезервированными. 
Они рассматриваются как таковые только в соответствующем контексте. 
Если вы используете [идентификаторы](#identifiers) с тем же именем, что и ключевые слова, заключите их в двойные кавычки или обратные кавычки. 

Например, следующий запрос является действительным, если таблица `table_name` имеет столбец с именем `"FROM"`:

```sql
SELECT "FROM" FROM table_name
```

## Идентификаторы {#identifiers}

Идентификаторы это:

- Имена кластера, базы данных, таблицы, раздела и столбца.
- [Функции](#functions).
- [Типы данных](../sql-reference/data-types/index.md).
- [Псевдонимы выражений](#expression-aliases).

Идентификаторы могут быть заключены в кавычки или не заключены, хотя последние предпочтительнее.

Не заключенные в кавычки идентификаторы должны совпадать с регулярным выражением `^[a-zA-Z_][0-9a-zA-Z_]*$` и не могут совпадать с [ключевыми словами](#keywords).
Смотрите таблицу ниже для примеров действительных и недействительных идентификаторов:

| Действительные идентификаторы                             | Недействительные идентификаторы                     |
|---------------------------------------------------------|----------------------------------------------------|
| `xyz`, `_internal`, `Id_with_underscores_123_`        | `1x`, `tom@gmail.com`, `äußerst_schön`             |


Если вы хотите использовать идентификаторы, такие как ключевые слова или вы хотите использовать другие символы в идентификаторах, заключите их в двойные кавычки или обратные кавычки, например, `"id"`, `` `id` ``.

:::note
Тем же правилам, которые применяются для экранирования в заключенных в кавычки идентификаторах, также подвергаются строковые литералы. См. [Строка](#string) для получения более подробной информации.
:::

## Литералы {#literals}

В ClickHouse литерал — это значение, которое непосредственно представлено в запросе.
Другими словами, это фиксированное значение, которое не изменяется во время выполнения запроса.

Литералы могут быть:
- [Строка](#string)
- [Числовой](#numeric)
- [Составной](#compound)
- [`NULL`](#null)
- [Heredocs](#heredoc) (пользовательские строковые литералы)

Мы подробнее рассмотрим каждую из этих категорий в следующих разделах.

### Строка {#string}

Строковые литералы должны быть заключены в одинарные кавычки. Двойные кавычки не поддерживаются.

Экранирование осуществляется следующим образом:

- используя предшествующую одинарную кавычку, где символ одинарной кавычки `'` (и только этот символ) можно экранировать как `''`, или
- используя предшествующий обратный слэш с поддерживаемыми последовательностями экранирования, перечисленными в таблице ниже.

:::note
Обратный слэш теряет своё специальное значение, то есть он интерпретируется буквально, если он предшествует символам, отличным от перечисленных ниже.
:::

| Поддерживаемое экранирование                     | Описание                                                             |
|--------------------------------------------------|-------------------------------------------------------------------------|
| `\xHH`                                           | Спецификация 8-битного символа, за которым следует любое количество шестнадцатеричных цифр (H). | 
| `\N`                                             | зарезервированный, ничего не делает (например, `SELECT 'a\Nb'` возвращает `ab`)                |
| `\a`                                            | сигнал                                                                   |
| `\b`                                            | возврат каретки                                                               |
| `\e`                                            | символ экранирования                                                        |
| `\f`                                            | новая страница                                                               |
| `\n`                                            | перевод строки                                                               |
| `\r`                                            | возврат каретки                                                         |
| `\t`                                            | горизонтальная табуляция                                                          |
| `\v`                                            | вертикальная табуляция                                                            |
| `\0`                                            | нулевой символ                                                          |
| `\\`                                           | обратный слэш                                                               |
| `\'` (или ` '' `)                               | одинарная кавычка                                                            |
| `\"`                                           | двойная кавычка                                                            |
| `` ` ``                                           | обратная кавычка                                                                |
| `\/`                                           | прямой слэш                                                           |
| `\=`                                           | знак равенства                                                              |
| ASCII контрольные символы (c &lt;= 31). |                                                                      | 

:::note
В строковых литералах вы должны экранировать как минимум символы `'` и `\` с помощью escape-кодов `\'` (или: `''`) и `\\`.
:::

### Числовой {#numeric}

Числовые литералы анализируются следующим образом:

- Сначала как 64-битное знаковое число с использованием функции [strtoull](https://en.cppreference.com/w/cpp/string/byte/strtoul).
- Если это не удастся, как 64-битное без знака число с использованием функции [strtoll](https://en.cppreference.com/w/cpp/string/byte/strtol).
- Если это не удастся, как число с плавающей запятой с использованием функции [strtod](https://en.cppreference.com/w/cpp/string/byte/strtof).
- В противном случае возвращается ошибка.

Литералы преобразуются в наименьший тип, в который вмещается значение.
Например:
- `1` интерпретируется как `UInt8`
- `256` интерпретируется как `UInt16`. 

Для получения дополнительной информации смотрите [Типы данных](../sql-reference/data-types/index.md).

Подчеркивание `_` внутри числовых литералов игнорируется и может использоваться для улучшения читаемости.

Следующие числовые литералы поддерживаются:

| Числовой литерал                               | Примеры                                       |
|-----------------------------------------------|-----------------------------------------------|
| **Целые числа**                              | `1`, `10_000_000`, `18446744073709551615`, `01` |
| **Десятичные числа**                         | `0.1`                                        |
| **Экспоненциальная нотация**                 | `1e100`, `-1e-100`                             |
| **Числа с плавающей точкой**                 | `123.456`, `inf`, `nan`                        |
| **Шестнадцатеричные**                        | `0xc0fe`                                       |
| **Строка шестнадцатеричного формата, совместимая со стандартом SQL**| `x'c0fe'`                                      |
| **Двоичные числа**                           | `0b1101`                                       |
| **Строка двоичного формата, совместимая со стандартом SQL** | `b'1101'`                                      |

:::note
Октальные литералы не поддерживаются для избежания случайных ошибок интерпретации.
:::

### Составной {#compound}

Массивы создаются с использованием квадратных скобок `[1, 2, 3]`. Кортежи создаются с использованием круглых скобок `(1, 'Hello, world!', 2)`.
Технически это не литералы, а выражения с оператором создания массива и оператором создания кортежа соответственно.
Массив должен содержать как минимум один элемент, а кортеж — как минимум два элемента.

:::note
Существует отдельный случай, когда кортежи встречаются в условии `IN` запроса `SELECT`. 
Результаты запросов могут включать кортежи, но кортежи не могут быть сохранены в базе данных (исключая таблицы с использованием движка [Memory](../engines/table-engines/special/memory.md)).
:::

### NULL {#null}

`NULL` используется для указания на то, что значение отсутствует. 
Чтобы сохранить `NULL` в поле таблицы, оно должно быть типа [Nullable](../sql-reference/data-types/nullable.md).

:::note
Следует отметить следующее относительно `NULL`:

- В зависимости от формата данных (входного или выходного) `NULL` может иметь разное представление. Для получения дополнительной информации смотрите [форматы данных](/interfaces/formats).
- Обработка `NULL` имеет свои нюансы. Например, если хотя бы один из аргументов операции сравнения равен `NULL`, результат этой операции также будет равен `NULL`. То же самое относится к умножению, сложению и другим операциям. Мы рекомендуем ознакомиться с документацией по каждой операции.
- В запросах вы можете проверять `NULL` с помощью операторов [`IS NULL`](/sql-reference/functions/functions-for-nulls#isnull) и [`IS NOT NULL`](/sql-reference/functions/functions-for-nulls#isnotnull) и связанных функций `isNull` и `isNotNull`.
:::

### Heredoc {#heredoc}

[Heredoc](https://en.wikipedia.org/wiki/Here_document) — это способ определения строки (часто многострочной), сохраняя оригинальное форматирование. 
Heredoc определяется как пользовательский строковой литерал, размещаемый между двумя символами `$`.

Например:

```sql
SELECT $heredoc$SHOW CREATE VIEW my_view$heredoc$;

┌─'SHOW CREATE VIEW my_view'─┐
│ SHOW CREATE VIEW my_view   │
└────────────────────────────┘
```

:::note
- Значение между двумя heredoc обрабатывается "как есть".
:::

:::tip
- Вы можете использовать heredoc для встраивания фрагментов SQL, кода HTML или XML и т.д.
:::

## Определение и использование параметров запроса {#defining-and-using-query-parameters}

Параметры запросов позволяют вам писать универсальные запросы, содержащие абстрактные заполнители вместо конкретных идентификаторов. 
Когда запрос с параметрами выполняется, 
все заполнители разрешаются и заменяются фактическими значениями параметров запроса.

Существует два способа определения параметра запроса:

- `SET param_<name>=<value>`
- `--param_<name>='<value>'`

При использовании второго варианта он передаётся как аргумент к `clickhouse-client` в командной строке, где:
- `<name>` — это имя параметра запроса.
- `<value>` — его значение.

Параметр запроса может быть ссылается в запросе, используя `{<name>: <datatype>}`, где `<name>` — это имя параметра запроса, а `<datatype>` — это тип данных, в который он преобразуется.

<details>
<summary>Пример с командой SET</summary>

Например, следующий SQL определяет параметры с именами `a`, `b`, `c` и `d`, каждый с разным типом данных:

```sql
SET param_a = 13;
SET param_b = 'str';
SET param_c = '2022-08-04 18:30:53';
SET param_d = {'10': [11, 12], '13': [14, 15]};

SELECT
   {a: UInt32},
   {b: String},
   {c: DateTime},
   {d: Map(String, Array(UInt8))};

13    str    2022-08-04 18:30:53    {'10':[11,12],'13':[14,15]}
```
</details>

<details>
<summary>Пример с clickhouse-client</summary>

Если вы используете `clickhouse-client`, параметры задаются как `--param_name=value`. Например, следующий параметр имеет имя `message`, и он извлекается как `String`:

```bash
clickhouse-client --param_message='hello' --query="SELECT {message: String}"

hello
```

Если параметр запроса представляет собой имя базы данных, таблицы, функции или другого идентификатора, используйте `Identifier` для его типа. Например, следующий запрос возвращает строки из таблицы с названием `uk_price_paid`:

```sql
SET param_mytablename = "uk_price_paid";
SELECT * FROM {mytablename:Identifier};
```
</details>

:::note
Параметры запросов не являются общими текстовыми заменами, которые могут использоваться в произвольных местах в произвольных SQL-запросах. 
Они в первую очередь предназначены для работы в операторах `SELECT` на месте идентификаторов или литералов.
:::

## Функции {#functions}

Вызовы функций записываются как идентификатор с перечнем аргументов (возможно, пустых) в круглых скобках. 
В отличие от стандартного SQL, скобки обязательны, даже для пустого списка аргументов. 
Например: 

```sql
now()
```

Существуют также:
- [Обычные функции](/sql-reference/functions/overview).
- [Агрегатные функции](/sql-reference/aggregate-functions).

Некоторые агрегатные функции могут содержать два списка аргументов в скобках. Например: 

```sql
quantile (0.9)(x) 
```

Эти агрегатные функции называются "параметрическими" функциями, 
а аргументы в первом списке называются "параметрами".

:::note
Синтаксис агрегатных функций без параметров такой же, как и для обычных функций.
:::

## Операторы {#operators}

Операторы преобразуются в соответствующие функции во время парсинга запросов, принимая во внимание их приоритет и ассоциативность.

Например, выражение

```text
1 + 2 * 3 + 4
```

преобразуется в 

```text
plus(plus(1, multiply(2, 3)), 4)`
```

## Типы данных и движки таблиц базы данных {#data-types-and-database-table-engines}

Типы данных и движки таблиц в запросе `CREATE` записываются так же, как идентификаторы или функции. 
Другими словами, они могут содержать аргументы в скобках или не содержать.

Для получения дополнительной информации смотрите разделы:
- [Типы данных](/sql-reference/data-types/index.md)
- [Движки таблиц](/engines/table-engines/index.md)
- [CREATE](/sql-reference/statements/create/index.md).

## Выражения {#expressions}

Выражение может быть следующим: 
- функцией
- идентификатором
- литералом
- применением оператора
- выражением в скобках
- подзапросом
- или звездочкой. 

Оно также может содержать [псевдоним](#expression-aliases).

Список выражений представляет собой одно или несколько выражений, разделённых запятыми.
Функции и операторы, в свою очередь, могут принимать выражения в качестве аргументов.

## Псевдонимы выражений {#expression-aliases}

Псевдоним — это имя, заданное пользователем для [выражения](#expressions) в запросе.

```sql
expr AS alias
```

Части синтаксиса выше объясняются ниже.

| Часть синтаксиса | Описание                                                                                                                                      | Пример                                                                 | Примечания                                                                                                                                                |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `AS`             | Ключевое слово для определения псевдонимов. Вы можете определить псевдоним для имени таблицы или имени столбца в операторе `SELECT`, не используя ключевое слово `AS`. | `SELECT table_name_alias.column_name FROM table_name table_name_alias`. | В функции [CAST](/sql-reference/functions/type-conversion-functions#cast) ключевое слово `AS` имеет другое значение. См. описание функции. |
| `expr`           | Любое выражение, поддерживаемое ClickHouse.                                                                                                          | `SELECT column_name * 2 AS double FROM some_table`                      |                                                                                                                                                      |
| `alias`          | Имя для `expr`. Псевдонимы должны соответствовать синтаксису [идентификаторов](#identifiers).                                                                       | `SELECT "table t".column_name FROM table_name AS "table t"`.            |                                                                                                                                                      |

### Примечания по использованию {#notes-on-usage}

- Псевдонимы действительны глобально для запроса или подзапроса, и вы можете определить псевдоним в любой части запроса для любого выражения. Например:

```sql
SELECT (1 AS n) + 2, n`.
```

- Псевдонимы не видны в подзапросах и между подзапросами. Например, при выполнении следующего запроса ClickHouse генерирует исключение `Неизвестный идентификатор: num`:

```sql
`SELECT (SELECT sum(b.a) + num FROM b) - a.a AS num FROM a`
```

- Если псевдоним определяется для результирующих столбцов в операторе `SELECT` подзапроса, эти столбцы видны в внешнем запросе. Например:

```sql
SELECT n + m FROM (SELECT 1 AS n, 2 AS m)`.
```

- Будьте осторожны с псевдонимами, которые совпадают с именами столбцов или таблиц. Рассмотрим следующий пример:

```sql
CREATE TABLE t
(
    a Int,
    b Int
)
ENGINE = TinyLog();

SELECT
    argMax(a, b),
    sum(b) AS b
FROM t;

Получено исключение от сервера (версия 18.14.17):
Код: 184. DB::Exception: Получено от localhost:9000, 127.0.0.1. DB::Exception: Агрегатная функция sum(b) найдена внутри другой агрегатной функции в запросе.
```

В предыдущем примере мы объявили таблицу `t` с колонкой `b`. 
Затем, когда мы отбирали данные, мы определили псевдоним `sum(b) AS b`. 
Так как псевдонимы действительны глобально, 
ClickHouse заменил литерал `b` в выражении `argMax(a, b)` на выражение `sum(b)`. 
Эта замена вызвала исключение.

:::note
Вы можете изменить это стандартное поведение, установив [prefer_column_name_to_alias](/operations/settings/settings#prefer_column_name_to_alias) в `1`.
:::

## Звездочка {#asterisk}

В операторе `SELECT` звездочка может заменить выражение. 
Для получения дополнительной информации смотрите раздел [SELECT](/sql-reference/statements/select/index.md#asterisk).
