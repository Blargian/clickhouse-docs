---
slug: /materialized-view/incremental-materialized-view
title: 'Инкрементное материализованное представление'
description: 'Как использовать инкрементные материализованные представления для ускорения запросов'
keywords: ['инкрементные материализованные представления', 'ускорение запросов', 'оптимизация запросов']
score: 10000
---

import materializedViewDiagram from '@site/static/images/materialized-view/materialized-view-diagram.png';
import Image from '@theme/IdealImage';


# Инкрементные материализованные представления

Инкрементные материализованные представления (Materialized Views) позволяют пользователям перенести стоимость вычислений с времени запроса на время вставки, что приводит к более быстрым запросам `SELECT`.

В отличие от транзакционных баз данных, таких как Postgres, материализованное представление в ClickHouse является просто триггером, который выполняет запрос при вставке блоков данных в таблицу. Результат этого запроса вставляется во вторую "целевую" таблицу. Если будут вставлены дополнительные строки, результаты вновь будут отправлены в целевую таблицу, где промежуточные результаты будут обновлены и объединены. Этот объединенный результат является эквивалентом выполнения запроса над всеми исходными данными.

Основная мотивация материализованных представлений заключается в том, что результаты, вставляемые в целевую таблицу, представляют собой результаты агрегации, фильтрации или преобразования строк. Эти результаты часто будут менее объемным представлением исходных данных (частичной выборкой в случае агрегаций). Это, наряду с тем, что запрос для чтения результатов из целевой таблицы является простым, обеспечивает более быстрое время запроса, чем если бы то же вычисление выполнялось над исходными данными, перемещая вычисления (и, следовательно, задержку запроса) с времени запроса на время вставки.

Материализованные представления в ClickHouse обновляются в реальном времени по мере того, как данные поступают в таблицу, на основе которой они построены, функционируя больше как постоянно обновляемые индексы. Это отличается от других баз данных, где материализованные представления обычно являются статическими снимками запроса, которые необходимо обновлять (аналогично [обновляемым материализованным представлениям](/sql-reference/statements/create/view#refreshable-materialized-view) ClickHouse).

<Image img={materializedViewDiagram} size="md" alt="Диаграмма материализованного представления"/>

## Пример {#example}

Предположим, мы хотим получить количество положительных и отрицательных голосов за пост в день.

```sql
CREATE TABLE votes
(
    `Id` UInt32,
    `PostId` Int32,
    `VoteTypeId` UInt8,
    `CreationDate` DateTime64(3, 'UTC'),
    `UserId` Int32,
    `BountyAmount` UInt8
)
ENGINE = MergeTree
ORDER BY (VoteTypeId, CreationDate, PostId)

INSERT INTO votes SELECT * FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/votes/*.parquet')

0 rows in set. Elapsed: 29.359 sec. Processed 238.98 million rows, 2.13 GB (8.14 million rows/s., 72.45 MB/s.)
```

Это довольно простой запрос в ClickHouse благодаря функции [`toStartOfDay`](/sql-reference/functions/date-time-functions#tostartofday):

```sql
SELECT toStartOfDay(CreationDate) AS day,
       countIf(VoteTypeId = 2) AS UpVotes,
       countIf(VoteTypeId = 3) AS DownVotes
FROM votes
GROUP BY day
ORDER BY day ASC
LIMIT 10

┌─────────────────day─┬─UpVotes─┬─DownVotes─┐
│ 2008-07-31 00:00:00 │       6 │         0 │
│ 2008-08-01 00:00:00 │     182 │        50 │
│ 2008-08-02 00:00:00 │     436 │       107 │
│ 2008-08-03 00:00:00 │     564 │       100 │
│ 2008-08-04 00:00:00 │    1306 │       259 │
│ 2008-08-05 00:00:00 │    1368 │       269 │
│ 2008-08-06 00:00:00 │    1701 │       211 │
│ 2008-08-07 00:00:00 │    1544 │       211 │
│ 2008-08-08 00:00:00 │    1241 │       212 │
│ 2008-08-09 00:00:00 │     576 │        46 │
└─────────────────────┴─────────┴───────────┘

10 rows in set. Elapsed: 0.133 sec. Processed 238.98 million rows, 2.15 GB (1.79 billion rows/s., 16.14 GB/s.)
Peak memory usage: 363.22 MiB.
```

Этот запрос уже быстрый благодаря ClickHouse, но можем ли мы сделать лучше?

Если мы хотим вычислить это во время вставки, используя материализованное представление, нам нужна таблица для получения результатов. Эта таблица должна сохранять только 1 строку на день. Если будет получено обновление для существующего дня, другие столбцы должны быть объединены в строку дня. Для того чтобы эта агрегация инкрементальных состояний произошла, промежуточные состояния должны храниться для других столбцов.

Для этого требуется специальный тип движка в ClickHouse: [SummingMergeTree](/engines/table-engines/mergetree-family/summingmergetree). Этот движок заменяет все строки с одинаковым ключом упорядочивания одной строкой, содержащей суммированные значения для числовых столбцов. Следующая таблица объединит любые строки с одной и той же датой, суммируя любые числовые столбцы:

```sql
CREATE TABLE up_down_votes_per_day
(
  `Day` Date,
  `UpVotes` UInt32,
  `DownVotes` UInt32
)
ENGINE = SummingMergeTree
ORDER BY Day
```

Чтобы продемонстрировать наше материализованное представление, предположим, что наша таблица голосов пуста и еще не получила никаких данных. Наше материализованное представление выполняет указанный выше `SELECT` на данных, вставленных в `votes`, с результатами, отправленными в `up_down_votes_per_day`:

```sql
CREATE MATERIALIZED VIEW up_down_votes_per_day_mv TO up_down_votes_per_day AS
SELECT toStartOfDay(CreationDate)::Date AS Day,
       countIf(VoteTypeId = 2) AS UpVotes,
       countIf(VoteTypeId = 3) AS DownVotes
FROM votes
GROUP BY Day
```

Ключевым здесь является CLAUSE `TO`, обозначающий, куда будут отправлены результаты, т.е. `up_down_votes_per_day`.

Теперь мы можем заново заполнить нашу таблицу голосов с помощью раннего вставки:

```sql
INSERT INTO votes SELECT toUInt32(Id) AS Id, toInt32(PostId) AS PostId, VoteTypeId, CreationDate, UserId, BountyAmount
FROM s3('https://datasets-documentation.s3.eu-west-3.amazonaws.com/stackoverflow/parquet/votes/*.parquet')

0 rows in set. Elapsed: 111.964 sec. Processed 477.97 million rows, 3.89 GB (4.27 million rows/s., 34.71 MB/s.)
Peak memory usage: 283.49 MiB.
```

По завершении, мы можем подтвердить размер нашего `up_down_votes_per_day` - у нас должно быть 1 строка на день:

```sql
SELECT count()
FROM up_down_votes_per_day
FINAL

┌─count()─┐
│    5723 │
└─────────┘
```

Мы тем самым эффективно снизили количество строк здесь с 238 миллионов (в `votes`) до 5000 за счет хранения результата нашего запроса. Ключевым здесь, однако, является то, что если новые голоса будут вставлены в таблицу `votes`, новые значения будут отправлены в `up_down_votes_per_day` для соответствующего дня, где они автоматически будут асинхронно объединены в фоновом режиме - сохраняя только одну строку на день. Таким образом, `up_down_votes_per_day` всегда будет как маленьким, так и актуальным.

Поскольку объединение строк происходит асинхронно, может быть больше одного голоса за день, когда пользователь выполняет запрос. Чтобы обеспечить объединение любых ожидающих строк во время запроса, у нас есть два варианта:

- Использовать модификатор `FINAL` в имени таблицы. Мы сделали это для запроса счётчика выше.
- Агрегировать по ключу упорядочивания, используемому в нашей финальной таблице, т.е. `CreationDate` и суммировать метрики. Обычно это более эффективно и гибко (таблицу можно использовать для других целей), но первый вариант может быть проще для некоторых запросов. Мы показываем оба ниже:

```sql
SELECT
        Day,
        UpVotes,
        DownVotes
FROM up_down_votes_per_day
FINAL
ORDER BY Day ASC
LIMIT 10

10 rows in set. Elapsed: 0.004 sec. Processed 8.97 thousand rows, 89.68 KB (2.09 million rows/s., 20.89 MB/s.)
Peak memory usage: 289.75 KiB.

SELECT Day, sum(UpVotes) AS UpVotes, sum(DownVotes) AS DownVotes
FROM up_down_votes_per_day
GROUP BY Day
ORDER BY Day ASC
LIMIT 10
┌────────Day─┬─UpVotes─┬─DownVotes─┐
│ 2008-07-31 │       6 │         0 │
│ 2008-08-01 │     182 │        50 │
│ 2008-08-02 │     436 │       107 │
│ 2008-08-03 │     564 │       100 │
│ 2008-08-04 │    1306 │       259 │
│ 2008-08-05 │    1368 │       269 │
│ 2008-08-06 │    1701 │       211 │
│ 2008-08-07 │    1544 │       211 │
│ 2008-08-08 │    1241 │       212 │
│ 2008-08-09 │     576 │        46 │
└────────────┴─────────┴───────────┘

10 rows in set. Elapsed: 0.010 sec. Processed 8.97 thousand rows, 89.68 KB (907.32 thousand rows/s., 9.07 MB/s.)
Peak memory usage: 567.61 KiB.
```

Это ускорило наш запрос с 0.133с до 0.004с – более чем 25-кратное улучшение!

:::important Важно: `ORDER BY` = `GROUP BY`
В большинстве случаев столбцы, используемые в предложении `GROUP BY` преобразования материализованных представлений, должны соответствовать тем, которые используются в предложении `ORDER BY` целевой таблицы, если используются движки таблиц `SummingMergeTree` или `AggregatingMergeTree`. Эти движки полагаются на столбцы `ORDER BY`, чтобы объединять строки с идентичными значениями во время фоновых операций объединения. Несоответствие между столбцами `GROUP BY` и `ORDER BY` может привести к неэффективной производительности запросов, не оптимальным объединениям или даже к несоответствиям данных.
:::

### Более сложный пример {#a-more-complex-example}

Приведенный выше пример использует материализованные представления для вычисления и поддержания двух сумм за день. Суммы представляют собой самую простую форму агрегации, для которой можно поддерживать частичные состояния - мы можем просто добавлять новые значения к существующим значениям, когда они приходят. Однако материализованные представления ClickHouse могут использоваться для любого типа агрегации.

Предположим, мы хотим вычислить некоторые статистические данные для постов за каждый день: 99.9-й процентиль для `Score` и среднее значение `CommentCount`. Запрос для вычисления этого может выглядеть так:

```sql
SELECT
        toStartOfDay(CreationDate) AS Day,
        quantile(0.999)(Score) AS Score_99th,
        avg(CommentCount) AS AvgCommentCount
FROM posts
GROUP BY Day
ORDER BY Day DESC
LIMIT 10

    ┌─────────────────Day─┬────────Score_99th─┬────AvgCommentCount─┐
 1. │ 2024-03-31 00:00:00 │  5.23700000000008 │ 1.3429811866859624 │
 2. │ 2024-03-30 00:00:00 │                 5 │ 1.3097158891616976 │
 3. │ 2024-03-29 00:00:00 │  5.78899999999976 │ 1.2827635327635327 │
 4. │ 2024-03-28 00:00:00 │                 7 │  1.277746158224246 │
 5. │ 2024-03-27 00:00:00 │ 5.738999999999578 │ 1.2113264918282023 │
 6. │ 2024-03-26 00:00:00 │                 6 │ 1.3097536945812809 │
 7. │ 2024-03-25 00:00:00 │                 6 │ 1.2836721018539201 │
 8. │ 2024-03-24 00:00:00 │ 5.278999999999996 │ 1.2931667891256429 │
 9. │ 2024-03-23 00:00:00 │ 6.253000000000156 │  1.334061135371179 │
10. │ 2024-03-22 00:00:00 │ 9.310999999999694 │ 1.2388059701492538 │
    └─────────────────────┴───────────────────┴────────────────────┘

10 rows in set. Elapsed: 0.113 sec. Processed 59.82 million rows, 777.65 MB (528.48 million rows/s., 6.87 GB/s.)
Peak memory usage: 658.84 MiB.
```

Как и раньше, мы можем создать материализованное представление, которое выполняет указанный выше запрос при вставке новых постов в нашу таблицу `posts`.

В целях примера, и чтобы избежать загрузки данных постов из S3, мы создадим дубликат таблицы `posts_null` с той же схемой, что и `posts`. Однако эта таблица не будет хранить никаких данных и будет просто использоваться материализованным представлением, когда строки вставляются. Чтобы предотвратить хранение данных, мы можем использовать тип движка таблицы [`Null`](/engines/table-engines/special/null).

```sql
CREATE TABLE posts_null AS posts ENGINE = Null
```

Движок таблицы Null является мощной оптимизацией - думайте об этом как о `/dev/null`. Наше материализованное представление будет вычислять и хранить наши сводные статистики, когда в таблицу `posts_null` будут поступать строки при вставке - это просто триггер. Однако сырье не будет храниться. Хотя в нашем случае мы, вероятно, все еще хотим хранить оригинальные посты, этот подход можно использовать для вычисления агрегатов, избегая затрат на хранение сырьевых данных.

Таким образом, материализованное представление становится следующим:

```sql
CREATE MATERIALIZED VIEW post_stats_mv TO post_stats_per_day AS
       SELECT toStartOfDay(CreationDate) AS Day,
       quantileState(0.999)(Score) AS Score_quantiles,
       avgState(CommentCount) AS AvgCommentCount
FROM posts_null
GROUP BY Day
```

Обратите внимание, что мы добавляем суффикс `State` к концу наших агрегатных функций. Это гарантирует, что возвращается агрегатное состояние функции, а не окончательный результат. Это будет содержать дополнительную информацию, чтобы позволить этому частичному состоянию объединиться с другими состояниями. Например, в случае среднего значения это будет включать количество и сумму столбца.

> Частичные состояния агрегации необходимы для получения корректных результатов. Например, при вычислении среднего значение простым усреднением средних значений поддиапазонов производит некорректные результаты.

Теперь мы создаем целевую таблицу для этого представления `post_stats_per_day`, которая хранит эти частичные состояния агрегатов:

```sql
CREATE TABLE post_stats_per_day
(
  `Day` Date,
  `Score_quantiles` AggregateFunction(quantile(0.999), Int32),
  `AvgCommentCount` AggregateFunction(avg, UInt8)
)
ENGINE = AggregatingMergeTree
ORDER BY Day
```

Хотя ранее `SummingMergeTree` был достаточен для хранения количества, нам требуется более продвинутый тип движка для других функций: [`AggregatingMergeTree`](/engines/table-engines/mergetree-family/aggregatingmergetree).
Чтобы обеспечить ClickHouse, что будут храниться агрегатные состояния, мы определяем `Score_quantiles` и `AvgCommentCount` как тип `AggregateFunction`, указывая функцию-источник частичных состояний и тип их исходных столбцов. Как и в случае с `SummingMergeTree`, строки с одинаковым значением ключа `ORDER BY` будут объединены (`Day` в приведенном примере).

Чтобы заполнить нашу `post_stats_per_day` через наше материализованное представление, мы можем просто вставить все строки из `posts` в `posts_null`:

```sql
INSERT INTO posts_null SELECT * FROM posts

0 rows in set. Elapsed: 13.329 sec. Processed 119.64 million rows, 76.99 GB (8.98 million rows/s., 5.78 GB/s.)
```

> На практике вы, вероятно, прикрепите материализованное представление к таблице `posts`. Мы использовали `posts_null` здесь для демонстрации нулевой таблицы.

Наш окончательный запрос должен использовать суффикс `Merge` для наших функций (так как столбцы хранят частичные состояния агрегации):

```sql
SELECT
        Day,
        quantileMerge(0.999)(Score_quantiles),
        avgMerge(AvgCommentCount)
FROM post_stats_per_day
GROUP BY Day
ORDER BY Day DESC
LIMIT 10
```

Обратите внимание, что мы используем `GROUP BY` здесь вместо использования `FINAL`.

## Использование исходной таблицы в фильтрах и соединениях в материализованных представлениях {#using-source-table-in-filters-and-joins-in-materialized-views}

При работе с материализованными представлениями в ClickHouse важно понимать, как исходная таблица обрабатывается во время выполнения запроса к материализованному представлению. В частности, исходная таблица в запросе к материализованному представлению заменяется вставленным блоком данных. Это поведение может привести к неожиданным результатам, если его не понять должным образом.

### Пример сценария {#example-scenario}

Рассмотрим следующую настройку:

```sql
CREATE TABLE t0 (`c0` Int) ENGINE = Memory;
CREATE TABLE mvw1_inner (`c0` Int) ENGINE = Memory;
CREATE TABLE mvw2_inner (`c0` Int) ENGINE = Memory;

CREATE VIEW vt0 AS SELECT * FROM t0;

CREATE MATERIALIZED VIEW mvw1 TO mvw1_inner
AS SELECT count(*) AS c0
    FROM t0
    LEFT JOIN ( SELECT * FROM t0 ) AS x ON t0.c0 = x.c0;

CREATE MATERIALIZED VIEW mvw2 TO mvw2_inner
AS SELECT count(*) AS c0
    FROM t0
    LEFT JOIN vt0 ON t0.c0 = vt0.c0;

INSERT INTO t0 VALUES (1),(2),(3);

INSERT INTO t0 VALUES (1),(2),(3),(4),(5);

SELECT * FROM mvw1;
   ┌─c0─┐
1. │  3 │
2. │  5 │
   └────┘

SELECT * FROM mvw2;
   ┌─c0─┐
1. │  3 │
2. │  8 │
   └────┘
```

### Объяснение {#explanation}

В приведенном выше примере у нас есть два материализованных представления `mvw1` и `mvw2`, которые выполняют похожие операции, но с небольшим различием в том, как они ссылаются на исходную таблицу `t0`.

В `mvw1` таблица `t0` ссылается непосредственно внутри подзапроса `(SELECT * FROM t0)` с правой стороны от JOIN. Когда данные вставляются в `t0`, запрос к материализованному представлению выполняется с вставленным блоком данных, заменяющим `t0`. Это означает, что операция соединения выполняется только над вновь вставленными строками, а не над всей таблицей.

Во втором случае с присоединением к `vt0` представление считывает все данные из `t0`. Это гарантирует, что операция соединения учитывает все строки в `t0`, а не только вновь вставленный блок.

### Почему это работает именно так {#why-this-works-like-that}

Ключевое различие заключается в том, как ClickHouse обрабатывает исходную таблицу в запросе к материализованному представлению. Когда материализованное представление срабатывает по вставке, исходная таблица (в данном случае `t0`) заменяется вставленным блоком данных. Это поведение может быть использовано для оптимизации запросов, но также требует внимательного рассмотрения, чтобы избежать неожиданных результатов.

### Сценарии использования и предостережения {#use-cases-and-caveats}

На практике вы можете использовать это поведение для оптимизации материализованных представлений, которым нужно обрабатывать только подмножество данных исходной таблицы. Например, вы можете использовать подзапрос для фильтрации исходной таблицы, прежде чем объединить ее с другими таблицами. Это может помочь уменьшить объем данных, обрабатываемых материализованным представлением, и улучшить производительность.

```sql
CREATE TABLE t0 (id UInt32, value String) ENGINE = MergeTree() ORDER BY id;
CREATE TABLE t1 (id UInt32, description String) ENGINE = MergeTree() ORDER BY id;
INSERT INTO t1 VALUES (1, 'A'), (2, 'B'), (3, 'C');

CREATE TABLE mvw1_target_table (id UInt32, value String, description String) ENGINE = MergeTree() ORDER BY id;

CREATE MATERIALIZED VIEW mvw1 TO mvw1_target_table AS
SELECT t0.id, t0.value, t1.description
FROM t0
JOIN (SELECT * FROM t1 WHERE t1.id IN (SELECT id FROM t0)) AS t1
ON t0.id = t1.id;
```

В этом примере набор для построения из подзапроса `IN (SELECT id FROM t0)` содержит только вновь вставленные строки, что может помочь отфильтровать `t1` по этому критерию.

## Другие применения {#other-applications}

Вышеописанное преимущественно сосредоточено на использовании материализованных представлений для инкрементного обновления частичных агрегатов данных, перенаправляя вычисления с времени запроса на время вставки. За рамками этого распространенного сценария у материализованных представлений есть ряд других применений.

### Фильтрация и преобразование {#filtering-and-transformation}

В некоторых ситуациях мы можем пожелать вставить только подмножество строк и столбцов при вставке. В этом случае наша таблица `posts_null` может получать вставки, с помощью запроса `SELECT`, который фильтрует строки перед вставкой в таблицу `posts`. Например, предположим, что мы хотели бы преобразовать столбец `Tags` в нашей таблице `posts`. Это содержит список имён тегов, разделённых символами "pipe". Преобразовав их в массив, мы сможем легче агрегировать по индивидуальным значениям тегов.

> Мы могли бы выполнить это преобразование при выполнении `INSERT INTO SELECT`. Материализованное представление позволяет нам инкапсулировать эту логику в DDL ClickHouse и упростить наш `INSERT`, применив преобразование к любым новым строкам.

Наше материализованное представление для этого преобразования показано ниже:

```sql
CREATE MATERIALIZED VIEW posts_mv TO posts AS
        SELECT * EXCEPT Tags, arrayFilter(t -> (t != ''), splitByChar('|', Tags)) as Tags FROM posts_null
```

### Таблица соответствий {#lookup-table}

Пользователи должны учитывать свои шаблоны доступа при выборе ключа упорядочивания ClickHouse, где используются столбцы, которые часто применяются в фильтрах и агрегирующих выражениях. Это может быть ограничивающим для сценариев, где пользователи имеют более разнообразные шаблоны доступа, которые не могут быть инкапсулированы в одном наборе столбцов. Например, рассмотрим следующую таблицу `comments`:

```sql
CREATE TABLE comments
(
        `Id` UInt32,
        `PostId` UInt32,
        `Score` UInt16,
        `Text` String,
        `CreationDate` DateTime64(3, 'UTC'),
        `UserId` Int32,
        `UserDisplayName` LowCardinality(String)
)
ENGINE = MergeTree
ORDER BY PostId

0 rows in set. Elapsed: 46.357 sec. Processed 90.38 million rows, 11.14 GB (1.95 million rows/s., 240.22 MB/s.)
```

Ключ упорядочивания здесь оптимизирует таблицу для запросов, фильтрующих по `PostId`.

Предположим, пользователь хочет отфильтровать по конкретному `UserId` и вычислить их средний `Score`:

```sql
SELECT avg(Score)
FROM comments
WHERE UserId = 8592047

   ┌──────────avg(Score)─┐
1. │ 0.18181818181818182 │
   └─────────────────────┘

1 row in set. Elapsed: 0.778 sec. Processed 90.38 million rows, 361.59 MB (116.16 million rows/s., 464.74 MB/s.)
Peak memory usage: 217.08 MiB.
```

Хотя это быстро (данные малы для ClickHouse), мы можем сказать, что это требует полного сканирования таблицы по количеству обработанных строк - 90.38 миллиона. Для больших наборов данных мы можем использовать материализованное представление для поиска значений нашего ключа упорядочивания `PostId` для фильтрации столбца `UserId`. Эти значения затем могут быть использованы для выполнения эффективного поиска.

В этом примере наше материализованное представление может быть очень простым, выбирая только `PostId` и `UserId` из `comments` при вставке. Эти результаты затем отправляются в таблицу `comments_posts_users`, которая упорядочена по `UserId`. Мы создаем нулевую версию таблицы `Comments` ниже и используем это для заполнения нашего представления и таблицы `comments_posts_users`:

```sql
CREATE TABLE comments_posts_users (
  PostId UInt32,
  UserId Int32
) ENGINE = MergeTree ORDER BY UserId


CREATE TABLE comments_null AS comments
ENGINE = Null

CREATE MATERIALIZED VIEW comments_posts_users_mv TO comments_posts_users AS
SELECT PostId, UserId FROM comments_null

INSERT INTO comments_null SELECT * FROM comments

0 rows in set. Elapsed: 5.163 sec. Processed 90.38 million rows, 17.25 GB (17.51 million rows/s., 3.34 GB/s.)
```

Теперь мы можем использовать это представление в подзапросе для ускорения нашего предыдущего запроса:

```sql
SELECT avg(Score)
FROM comments
WHERE PostId IN (
        SELECT PostId
        FROM comments_posts_users
        WHERE UserId = 8592047
) AND UserId = 8592047


   ┌──────────avg(Score)─┐
1. │ 0.18181818181818182 │
   └─────────────────────┘

1 row in set. Elapsed: 0.012 sec. Processed 88.61 thousand rows, 771.37 KB (7.09 million rows/s., 61.73 MB/s.)
```

### Цепочка {#chaining}

Материализованные представления могут быть связаны друг с другом, что позволяет устанавливать сложные рабочие процессы. Для практического примера мы рекомендуем этот [блог](https://clickhouse.com/blog/chaining-materialized-views).
