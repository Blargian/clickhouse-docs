---
description: 'Документация для функций массива'
sidebar_label: 'Массивы'
sidebar_position: 10
slug: /sql-reference/functions/array-functions
title: 'Функции массива'
---

# Функции массива
## empty {#empty}

Проверяет, является ли входной массив пустым.

**Синтаксис**

```sql
empty([x])
```

Массив считается пустым, если он не содержит элементов.

:::note
Может быть оптимизирован, если включить [`optimize_functions_to_subcolumns` настройку](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подколонку [size0](/sql-reference/data-types/array#array-size), вместо того чтобы читать и обрабатывать всю колонку массива. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для [строк](string-functions.md#empty) или [UUID](uuid-functions.md#empty).

**Аргументы**

- `[x]` — Входной массив. [Array](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для пустого массива или `0` для непустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT empty([]);
```

Результат:

```text
┌─empty(array())─┐
│              1 │
└────────────────┘
```
## notEmpty {#notempty}

Проверяет, является ли входной массив непустым.

**Синтаксис**

```sql
notEmpty([x])
```

Массив считается непустым, если он содержит хотя бы один элемент.

:::note
Может быть оптимизирован, если включить [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns) настройку. При `optimize_functions_to_subcolumns = 1` функция читает только подколонку [size0](/sql-reference/data-types/array#array-size), вместо того чтобы читать и обрабатывать всю колонку массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для [строк](string-functions.md#notempty) или [UUID](uuid-functions.md#notempty).

**Аргументы**

- `[x]` — Входной массив. [Array](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для непустого массива или `0` для пустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT notEmpty([1,2]);
```

Результат:

```text
┌─notEmpty([1, 2])─┐
│                1 │
└──────────────────┘
```
## length {#length}

Возвращает количество элементов в массиве.
Тип результата — UInt64.
Функция также работает для строк.

Может быть оптимизирован, если включить [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns) настройку. При `optimize_functions_to_subcolumns = 1` функция читает только подколонку [size0](/sql-reference/data-types/array#array-size), вместо того чтобы читать и обрабатывать всю колонку массива. Запрос `SELECT length(arr) FROM table` преобразуется в `SELECT arr.size0 FROM TABLE`.

Псевдоним: `OCTET_LENGTH`
## emptyArrayUInt8 {#emptyarrayuint8}

Возвращает пустой массив UInt8.

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt8();
```

Результат:

```response
[]
```
## emptyArrayUInt16 {#emptyarrayuint16}

Возвращает пустой массив UInt16.

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt16();

```

Результат:

```response
[]
```
## emptyArrayUInt32 {#emptyarrayuint32}

Возвращает пустой массив UInt32.

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt32();
```

Результат:

```response
[]
```
## emptyArrayUInt64 {#emptyarrayuint64}

Возвращает пустой массив UInt64.

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt64();
```

Результат:

```response
[]
```
## emptyArrayInt8 {#emptyarrayint8}

Возвращает пустой массив Int8.

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt8();
```

Результат:

```response
[]
```
## emptyArrayInt16 {#emptyarrayint16}

Возвращает пустой массив Int16.

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt16();
```

Результат:

```response
[]
```
## emptyArrayInt32 {#emptyarrayint32}

Возвращает пустой массив Int32.

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt32();
```

Результат:

```response
[]
```
## emptyArrayInt64 {#emptyarrayint64}

Возвращает пустой массив Int64.

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt64();
```

Результат:

```response
[]
```
## emptyArrayFloat32 {#emptyarrayfloat32}

Возвращает пустой массив Float32.

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat32();
```

Результат:

```response
[]
```
## emptyArrayFloat64 {#emptyarrayfloat64}

Возвращает пустой массив Float64.

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat64();
```

Результат:

```response
[]
```
## emptyArrayDate {#emptyarraydate}

Возвращает пустой массив Date.

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDate();
```
## emptyArrayDateTime {#emptyarraydatetime}

Возвращает пустой массив DateTime.

**Синтаксис**

```sql
[]
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDateTime();
```

Результат:

```response
[]
```
## emptyArrayString {#emptyarraystring}

Возвращает пустой массив String.

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayString();
```

Результат:

```response
[]
```
## emptyArrayToSingle {#emptyarraytosingle}

Принимает пустой массив и возвращает массив с одним элементом, который равен значению по умолчанию.
## range(end), range(\[start, \] end \[, step\]) {#rangeend-rangestart--end--step}

Возвращает массив чисел от `start` до `end - 1` с шагом `step`. Поддерживаемые типы: [UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64](../data-types/int-uint.md).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

- `start` — Первый элемент массива. Необязательный, обязательный, если используется `step`. Значение по умолчанию: 0.
- `end` — Число, перед которым создается массив. Обязательный.
- `step` — Определяет шаг инкремента между каждым элементом в массиве. Необязательный. Значение по умолчанию: 1.

**Возвращаемое значение**

- Массив чисел от `start` до `end - 1` с шагом `step`.

**Детали реализации**

- Все аргументы `start`, `end`, `step` должны быть ниже следующих типов: `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`, а также элементы возвращаемого массива, тип которого является суперклассом всех аргументов.
- Исключение выбрасывается, если запрос возвращает массивы с общей длиной, превышающей количество элементов, указанное настройкой [function_range_max_elements_in_block](../../operations/settings/settings.md#function_range_max_elements_in_block).
- Возвращает Null, если любой из аргументов имеет тип Nullable(Nothing). Исключение выбрасывается, если любой из аргументов имеет значение Null (Nullable(T) тип).

**Примеры**

Запрос:

```sql
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

Результат:

```txt
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```
## array(x1, ...), оператор \[x1, ...\] {#arrayx1--operator-x1-}

Создает массив из аргументов функции.
Аргументы должны быть константами и иметь типы с наименьшим общим типом. Должен быть передан хотя бы один аргумент, поскольку в противном случае неясно, какой тип массива создать. То есть, вы не можете использовать эту функцию для создания пустого массива (для этого воспользуйтесь функцией 'emptyArray*', описанной выше).
Возвращает результат типа 'Array(T)', где 'T' — наименьший общий тип среди переданных аргументов.
## arrayWithConstant(length, elem) {#arraywithconstantlength-elem}

Создает массив длиной `length`, заполненный константой `elem`.
## arrayConcat {#arrayconcat}

Объединяет массивы, переданные в качестве аргументов.

```sql
arrayConcat(arrays)
```

**Аргументы**

- `arrays` – Произвольное количество аргументов типа [Array](/sql-reference/data-types/array).

**Пример**

```sql
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```text
┌─res───────────┐
│ [1,2,3,4,5,6] │
└───────────────┘
```
## arrayElement(arr, n), оператор arr\[n\] {#arrayelementarr-n-operator-arrn}

Получает элемент с индексом `n` из массива `arr`. `n` может быть любого целочисленного типа.
Индексы в массиве начинаются с одного.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, номер которого считается с конца. Например, `arr[-1]` — это последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается некоторое значение по умолчанию (0 для чисел, пустая строка для строк и т. д.), за исключением случая с не константным массивом и константным индексом 0 (в этом случае будет ошибка `Индексы массива начинаются с 1`).
## has(arr, elem) {#hasarr-elem}

Проверяет, содержит ли массив 'arr' элемент 'elem'.
Возвращает 0, если элемент не в массиве, или 1, если он есть.

`NULL` обрабатывается как значение.

```sql
SELECT has([1, 2, NULL], NULL)
```

```text
┌─has([1, 2, NULL], NULL)─┐
│                       1 │
└─────────────────────────┘
```
## arrayElementOrNull(arr, n) {#arrayelementornullarr-n}

Получает элемент с индексом `n` из массива `arr`. `n` может быть любого целочисленного типа.
Индексы в массиве начинаются с одного.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, номер которого считается с конца. Например, `arr[-1]` — это последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается `NULL` вместо значения по умолчанию.
### Примеры {#examples}

```sql
SELECT arrayElementOrNull([1, 2, 3], 2), arrayElementOrNull([1, 2, 3], 4)
```

```text
 ┌─arrayElementOrNull([1, 2, 3], 2)─┬─arrayElementOrNull([1, 2, 3], 4)─┐
 │                                2 │                             ᴺᵁᴸᴸ │
 └──────────────────────────────────┴──────────────────────────────────┘
```
## hasAll {#hasall}

Проверяет, является ли один массив подмножеством другого.

```sql
hasAll(set, subset)
```

**Аргументы**

- `set` – Массив любого типа с набором элементов.
- `subset` – Массив любого типа, который делит общий суперкласс с `set`, содержащий элементы, которые должны быть проверены как подмножество `set`.

**Возвращаемые значения**

- `1`, если `set` содержит все элементы из `subset`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы set и subset не делят общий суперкласс.

**Особые свойства**

- Пустой массив является подмножеством любого массива.
- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAll([], [])` возвращает 1.

`SELECT hasAll([1, Null], [Null])` возвращает 1.

`SELECT hasAll([1.0, 2, 3, 4], [1, 3])` возвращает 1.

`SELECT hasAll(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasAll([1], ['a'])` вызывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])` возвращает 0.
## hasAny {#hasany}

Проверяет, имеют ли два массива пересечения хотя бы по некоторым элементам.

```sql
hasAny(array1, array2)
```

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа, который делит общий суперкласс с `array1`.

**Возвращаемые значения**

- `1`, если `array1` и `array2` имеют хотя бы один общий элемент.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы array1 и array2 не делят общий суперкласс.

**Особые свойства**

- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAny([1], [])` возвращает `0`.

`SELECT hasAny([Null], [Null, 1])` возвращает `1`.

`SELECT hasAny([-128, 1., 512], [1])` возвращает `1`.

`SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])` вызывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])` возвращает `1`.
## hasSubstr {#hassubstr}

Проверяет, появляются ли все элементы array2 в array1 в том же точном порядке. Поэтому функция вернет 1, если и только если `array1 = префикс + array2 + суффикс`.

```sql
hasSubstr(array1, array2)
```

Другими словами, функции проверяют, содержатся ли все элементы `array2` в `array1`, как функция `hasAll`. В дополнение, она проверяет, что элементы наблюдаются в том же порядке в обоих `array1` и `array2`.

Например:

- `hasSubstr([1,2,3,4], [2,3])` возвращает 1. Однако, `hasSubstr([1,2,3,4], [3,2])` вернет `0`.
- `hasSubstr([1,2,3,4], [1,2,3])` возвращает 1. Однако, `hasSubstr([1,2,3,4], [1,2,4])` вернет `0`.

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа с набором элементов.

**Возвращаемые значения**

- `1`, если `array1` содержит `array2`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы array1 и array2 не делят общий суперкласс.

**Особые свойства**

- Функция вернет `1`, если `array2` пустой.
- `Null` обрабатывается как значение. Другими словами `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернет `0`. Однако, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернет `1`.
- Порядок значений в обоих массивах имеет значение.

**Примеры**

`SELECT hasSubstr([], [])` возвращает 1.

`SELECT hasSubstr([1, Null], [Null])` возвращает 1.

`SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])` возвращает 0.

`SELECT hasSubstr(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])` возвращает 0.

`SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])` возвращает 1.
`SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])` вызывает исключение `NO_COMMON_TYPE`.
## indexOf(arr, x) {#indexofarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он находится в массиве.
Если массив не содержит искомое значение, функция возвращает 0.

Пример:

```sql
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```text
┌─indexOf([1, 3, NULL, NULL], NULL)─┐
│                                 3 │
└───────────────────────────────────┘
```

Элементы, установленные в `NULL`, обрабатываются как обычные значения.
## indexOfAssumeSorted(arr, x) {#indexofassumesortedarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он находится в массиве.
Если массив не содержит искомое значение, функция возвращает 0.
Предполагает, что массив отсортирован в порядке возрастания (т. е. функция использует бинарный поиск).
Если массив не отсортирован, результаты не определены.
Если внутренний массив имеет тип Nullable, будет вызвана функция 'indexOf'.

Пример:

```sql
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```text
┌─indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)─┐
│                                             5 │
└───────────────────────────────────────────────┘
```
## arrayCount(\[func,\] arr1, ...) {#arraycountfunc-arr1-}

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то иное, чем 0. Если `func` не указана, она возвращает количество ненулевых элементов в массиве.

Обратите внимание, что `arrayCount` является [высшей функцией](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayDotProduct {#arraydotproduct}

Возвращает скалярное произведение двух массивов.

**Синтаксис**

```sql
arrayDotProduct(vector1, vector2)
```

Псевдонимы: `scalarProduct`, `dotProduct`

**Параметры**

- `vector1`: Первый вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.
- `vector2`: Второй вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.

:::note
Размеры двух векторов должны быть равны. Массивы и кортежи также могут содержать смешанные типы элементов.
:::

**Возвращаемое значение**

- Скалярное произведение двух векторов. [Numeric](/native-protocol/columns#numeric-types).

:::note
Тип возвращаемого значения определяется типом аргументов. Если массивы или кортежи содержат смешанные типы элементов, тогда тип результата является суперклассом.
:::

**Примеры**

Запрос:

```sql
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

Результат:

```response
32    UInt16
```

Запрос:

```sql
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

Результат:

```response
32    Float64
```
## countEqual(arr, x) {#countequalarr-x}

Возвращает количество элементов в массиве, равных x. Эквивалентно arrayCount (elem -> elem = x, arr).

Элементы `NULL` обрабатываются как отдельные значения.

Пример:

```sql
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```text
┌─countEqual([1, 2, NULL, NULL], NULL)─┐
│                                    2 │
└──────────────────────────────────────┘
```
## arrayEnumerate(arr) {#arrayenumeratearr}

Возвращает массив \[1, 2, 3, ..., length (arr) \]

Эта функция обычно используется с ARRAY JOIN. Она позволяет считать что-то один раз для каждого массива после применения ARRAY JOIN. Пример:

```sql
SELECT
    count() AS Reaches,
    countIf(num = 1) AS Hits
FROM test.hits
ARRAY JOIN
    GoalsReached,
    arrayEnumerate(GoalsReached) AS num
WHERE CounterID = 160656
LIMIT 10
```

```text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

В этом примере Reaches — это количество конверсий (строки, полученные после применения ARRAY JOIN), а Hits — это количество просмотров страниц (строки до ARRAY JOIN). В этом конкретном случае вы можете получить тот же результат более простым способом:

```sql
SELECT
    sum(length(GoalsReached)) AS Reaches,
    count() AS Hits
FROM test.hits
WHERE (CounterID = 160656) AND notEmpty(GoalsReached)
```

```text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

Эту функцию также можно использовать в высших функциях. Например, вы можете использовать ее для получения индексов массива для элементов, которые соответствуют условию.
## arrayEnumerateUniq {#arrayenumerateuniq}

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента, какова его позиция среди элементов с одинаковым значением.
Например: arrayEnumerateUniq(\[10, 20, 10, 30\]) = \[1, 1, 2, 1\].

Эта функция полезна при использовании ARRAY JOIN и агрегации элементов массива.
Пример:

```sql
SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```text
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```

В этом случае каждый идентификатор цели имеет расчет количества конверсий (каждый элемент в вложенной структуре данных Goals — это цель, которая была достигнута, которую мы называем конверсией) и количество сессий. Без ARRAY JOIN мы бы посчитали количество сессий как sum(Sign). Но в данном конкретном случае строки умножались на вложенную структуру Goals, поэтому для того, чтобы сосчитать каждую сессию один раз после этого, мы применили условие к значению функции arrayEnumerateUniq(Goals.ID).

Функция arrayEnumerateUniq может принимать несколько массивов одинакового размера в качестве аргументов. В этом случае уникальность считается для кортежей элементов на одинаковых позициях во всех массивах.

```sql
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]) AS res
```

```text
┌─res───────────┐
│ [1,2,1,1,2,1] │
└───────────────┘
```

Это необходимо при использовании ARRAY JOIN с вложенной структурой данных и дальнейшей агрегации по нескольким элементам в этой структуре.
## arrayEnumerateUniqRanked {#arrayenumerateuniqranked}

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента, какова его позиция среди элементов с одинаковым значением. Позволяет перечислить многомерный массив с возможностью указать, насколько глубоко нужно заглянуть внутрь массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Перечислить элементы на указанном уровне отдельно. Позитивное [Целое число](../data-types/int-uint.md), меньшее либо равное `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Array](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Позитивное [Целое число](../data-types/int-uint.md), меньшее или равное глубине `arr`.

**Пример**

При `clear_depth=1` и `max_array_depth=1` результат `arrayEnumerateUniqRanked` идентичен тому, который даст [`arrayEnumerateUniq`](#arrayenumerateuniq) для того же массива.

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(1, [1,2,1], 1);
```

Результат:

```text
[1,1,2]
```

В этом примере `arrayEnumerateUniqRanked` используется для получения массива, указывающего для каждого элемента многомерного массива, какова его позиция среди элементов одного и того же значения. Для первой строки переданного массива `[1,2,3]` соответствующий результат — `[1,1,1]`, указывающий на то, что это первый раз, когда появляются `1`, `2` и `3`. Для второй строки предоставленного массива `[2,2,1]` соответствующий результат — `[2,3,3]`, указывающий на то, что `2` встречается во второй и третий раз, а `1` встречается во второй раз. Таким образом, для третьей строки предоставленного массива `[3]` соответствующий результат — `[2]`, указывающий на то, что `3` встречается во второй раз. 

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(1, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

```text
[[1,1,1],[2,3,2],[2]]
```

Изменяя `clear_depth=2`, элементы перечисляются отдельно для каждой строки.

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(2, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

```text
[[1,1,1],[1,2,1],[1]]
```
## arrayPopBack {#arraypopback}

Удаляет последний элемент из массива.

```sql
arrayPopBack(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

```sql
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```text
┌─res───┐
│ [1,2] │
└───────┘
```
## arrayPopFront {#arraypopfront}

Удаляет первый элемент из массива.

```sql
arrayPopFront(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

```sql
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```text
┌─res───┐
│ [2,3] │
└───────┘
```
## arrayPushBack {#arraypushback}

Добавляет один элемент в конец массива.

```sql
arrayPushBack(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Одно значение. В массив с числами можно добавлять только числа, а в массив строк — только строки. При добавлении чисел ClickHouse автоматически устанавливает тип `single_value` для типа данных массива. Для получения дополнительной информации о типах данных в ClickHouse смотрите "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

```sql
SELECT arrayPushBack(['a'], 'b') AS res;
```

```text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayPushFront {#arraypushfront}

Добавляет один элемент в начало массива.

```sql
arrayPushFront(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Одно значение. В массив с числами можно добавлять только числа, а в массив строк — только строки. При добавлении чисел ClickHouse автоматически устанавливает тип `single_value` для типа данных массива. Для получения дополнительной информации о типах данных в ClickHouse смотрите "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

```sql
SELECT arrayPushFront(['b'], 'a') AS res;
```

```text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayResize {#arrayresize}

Изменяет длину массива.

```sql
arrayResize(array, size[, extender])
```

**Аргументы:**

- `array` — Массив.
- `size` — Требуемая длина массива.
  - Если `size` меньше исходного размера массива, массив обрезается с правой стороны.
- Если `size` больше исходного размера массива, массив расширяется вправо значениями `extender` или значениями по умолчанию для типа данных элементов массива.
- `extender` — Значение для расширения массива. Может быть `NULL`.

**Возвращаемое значение:**

Массив длиной `size`.

**Примеры вызовов**

```sql
SELECT arrayResize([1], 3);
```

```text
┌─arrayResize([1], 3)─┐
│ [1,0,0]             │
└─────────────────────┘
```

```sql
SELECT arrayResize([1], 3, NULL);
```

```text
┌─arrayResize([1], 3, NULL)─┐
│ [1,NULL,NULL]             │
└───────────────────────────┘
```
## arraySlice {#arrayslice}

Возвращает срез массива.

```sql
arraySlice(array, offset[, length])
```

**Аргументы**

- `array` – Массив данных.
- `offset` – Сдвиг от края массива. Положительное значение указывает на смещение слева, а отрицательное — на сдвиг справа. Нумерация элементов массива начинается с 1.
- `length` – Длина требуемого среза. Если вы укажете отрицательное значение, функция возвращает открытый срез `[offset, array_length - length]`. Если вы пропустите значение, функция вернет срез `[offset, конец_массива]`.

**Пример**

```sql
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```text
┌─res────────┐
│ [2,NULL,4] │
└────────────┘
```

Элементы массива, установленные в `NULL`, обрабатываются как обычные значения.
## arrayShingles {#arrayshingles}

Генерирует массив "шинглов", т. е. последовательных подмассивов с заданной длиной входного массива.

**Синтаксис**

```sql
arrayShingles(array, length)
```

**Аргументы**

- `array` — Входной массив [Array](/sql-reference/data-types/array).
- `length` — Длина каждого шингла.

**Возвращаемое значение**

- Массив сгенерированных шинглов. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShingles([1,2,3,4], 3) as res;
```

Результат:

```text
┌─res───────────────┐
│ [[1,2,3],[2,3,4]] │
└───────────────────┘
```
## arraySort(\[func,\] arr, ...) {#sort}

Сортирует элементы массива `arr` в порядке возрастания. Если указана функция `func`, порядок сортировки определяется результатом функции `func`, примененной к элементам массива. Если `func` принимает несколько аргументов, функции `arraySort` передаются несколько массивов, которые будут соответствовать аргументам `func`. Примеры приведены в конце описания `arraySort`.

Пример сортировки целых чисел:

```sql
SELECT arraySort([1, 3, 3, 0]);
```

```text
┌─arraySort([1, 3, 3, 0])─┐
│ [0,1,3,3]               │
└─────────────────────────┘
```

Пример сортировки строк:

```sql
SELECT arraySort(['hello', 'world', '!']);
```

```text
┌─arraySort(['hello', 'world', '!'])─┐
│ ['!','hello','world']              │
└────────────────────────────────────┘
```

Рассмотрим порядок сортировки для значений `NULL`, `NaN` и `Inf`:

```sql
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```text
┌─arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf])─┐
│ [-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]                     │
└───────────────────────────────────────────────────────────┘
```

- Значения `-Inf` стоят первыми в массиве.
- Значения `NULL` стоят последними в массиве.
- Значения `NaN` стоят прямо перед `NULL`.
- Значения `Inf` стоят прямо перед `NaN`.

Обратите внимание, что `arraySort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента. В этом случае порядок сортировки определяется результатом лямбда-функции, примененной к элементам массива.

Рассмотрим следующий пример:

```sql
SELECT arraySort((x) -> -x, [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [3,2,1] │
└─────────┘
```

Для каждого элемента исходного массива лямбда-функция возвращает ключ сортировки, то есть \[1 –\> -1, 2 –\> -2, 3 –\> -3\]. Поскольку функция `arraySort` сортирует ключи в порядке возрастания, результат будет \[3, 2, 1\]. Таким образом, лямбда-функция `(x) –> -x` устанавливает [убывающий порядок](#arrayreversesort) при сортировке.

Лямбда-функция может принимать несколько аргументов. В этом случае вам нужно передать функции `arraySort` несколько массивов одинаковой длины, которые будут соответствовать аргументам лямбда-функции. Результирующий массив будет состоять из элементов первого входного массива; элементы следующих входных массивов будут определять ключи сортировки. Например:

```sql
SELECT arraySort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

```text
┌─res────────────────┐
│ ['world', 'hello'] │
└────────────────────┘
```

Здесь элементы, переданные во втором массиве (\[2, 1\]), определяют ключ сортировки для соответствующего элемента из исходного массива (\['hello', 'world'\]), то есть \['hello' –\> 2, 'world' –\> 1\]. Поскольку лямбда-функция не использует `x`, фактические значения исходного массива не влияют на порядок в результате. Таким образом, 'hello' будет вторым элементом в результате, а 'world' - первым.

Другие примеры приведены ниже.

```sql
SELECT arraySort((x, y) -> y, [0, 1, 2], ['c', 'b', 'a']) as res;
```

```text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

```sql
SELECT arraySort((x, y) -> -y, [0, 1, 2], [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

:::note
Для повышения эффективности сортировки используется [Шварцианская трансформация](https://en.wikipedia.org/wiki/Schwartzian_transform).
:::

## arrayPartialSort(\[func,\] limit, arr, ...) {#arraypartialsortfunc-limit-arr-}

Тот же, что и `arraySort`, с дополнительным аргументом `limit`, позволяющим частичную сортировку. Возвращает массив такого же размера, как и исходный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке возрастания. Оставшиеся элементы `(limit..N]` будут содержать элементы в неопределенном порядке.

## arrayReverseSort {#arrayreversesort}

Сортирует элементы массива `arr` в порядке убывания. Если указана функция `func`, `arr` сортируется в соответствии с результатом функции `func`, примененной к элементам массива, а затем отсортированный массив инвертируется. Если `func` принимает несколько аргументов, функции `arrayReverseSort` передаются несколько массивов, которые будут соответствовать аргументам `func`. Примеры приведены в конце описания `arrayReverseSort`.

**Синтаксис**

```sql
arrayReverseSort([func,] arr, ...)
```

Пример сортировки целых чисел:

```sql
SELECT arrayReverseSort([1, 3, 3, 0]);
```

```text
┌─arrayReverseSort([1, 3, 3, 0])─┐
│ [3,3,1,0]                      │
└────────────────────────────────┘
```

Пример сортировки строк:

```sql
SELECT arrayReverseSort(['hello', 'world', '!']);
```

```text
┌─arrayReverseSort(['hello', 'world', '!'])─┐
│ ['world','hello','!']                     │
└───────────────────────────────────────────┘
```

Рассмотрим порядок сортировки для значений `NULL`, `NaN` и `Inf`:

```sql
SELECT arrayReverseSort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]) as res;
```

```text
┌─res───────────────────────────────────┐
│ [inf,3,2,1,-4,-inf,nan,nan,NULL,NULL] │
└───────────────────────────────────────┘
```

- Значения `Inf` стоят первыми в массиве.
- Значения `NULL` стоят последними в массиве.
- Значения `NaN` стоят прямо перед `NULL`.
- Значения `-Inf` стоят прямо перед `NaN`.

Обратите внимание, что `arrayReverseSort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента. Пример показан ниже.

```sql
SELECT arrayReverseSort((x) -> -x, [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [1,2,3] │
└─────────┘
```

Массив сортируется следующим образом:

1. Изначально, исходный массив (\[1, 2, 3\]) сортируется в соответствии с результатом лямбда-функции, примененной к элементам массива. Результат – массив \[3, 2, 1\].
2. Массив, полученный на предыдущем шаге, инвертируется. Таким образом, окончательный результат – \[1, 2, 3\].

Лямбда-функция может принимать несколько аргументов. В этом случае вам нужно передать функции `arrayReverseSort` несколько массивов одинаковой длины, которые будут соответствовать аргументам лямбда-функции. Результирующий массив будет состоять из элементов первого входного массива; элементы следующих входных массивов будут определять ключи сортировки. Например:

```sql
SELECT arrayReverseSort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

```text
┌─res───────────────┐
│ ['hello','world'] │
└───────────────────┘
```

В этом примере массив сортируется следующим образом:

1. Изначально, исходный массив (\['hello', 'world'\]) сортируется в соответствии с результатом лямбда-функции, примененной к элементам массивов. Элементы, переданные во втором массиве (\[2, 1\]), определяют ключи сортировки для соответствующих элементов из исходного массива. Результат – массив \['world', 'hello'\].
2. Массив, отсортированный на предыдущем шаге, инвертируется. Таким образом, окончательный результат будет \['hello', 'world'\].

Другие примеры ниже.

```sql
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```text
┌─res─────┐
│ [5,3,4] │
└─────────┘
```

```sql
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```text
┌─res─────┐
│ [4,3,5] │
└─────────┘
```

## arrayPartialReverseSort(\[func,\] limit, arr, ...) {#arraypartialreversesortfunc-limit-arr-}

Тот же, что и `arrayReverseSort`, с дополнительным аргументом `limit`, позволяющим частичную сортировку. Возвращает массив такого же размера, как и исходный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке убывания. Оставшиеся элементы `(limit..N]` будут содержать элементы в неопределенном порядке.

## arrayShuffle {#arrayshuffle}

Возвращает массив такого же размера, как и исходный массив, содержащий элементы в перемешанном порядке. Элементы переупорядочиваются таким образом, чтобы каждая возможная перестановка этих элементов имела равную вероятность появления.

**Синтаксис**

```sql
arrayShuffle(arr[, seed])
```

**Параметры**

- `arr`: Массив для частичной перетасовки. [Array](/sql-reference/data-types/array).
- `seed` (необязательный): семя, используемое для генерации псевдослучайных чисел. Если не указано, будет использовано случайное значение. [UInt или Int](../data-types/int-uint.md).

**Возвращаемое значение**

- Массив с перемешанными элементами.

**Детали реализации**

:::note 
Эта функция не будет материализовывать константы.
:::

**Примеры**

В этом примере `arrayShuffle` используется без указания `seed`, поэтому она будет генерировать его случайно. 

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4]);
```

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции.

Результат: 

```response
[1,4,2,3]
```

В этом примере `arrayShuffle` получает значение `seed`, и результаты будут стабильными.

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

Результат: 

```response
[3,2,1,4]
```

## arrayPartialShuffle {#arraypartialshuffle}

Данный массив с кардинальностью `N` возвращает массив размера N, где элементы в диапазоне `[1...limit]` перемешаны, а остальные элементы в диапазоне `(limit...n]` не изменение.

**Синтаксис**

```sql
arrayPartialShuffle(arr[, limit[, seed]])
```

**Параметры**

- `arr`: Массив размера `N`, который необходимо частично перетасовать. [Array](/sql-reference/data-types/array).
- `limit` (необязательный): Число, ограничивающее количество перестановок элементов, в пределах `[1..N]`. [UInt или Int](../data-types/int-uint.md).
- `seed` (необязательный): Значение семени для генерации псевдослучайных чисел. Если не указано, будет выбрано случайное. [UInt или Int](../data-types/int-uint.md).

**Возвращаемое значение**

- Массив с частично перемешанными элементами.

**Детали реализации**

:::note 
Эта функция не будет материализовывать константы.

Значение `limit` должно находиться в диапазоне `[1..N]`. Значения вне этого диапазона эквивалентны полной [arrayShuffle](#arrayshuffle).
:::

**Примеры**

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции. 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)
```

Результат:

Порядок элементов сохраняется (`[2,3,4,5], [7,8,9,10]`) за исключением двух перемешанных элементов `[1, 6]`. Поскольку семя не указано, функция выбирает его случайно.

```response
[6,2,3,4,5,1,7,8,9,10]
```

В этом примере значение `limit` увеличивается до `2`, и задается значение `seed`. Порядок 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2);
```

Порядок элементов сохраняется (`[4, 5, 6, 7, 8], [10]`) за исключением четырех перемешанных элементов `[1, 2, 3, 9]`.

Результат: 
```response
[3,9,1,4,5,6,7,8,2,10]
```

## arrayUniq(arr, ...) {#arrayuniqarr-}

Если передан один аргумент, он считает количество различных элементов в массиве. Если передано несколько аргументов, он считает количество различных кортежей элементов на соответствующих позициях в нескольких массивах.

Если вы хотите получить список уникальных элементов в массиве, вы можете использовать arrayReduce('groupUniqArray', arr).

## arrayJoin(arr) {#arrayjoinarr}

Особая функция. См. раздел ["Функция ArrayJoin"](/sql-reference/functions/array-join).

## arrayDifference {#arraydifference}

Вычисляет массив разностей между смежными элементами массива. Первый элемент результирующего массива будет 0, второй `a[1] - a[0]`, третий `a[2] - a[1]` и так далее. Тип элементов в результирующем массиве определяется правилами вывода типов для вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(array)
```

**Аргументы**

- `array` – [Array](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив разностей между смежными элементами массива. [UInt\*](/sql-reference/data-types/int-uint#integer-ranges), [Int\*](/sql-reference/data-types/int-uint#integer-ranges), [Float\*](/sql-reference/data-types/float).

**Пример**

Запрос:

```sql
SELECT arrayDifference([1, 2, 3, 4]);
```

Результат:

```text
┌─arrayDifference([1, 2, 3, 4])─┐
│ [0,1,1,1]                     │
└───────────────────────────────┘
```

Пример переполнения из-за типа результата Int64:

Запрос:

```sql
SELECT arrayDifference([0, 10000000000000000000]);
```

Результат:

```text
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```

## arrayDistinct {#arraydistinct}

Принимает массив и возвращает массив, содержащий только уникальные элементы.

**Синтаксис**

```sql
arrayDistinct(array)
```

**Аргументы**

- `array` – [Array](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив, содержащий уникальные элементы.

**Пример**

Запрос:

```sql
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

Результат:

```text
┌─arrayDistinct([1, 2, 2, 3, 1])─┐
│ [1,2,3]                        │
└────────────────────────────────┘
```

## arrayEnumerateDense {#arrayenumeratedense}

Возвращает массив того же размера, что и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Пример**

Запрос:

```sql
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

Результат:

```text
┌─arrayEnumerateDense([10, 20, 10, 30])─┐
│ [1,2,1,3]                             │
└───────────────────────────────────────┘
```

## arrayEnumerateDenseRanked {#arrayenumeratedenseranked}

Возвращает массив такого же размера, как и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве. Позволяет перечислять многомерный массив с возможностью указать, на какую глубину просматривать массив.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Считывать элементы на указанном уровне отдельно. Положительное [целое число](../data-types/int-uint.md), не превышающее `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Array](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [целое число](../data-types/int-uint.md), не превышающее глубину `arr`.

**Пример**

С `clear_depth=1` и `max_array_depth=1` результат идентичен тому, что бы вы получили при использовании [arrayEnumerateDense](#arrayenumeratedense).

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

Результат:

```text
[1,2,1,3]
```

В этом примере `arrayEnumerateDenseRanked` используется для получения массива, указывая, для каждого элемента многомерного массива, какое его положение среди элементов одного и того же значения. Для первой строки переданного массива, `[10,10,30,20]`, соответствующей первой строкой результата будет `[1,1,2,3]`, указывая, что `10` – это первое число, обнаруженное на позициях 1 и 2, `30` – второе число, обнаруженное на позиции 3 и `20` – третье число, обнаруженное на позиции 4. Для второй строки, `[40, 50, 10, 30]`, соответствующей второй строкой результата будет `[4,5,1,2]`, указывая, что `40` и `50` – это четвертое и пятое числа, обнаруженные на позициях 1 и 2 этой строки, что еще одно `10` (первое обнаруженное число) находится на позиции 3, а `30` (второе обнаруженное число) находится на последней позиции.

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

Результат:

```text
[[1,1,2,3],[4,5,1,2]]
```

Изменение `clear_depth=2` приводит к тому, что перечисление происходит отдельно для каждой строки.

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```
Результат:

```text
[[1,1,2,3],[1,2,3,4]]
```

## arrayUnion {#arrayunion}

Принимает несколько массивов и возвращает массив, содержащий все элементы, присутствующие в одном из исходных массивов. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с уникальными элементами из исходных массивов.

**Пример**

Запрос:

```sql
SELECT
    arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
    arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
    arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

Результат:

```text
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```

## arrayIntersect {#arrayintersect}

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с уникальными элементами, присутствующими во всех исходных массивах.

**Пример**

Запрос:

```sql
SELECT
    arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
    arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

Результат:

```text
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```

## arraySymmetricDifference {#arraysymmetricdifference}

Принимает несколько массивов и возвращает массив с элементами, которые не присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

:::note
Симметричная разность _более чем двух множеств_ математически определяется как множество всех входных элементов, которые встречаются в нечетном количестве входных множеств. В отличие от этого функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые не встречаются во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с уникальными элементами, отсутствующими во всех исходных массивах.

**Пример**

Запрос:

```sql
SELECT
    arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
    arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference
```

Результат:

```text
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```

## arrayJaccardIndex {#arrayjaccardindex}

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) двух массивов.

**Пример**

Запрос:
```sql
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

Результат:
```text
┌─res────────────────┐
│ 0.3333333333333333 │
└────────────────────┘
```

## arrayReduce {#arrayreduce}

Применяет агрегатную функцию к элементам массива и возвращает ее результат. Название функции агрегации передается в виде строки в одинарных кавычках `'max'`, `'sum'`. При использовании параметрических агрегатных функций параметр указывается после имени функции в скобках `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_func, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — Название агрегатной функции, которая должна быть постоянной [строкой](../data-types/string.md).
- `arr` — Любое количество столбцов типа [array](/sql-reference/data-types/array) в качестве параметров агрегатной функции.

**Возвращаемое значение**

**Пример**

Запрос:

```sql
SELECT arrayReduce('max', [1, 2, 3]);
```

Результат:

```text
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

Если агрегатная функция принимает несколько аргументов, то эта функция должна применяться к нескольким массивам одинакового размера.

Запрос:

```sql
SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

Результат:

```text
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

Пример с параметрической агрегатной функцией:

Запрос:

```sql
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

Результат:

```text
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```

**См. также**

- [arrayFold](#arrayfold)

## arrayReduceInRanges {#arrayreduceinranges}

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив, содержащий результат для каждого диапазона. Функция вернет тот же результат, что и несколько вызовов `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_func, ranges, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — Название агрегатной функции, которая должна быть постоянной [строкой](../data-types/string.md).
- `ranges` — Диапазоны для агрегации, которые должны быть [массивом](/sql-reference/data-types/array) [кортежей](../data-types/tuple.md), содержащих индекс и длину каждого диапазона.
- `arr` — Любое количество колонок типа [Array](/sql-reference/data-types/array) в качестве параметров агрегатной функции.

**Возвращаемое значение**

- Массив, содержащий результаты агрегатной функции по указанным диапазонам. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

Результат:

```text
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```

## arrayFold {#arrayfold}

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и собирает результат в аккумулятор.

**Синтаксис**

```sql
arrayFold(lambda_function, arr1, arr2, ..., accumulator)
```

**Пример**

Запрос:

```sql
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], toInt64(3)) AS res;
```

Результат:

```text
┌─res─┐
│  23 │
└─────┘
```

**Пример с последовательностью Фибоначчи**

```sql
SELECT arrayFold(acc,x -> (acc.2, acc.2 + acc.1), range(number), (1::Int64, 0::Int64)).1 AS fibonacci
FROM numbers(1,10);

┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**См. также**

- [arrayReduce](#arrayreduce)

## arrayReverse {#arrayreverse}

Возвращает массив такого же размера, как и исходный массив, содержащий элементы в обратном порядке.

**Синтаксис**

```sql
arrayReverse(arr)
```

Пример:

```sql
SELECT arrayReverse([1, 2, 3])
```

```text
┌─arrayReverse([1, 2, 3])─┐
│ [3,2,1]                 │
└─────────────────────────┘
```

## reverse(arr) {#reversearr}

Синоним для ["arrayReverse"](#arrayreverse)

## arrayFlatten {#arrayflatten}

Преобразует массив массивов в плоский массив.

Функция:

- Применяется к любому уровню вложенности массивов.
- Не изменяет массивы, которые уже плоские.

Развернутый массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
flatten(array_of_arrays)
```

Псевдоним: `flatten`.

**Параметры**

- `array_of_arrays` — [Array](/sql-reference/data-types/array) массивов. Например, `[[1,2,3], [4,5]]`.

**Примеры**

```sql
SELECT flatten([[[1]], [[2], [3]]]);
```

```text
┌─flatten(array(array([1]), array([2], [3])))─┐
│ [1,2,3]                                     │
└─────────────────────────────────────────────┘
```

## arrayCompact {#arraycompact}

Удаляет последовательные дублирующиеся элементы из массива. Порядок результирующих значений определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

`arr` — Массив [array](/sql-reference/data-types/array) для проверки.

**Возвращаемое значение**

Массив без дубликатов. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

Результат:

```text
┌─arrayCompact([1, 1, nan, nan, 2, 3, 3, 3])─┐
│ [1,nan,nan,2,3]                            │
└────────────────────────────────────────────┘
```

## arrayZip {#arrayzip}

Объединяет несколько массивов в один массив. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов. Все входные массивы должны быть одинакового размера.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже такие же, как и типы входных массивов, и они расположены в том же порядке, что и массивы подаются. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

Результат:

```text
┌─arrayZip(['a', 'b', 'c'], [5, 2, 1])─┐
│ [('a',5),('b',2),('c',1)]            │
└──────────────────────────────────────┘
```

## arrayZipUnaligned {#arrayzipunaligned}

Объединяет несколько массивов в один массив, позволяя невыравненные массивы. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов различных типов.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже такие же, как и типы входных массивов, и они расположены в том же порядке, что и массивы подаются. [Array](/sql-reference/data-types/array). Если массивы имеют разный размер, более короткие массивы будут дополнены значениями `null`.

**Пример**

Запрос:

```sql
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

Результат:

```text
┌─arrayZipUnaligned(['a'], [1, 2, 3])─┐
│ [('a',1),(NULL,2),(NULL,3)]         │
└─────────────────────────────────────┘
```

## arrayROCAUC {#arrayrocauc}

Вычисляет площадь под кривой характеристик, принимающих значения (ROC).
ROC-кривая создается путем нанесения истинной положительной доли (TPR) по оси Y и ложной положительной доли (FPR) по оси X под всеми порогами.
Результирующее значение варьируется от 0 до 1, с более высоким значением, указывающим на более высокую производительность модели.
ROC AUC (также известная как просто AUC) является концепцией в машинном обучении.
Для получения дополнительной информации смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(arr_scores, arr_labels[, scale[, arr_partial_offsets]])
```

Псевдоним: `arrayAUC`

**Аргументы**

- `arr_scores` — Оценки, которые дает модель предсказания. [Array](/sql-reference/data-types/array) целых чисел или [Float](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Array](/sql-reference/data-types/array) целых чисел или [Enums](../data-types/enum.md).
- `scale` — Решает, возвращать ли нормализованную площадь. Если `false`, возвращает площадь под кривой TP (истинные положительные) x FP (ложные положительные) вместо этого. Значение по умолчанию: `true`. [Bool](../data-types/boolean.md). Необязательный.
- `arr_partial_offsets` — Массив из четырех неотрицательных целых чисел для вычисления частичной площади под ROC-кривой (эквивалентно вертикальной полосе пространства ROC) вместо всей AUC. Эта опция полезна для распределенного вычисления ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) неотрицательных [целых чисел](../data-types/int-uint.md). Необязательный.
    - `higher_partitions_tp`: Количество положительных меток в секциях с более высокими оценками.
    - `higher_partitions_fp`: Количество отрицательных меток в секциях с более высокими оценками.
    - `total_positives`: Общее количество положительных образцов в наборе данных.
    - `total_negatives`: Общее количество отрицательных образцов в наборе данных.

::::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны составлять лишь часть всего набора данных, содержащую диапазон оценок.
Набор данных должен быть разделен на смежные участки, где каждый участок содержит подмножество данных, чьи оценки попадают в определенный диапазон.
Например:
- Один участок может содержать все оценки в диапазоне [0, 0.5).
- Другой участок может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой характеристик (ROC). [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
select arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

```text
┌─arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                                             0.75 │
└──────────────────────────────────────────────────┘
```
## arrayAUCPR {#arrayaucpr}

Вычисляет площадь под кривой точности-восстановления (PR).
Кривая точности-восстановления создается путем построения точности по оси y и восстановления по оси x для всех порогов.
Полученное значение колеблется от 0 до 1, где более высокое значение указывает на лучшую производительность модели.
PR AUC особенно полезен для несбалансированных наборов данных, обеспечивая более четкое сравнение производительности по сравнению с ROC AUC в таких случаях.
Для получения дополнительных деталей, пожалуйста, смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(arr_scores, arr_labels[, arr_partial_offsets])
```

Псевдоним: `arrayPRAUC`

**Аргументы**

- `arr_scores` — Оценки, которые выдает модель предсказания. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Чисел с плавающей точкой](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Перечислений](../data-types/enum.md).
- `arr_partial_offsets` — Необязательно. [Массив](/sql-reference/data-types/array) из трех неотрицательных целых чисел для вычисления частичной площади под кривой PR (эквивалентно вертикальной полосе PR пространства) вместо всей AUC. Эта опция полезна для распределенной обработки PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]. [Массив](/sql-reference/data-types/array) неотрицательных [Целых чисел](../data-types/int-uint.md). Необязательно.
    - `higher_partitions_tp`: Количество положительных меток в более высоко оцененных частях.
    - `higher_partitions_fp`: Количество отрицательных меток в более высоко оцененных частях.
    - `total_positives`: Общее количество положительных образцов в всего наборе данных.

::::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны быть только частью всего набора данных, содержащей интервал оценок.
Набор данных должен быть разделен на смежные части, где каждая часть содержит подмножество данных, чьи оценки попадают в определенный диапазон.
Например:
- Одна часть может содержать все оценки в диапазоне [0, 0.5).
- Другая часть может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой точности-восстановления (PR). [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
select arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

```text
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayMap(func, arr1, ...) {#arraymapfunc-arr1-}

Возвращает массив, полученный из исходных массивов путем применения `func(arr1[i], ..., arrN[i])` для каждого элемента. Массивы `arr1` ... `arrN` должны иметь одинаковое количество элементов.

Примеры:

```sql
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [3,4,5] │
└─────────┘
```

Следующий пример показывает, как создать кортеж элементов из различных массивов:

```sql
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```text
┌─res─────────────────┐
│ [(1,4),(2,5),(3,6)] │
└─────────────────────┘
```

Обратите внимание, что `arrayMap` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayFilter(func, arr1, ...) {#arrayfilterfunc-arr1-}

Возвращает массив, содержащий только элементы в `arr1`, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Примеры:

```sql
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```text
┌─res───────────┐
│ ['abc World'] │
└───────────────┘
```

```sql
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```text
┌─res─┐
│ [2] │
└─────┘
```

Обратите внимание, что `arrayFilter` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayFill(func, arr1, ...) {#arrayfillfunc-arr1-}

Просматривает `arr1` от первого элемента до последнего элемента и заменяет `arr1[i]` на `arr1[i - 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Первый элемент `arr1` заменяться не будет.

Примеры:

```sql
SELECT arrayFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

```text
┌─res──────────────────────────────┐
│ [1,1,3,11,12,12,12,5,6,14,14,14] │
└──────────────────────────────────┘
```

Обратите внимание, что `arrayFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayReverseFill(func, arr1, ...) {#arrayreversefillfunc-arr1-}

Просматривает `arr1` от последнего элемента до первого элемента и заменяет `arr1[i]` на `arr1[i + 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Последний элемент `arr1` заменяться не будет.

Примеры:

```sql
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

```text
┌─res────────────────────────────────┐
│ [1,3,3,11,12,5,5,5,6,14,NULL,NULL] │
└────────────────────────────────────┘
```

Обратите внимание, что `arrayReverseFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arraySplit(func, arr1, ...) {#arraysplitfunc-arr1-}

Разделяет `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, массив будет разделен на левой стороне элемента. Массив не будет разделен перед первым элементом.

Примеры:

```sql
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```text
┌─res─────────────┐
│ [[1,2,3],[4,5]] │
└─────────────────┘
```

Обратите внимание, что `arraySplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayReverseSplit(func, arr1, ...) {#arrayreversesplitfunc-arr1-}

Разделяет `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, массив будет разделен на правой стороне элемента. Массив не будет разделен после последнего элемента.

Примеры:

```sql
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```text
┌─res───────────────┐
│ [[1],[2,3,4],[5]] │
└───────────────────┘
```

Обратите внимание, что `arrayReverseSplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayExists(\[func,\] arr1, ...) {#arrayexistsfunc-arr1-}

Возвращает 1, если в `arr` есть хотя бы один элемент, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0. В противном случае возвращает 0.

Обратите внимание, что `arrayExists` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.
## arrayAll(\[func,\] arr1, ...) {#arrayallfunc-arr1-}

Возвращает 1, если `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0 для всех элементов в массивах. В противном случае возвращает 0.

Обратите внимание, что `arrayAll` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.
## arrayFirst(func, arr1, ...) {#arrayfirstfunc-arr1-}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.
## arrayFirstOrNull {#arrayfirstornull}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Первый элемент в переданном массиве.
- В противном случае возвращает `NULL`

**Детали реализации**

Обратите внимание, что `arrayFirstOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.

**Пример**

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
2
```

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```

Запрос:

```sql
SELECT arrayLastOrNull((x,f) -> f, [1,2,3,NULL], [0,1,0,1]);
```

Результат:

```response
\N
```
## arrayLast(func, arr1, ...) {#arraylastfunc-arr1-}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Обратите внимание, что `arrayLast` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayLastOrNull {#arraylastornull}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Последний элемент в переданном массиве.
- В противном случае возвращает `NULL`

**Детали реализации**

Обратите внимание, что `arrayLastOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.

**Пример**

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
3
```

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```
## arrayFirstIndex(func, arr1, ...) {#arrayfirstindexfunc-arr1-}

Возвращает индекс первого элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Обратите внимание, что `arrayFirstIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayLastIndex(func, arr1, ...) {#arraylastindexfunc-arr1-}

Возвращает индекс последнего элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Обратите внимание, что `arrayLastIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию как первый аргумент, и ее нельзя опустить.
## arrayMin {#arraymin}

Возвращает минимум элементов в исходном массиве.

Если указана функция `func`, возвращает минимум элементов, преобразованных с помощью этой функции.

Обратите внимание, что `arrayMin` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.

**Синтаксис**

```sql
arrayMin([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Минимум значений функции (или минимум массива).

:::note
Если `func` указан, то возвращаемый тип совпадает с типом возвращаемого значения `func`, иначе он совпадает с типом элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMin([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   1 │
└─────┘
```

Запрос:

```sql
SELECT arrayMin(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -4 │
└─────┘
```
## arrayMax {#arraymax}

Возвращает максимум элементов в исходном массиве.

Если указана функция `func`, возвращает максимум элементов, преобразованных с помощью этой функции.

Обратите внимание, что `arrayMax` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.

**Синтаксис**

```sql
arrayMax([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Максимум значений функции (или максимум массива).

:::note
если `func` указан, то возвращаемый тип совпадает с типом возвращаемого значения `func`, иначе он совпадает с типом элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMax([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   4 │
└─────┘
```

Запрос:

```sql
SELECT arrayMax(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -1 │
└─────┘
```
## arraySum {#arraysum}

Возвращает сумму элементов в исходном массиве.

Если указана функция `func`, возвращает сумму элементов, преобразованных с помощью этой функции.

Обратите внимание, что `arraySum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.

**Синтаксис**

```sql
arraySum([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Сумма значений функции (или сумма массива).

:::note
Тип возвращаемого значения:

- Для десятичных чисел в исходном массиве (или для преобразованных значений, если указана `func`) — [Decimal128](../data-types/decimal.md).
- Для чисел с плавающей точкой — [Float64](../data-types/float.md).
- Для unsigned чисел — [UInt64](../data-types/int-uint.md). 
- Для signed чисел — [Int64](../data-types/int-uint.md).
:::

**Примеры**

Запрос:

```sql
SELECT arraySum([2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│   5 │
└─────┘
```

Запрос:

```sql
SELECT arraySum(x -> x*x, [2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│  13 │
└─────┘
```
## arrayAvg {#arrayavg}

Возвращает среднее значение элементов в исходном массиве.

Если указана функция `func`, возвращает среднее значение элементов, преобразованных с помощью этой функции.

Обратите внимание, что `arrayAvg` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.

**Синтаксис**

```sql
arrayAvg([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Среднее значение значений функции (или среднее значение массива). [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayAvg([1, 2, 4]) AS res;
```

Результат:

```text
┌────────────────res─┐
│ 2.3333333333333335 │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayAvg(x -> (x * x), [2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  10 │
└─────┘
```
## arrayCumSum(\[func,\] arr1, ...) {#arraycumsumfunc-arr1-}

Возвращает массив частичных (накопительных) сумм элементов в исходном массиве `arr1`. Если указана `func`, то сумма вычисляется путем применения `func` к `arr1`, `arr2`, ..., `arrN`, т.е. `func(arr1[i], ..., arrN[i])`.

**Синтаксис**

```sql
arrayCumSum(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив частичных сумм элементов в исходном массиве. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float/).

Пример:

```sql
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```text
┌─res──────────┐
│ [1, 2, 3, 4] │
└──────────────┘
```

Обратите внимание, что `arrayCumSum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.
## arrayCumSumNonNegative(\[func,\] arr1, ...) {#arraycumsumnonnegativefunc-arr1-}

Так же, как `arrayCumSum`, возвращает массив частичных (накопительных) сумм элементов в исходном массиве. Если указана `func`, то сумма вычисляется путем применения `func` к `arr1`, `arr2`, ..., `arrN`, т.е. `func(arr1[i], ..., arrN[i])`. В отличие от `arrayCumSum`, если текущая накопительная сумма меньше 0, она заменяется на 0.

**Синтаксис**

```sql
arrayCumSumNonNegative(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив неотрицательных частичных сумм элементов в исходном массиве. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float/).

```sql
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```text
┌─res───────┐
│ [1,2,0,1] │
└───────────┘
```

Обратите внимание, что `arraySumNonNegative` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию как первый аргумент.
## arrayProduct {#arrayproduct}

Умножает элементы [массива](/sql-reference/data-types/array).

**Синтаксис**

```sql
arrayProduct(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Произведение элементов массива. [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayProduct([1,2,3,4,5,6]) as res;
```

Результат:

```text
┌─res───┐
│ 720   │
└───────┘
```

Запрос:

```sql
SELECT arrayProduct([toDecimal64(1,8), toDecimal64(2,8), toDecimal64(3,8)]) as res, toTypeName(res);
```

Тип возвращаемого значения всегда [Float64](../data-types/float.md). Результат:

```text
┌─res─┬─toTypeName(arrayProduct(array(toDecimal64(1, 8), toDecimal64(2, 8), toDecimal64(3, 8))))─┐
│ 6   │ Float64                                                                                  │
└─────┴──────────────────────────────────────────────────────────────────────────────────────────┘
```
## arrayRotateLeft {#arrayrotateleft}

Поворачивает [массив](/sql-reference/data-types/array) налево на указанное количество элементов.
Если количество элементов отрицательное, массив поворачивается направо.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для поворота.

**Возвращаемое значение**

- Массив, повёрнутый налево на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateLeft(['a','b','c','d','e'], 3) as res;
```

Результат:

```text
┌─res───────────────────┐
│ ['d','e','a','b','c'] │
└───────────────────────┘
```
## arrayRotateRight {#arrayrotateright}

Поворачивает [массив](/sql-reference/data-types/array) направо на указанное количество элементов.
Если количество элементов отрицательное, массив поворачивается налево.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для поворота.

**Возвращаемое значение**

- Массив, повёрнутый направо на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateRight(['a','b','c','d','e'], 3) as res;
```

Результат:

```text
┌─res───────────────────┐
│ ['c','d','e','a','b'] │
└───────────────────────┘
```
## arrayShiftLeft {#arrayshiftleft}

Сдвигает [массив](/sql-reference/data-types/array) налево на указанное количество элементов.
Новые элементы заполняются предоставленным аргументом или значением по умолчанию для типа элемента массива.
Если количество элементов отрицательное, массив сдвигается направо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательно. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый налево на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

```text
┌─res─────────────┐
│ [3,4,5,6,42,42] │
└─────────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

```text
┌─res─────────────────────────────┐
│ ['d','e','f','foo','foo','foo'] │
└─────────────────────────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

```text
┌─res─────────────────┐
│ [3,4,5,6,4242,4242] │
└─────────────────────┘
```
## arrayShiftRight {#arrayshiftright}

Сдвигает [массив](/sql-reference/data-types/array) направо на указанное количество элементов.
Новые элементы заполняются предоставленным аргументом или значением по умолчанию для типа элемента массива.
Если количество элементов отрицательное, массив сдвигается налево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательно. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый направо на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

```text
┌─res─────────────┐
│ [42,42,1,2,3,4] │
└─────────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

```text
┌─res─────────────────────────────┐
│ ['foo','foo','foo','a','b','c'] │
└─────────────────────────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

```text
┌─res─────────────────┐
│ [4242,4242,1,2,3,4] │
└─────────────────────┘
```
## arrayRandomSample {#arrayrandomsample}

Функция `arrayRandomSample` возвращает подмножество с `samples`-количеством случайных элементов из входного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, т.е. возвращаются все элементы массива, но их порядок не гарантируется. Функция может обрабатывать как плоские массивы, так и вложенные массивы.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

- `arr` — Входной массив, из которого следует выбрать элементы. ([Array(T)](/sql-reference/data-types/array))
- `samples` — Количество элементов, которые следует включить в случайную выборку ([UInt*](../data-types/int-uint.md))

**Возвращаемое значение**

- Массив, содержащий случайную выборку элементов из входного массива. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

Результат:

```response
┌─res────────────────┐
│ ['cherry','apple'] │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

Результат:

```response
┌─res───────────┐
│ [[3,4],[5,6]] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([1, 2, 3], 5) as res;
```

Результат:

```response
┌─res─────┐
│ [3,1,2] │
└─────────┘
```
## arrayNormalizedGini {#arraynormalizedgini}

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

- `predicted` — Предсказанные значения ([Array(T)](/sql-reference/data-types/array))
- `label` — Фактические значения ([Array(T)](/sql-reference/data-types/array))

**Возвращаемое значение**

- Кортеж, содержащий коэффициенты Джини предсказанных значений, коэффициент Джини нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух коэффициентов Джини).

**Примеры**

Запрос:

```sql
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2]);
```

Результат:

```response
┌─arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2])──────────┐
│ (0.18055555555555558,0.2638888888888889,0.6842105263157896) │
└─────────────────────────────────────────────────────────────┘
```
## arrayLevenshteinDistance {#arraylevenshteindistance}

Вычисляет расстояние Левенштейна для двух массивов.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

- `from` — первый массив
- `to` — второй массив

**Возвращаемое значение**

- Расстояние Левенштейна между первым и вторым массивами

**Примеры**

Запрос:

```sql
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

Результат:

```text

┌─arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])─┐
│                                              1 │
└────────────────────────────────────────────────┘

```
## arrayLevenshteinDistanceWeighted {#arraylevenshteindistanceweighted}

Вычисляет расстояние Левенштейна для двух массивов с пользовательскими весами для каждого элемента. Количество элементов для массива и его весов должно совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив
- `to` — второй массив
- `from_weights` — веса для первого массива
- `to_weights` — веса для второго массива

**Возвращаемое значение**

- Расстояние Левенштейна между первым и вторым массивами с пользовательскими весами для каждого элемента

**Примеры**

Запрос:

```sql
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

Результат:

```text

┌─arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])─┐
│                                                                                           14 │
└──────────────────────────────────────────────────────────────────────────────────────────────┘

```
## arraySimilarity {#arraysimilarity}

Вычисляет схожесть массивов от 0 до 1 на основе взвешенного расстояния Левенштейна. Принимает те же аргументы, что и функция `arrayLevenshteinDistanceWeighted`.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив
- `to` — второй массив
- `from_weights` — веса для первого массива
- `to_weights` — веса для второго массива

**Возвращаемое значение**

- Сходство двух массивов на основе взвешенного расстояния Левенштейна

**Примеры**

Запрос:

```sql
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

Результат:

```text

┌─arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])─┐
│                                                          0.2222222222222222 │
└─────────────────────────────────────────────────────────────────────────────┘

```
## Distance functions {#distance-functions}

Все поддерживаемые функции описаны в [документации по функциям расстояния](../../sql-reference/functions/distance-functions.md).
