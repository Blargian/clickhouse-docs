---
alias: []
description: 'Protobufフォーマットのドキュメント'
input_format: true
keywords: ['Protobuf']
output_format: true
slug: /interfaces/formats/Protobuf
title: 'Protobuf'
---

import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';

<CloudNotSupportedBadge/>

| 入力 | 出力 | エイリアス |
|------|------|------------|
| ✔    | ✔    |            |

## 説明 {#description}

`Protobuf`フォーマットは[Protocol Buffers](https://protobuf.dev/)フォーマットです。

このフォーマットは外部フォーマットスキーマを必要とし、クエリの間キャッシュされます。

ClickHouseは以下をサポートします：
- `proto2`および`proto3`構文の両方。
- `Repeated`/`optional`/`required`フィールド。

## 使用例 {#example-usage}

### 基本的な例 {#basic-examples}

使用例：

```sql
SELECT * FROM test.table FORMAT Protobuf SETTINGS format_schema = 'schemafile:MessageType'
```

```bash
cat protobuf_messages.bin | clickhouse-client --query "INSERT INTO test.table SETTINGS format_schema='schemafile:MessageType' FORMAT Protobuf"
```

ファイル`schemafile.proto`は以下のようになります：

```capnp
syntax = "proto3";

message MessageType {
  string name = 1;
  string surname = 2;
  uint32 birthDate = 3;
  repeated string phoneNumbers = 4;
};
```

ClickHouseはテーブルカラムとProtocol Buffersのメッセージタイプのフィールドとの対応関係を見つけるために、その名前を比較します。この比較は大文字と小文字を区別せず、`_`（アンダースコア）と`.`（ドット）が同等と見なされます。カラムとProtocol Buffersのメッセージのフィールドの型が異なる場合、必要な変換が適用されます。

ネストされたメッセージがサポートされています。例えば、以下のメッセージタイプにおけるフィールド`z`のために：

```capnp
message MessageType {
  message XType {
    message YType {
      int32 z;
    };
    repeated YType y;
  };
  XType x;
};
```

ClickHouseは`x.y.z`（または`x_y_z`、`X.y_Z`など）という名前のカラムを探します。

ネストされたメッセージは、[ネストされたデータ構造](/sql-reference/data-types/nested-data-structures/index.md)の入力または出力に適しています。

以下のようにプロトコルスキーマに定義されたデフォルト値は適用されず、[テーブルのデフォルト](/sql-reference/statements/create/table#default_values)が代わりに使用されます：

```capnp
syntax = "proto2";

message MessageType {
  optional int32 result_per_page = 3 [default = 10];
}
```

ClickHouseは`length-delimited`フォーマットでprotobufメッセージを入力および出力します。これは、各メッセージの前にその長さを[可変幅整数（varint）](https://developers.google.com/protocol-buffers/docs/encoding#varints)として書き込む必要があることを意味します。

こちらも参照してください: [人気のある言語でlength-delimited protobufメッセージを読み書きする方法](https://cwiki.apache.org/confluence/display/GEODE/Delimiting+Protobuf+Messages)。

### 自動生成スキーマの使用 {#using-autogenerated-protobuf-schema}

データの外部Protobufスキーマがない場合でも、自動生成されたスキーマを使用してProtobufフォーマットでデータを出力/入力できます。

例えば：

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1
```

この場合、ClickHouseは[`structureToProtobufSchema`](/sql-reference/functions/other-functions.md#structure_to_protobuf_schema)関数を使用してテーブル構造に従ってProtobufスキーマを自動生成します。次に、このスキーマを使用してProtobufフォーマットでデータをシリアライズします。

自動生成スキーマを持つProtobufファイルを読み取ることもできます。この場合、ファイルは同じスキーマを使用して作成される必要があります：

```bash
$ cat hits.bin | clickhouse-client --query "INSERT INTO test.hits SETTINGS format_protobuf_use_autogenerated_schema=1 FORMAT Protobuf"
```

設定[`format_protobuf_use_autogenerated_schema`](/operations/settings/settings-formats.md#format_protobuf_use_autogenerated_schema)はデフォルトで有効で、[`format_schema`](/operations/settings/formats#format_schema)が設定されていない場合に適用されます。

入力/出力中に自動生成スキーマをファイルに保存することもできます。設定[`output_format_schema`](/operations/settings/formats#output_format_schema)を使用して。例えば：

```sql
SELECT * FROM test.hits format Protobuf SETTINGS format_protobuf_use_autogenerated_schema=1, output_format_schema='path/to/schema/schema.proto'
```

この場合、自動生成されたProtobufスキーマはファイル`path/to/schema/schema.capnp`に保存されます。

### Protobufキャッシュを削除 {#drop-protobuf-cache}

[`format_schema_path`](/operations/server-configuration-parameters/settings.md/#format_schema_path)から読み込まれたProtobufスキーマを再読み込みするには、[`SYSTEM DROP ... FORMAT CACHE`](/sql-reference/statements/system.md/#system-drop-schema-format)文を使用します。

```sql
SYSTEM DROP FORMAT SCHEMA CACHE FOR Protobuf
```

## フォーマット設定 {#format-settings}
