---
title: 'Использование JOIN в ClickHouse'
description: 'Как объединять таблицы в ClickHouse'
keywords: ['joins', 'join tables']
slug: /guides/joining-tables
---

import Image from '@theme/IdealImage';
import joins_1 from '@site/static/images/guides/joins-1.png';
import joins_2 from '@site/static/images/guides/joins-2.png';
import joins_3 from '@site/static/images/guides/joins-3.png';
import joins_4 from '@site/static/images/guides/joins-4.png';
import joins_5 from '@site/static/images/guides/joins-5.png';

ClickHouse имеет [полную поддержку `JOIN`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1) с широким выбором алгоритмов объединения. Для максимизации производительности мы рекомендуем следовать рекомендациям по оптимизации объединений, указанным в этом руководстве.

- Для оптимальной производительности пользователи должны стремиться сократить количество `JOIN` в запросах, особенно для аналитических рабочих нагрузок в реальном времени, где требуется производительность в миллисекундах. Стремитесь к максимуму 3-4 объединений в запросе. Мы подробно описываем ряд изменений для минимизации объединений в [разделе моделирования данных](/data-modeling/schema-design), включая денормализацию, словари и материализованные представления.
- В настоящее время ClickHouse не изменяет порядок объединений. Всегда убедитесь, что самая маленькая таблица расположена с правой стороны объединения. Это будет храниться в памяти для большинства алгоритмов объединения и обеспечит наименьшую нагрузку на память для запроса.
- Если вашему запросу требуется прямое объединение, т.е. `LEFT ANY JOIN`, как показано ниже, мы рекомендуем использовать [Словари](/dictionary), где это возможно.

<Image img={joins_1} size="sm" alt="Left any join"/>

- Если вы выполняете внутренние объединения, часто более оптимально записывать их в виде подзапросов с использованием оператора `IN`. Рассмотрим следующие запросы, которые функционально эквивалентны. Оба находят количество `posts`, которые не упоминают ClickHouse в вопросе, но делают это в `comments`.

```sql
SELECT count()
FROM stackoverflow.posts AS p
ANY INNER `JOIN` stackoverflow.comments AS c ON p.Id = c.PostId
WHERE (p.Title != '') AND (p.Title NOT ILIKE '%clickhouse%') AND (p.Body NOT ILIKE '%clickhouse%') AND (c.Text ILIKE '%clickhouse%')

┌─count()─┐
│       86 │
└─────────┘

1 row in set. Elapsed: 8.209 sec. Processed 150.20 million rows, 56.05 GB (18.30 million rows/s., 6.83 GB/s.)
Peak memory usage: 1.23 GiB.
```

Обратите внимание, что мы используем `ANY INNER JOIN` против просто `INNER JOIN`, так как мы не хотим картезианского произведения, т.е. мы хотим только одно совпадение для каждого поста.

Это объединение может быть переписано с использованием подзапроса, значительно повысив производительность:

```sql
SELECT count()
FROM stackoverflow.posts
WHERE (Title != '') AND (Title NOT ILIKE '%clickhouse%') AND (Body NOT ILIKE '%clickhouse%') AND (Id IN (
        SELECT PostId
        FROM stackoverflow.comments
        WHERE Text ILIKE '%clickhouse%'
))
┌─count()─┐
│       86 │
└─────────┘

1 row in set. Elapsed: 2.284 sec. Processed 150.20 million rows, 16.61 GB (65.76 million rows/s., 7.27 GB/s.)
Peak memory usage: 323.52 MiB.
```

Хотя ClickHouse пытается перенести условия в все операторы объединения и подзапросы, мы рекомендуем пользователям всегда вручную применять условия ко всем подусловиям, где это возможно - тем самым минимизируя объем данных для объединения. Рассмотрим следующий пример, в котором мы хотим вычислить количество голосов "за" для постов о Java с 2020 года.

Наивный запрос, с большей таблицей с левой стороны, завершается за 56 секунд:

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.posts AS p
INNER JOIN stackoverflow.votes AS v ON p.Id = v.PostId
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 56.642 sec. Processed 252.30 million rows, 1.62 GB (4.45 million rows/s., 28.60 MB/s.)
```

Переупорядочение этого объединения значительно улучшает производительность до 1.5 секунд:

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.votes AS v
INNER JOIN stackoverflow.posts AS p ON v.PostId = p.Id
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 1.519 sec. Processed 252.30 million rows, 1.62 GB (166.06 million rows/s., 1.07 GB/s.)
```

Добавление фильтра к таблице справа еще более улучшает производительность до 0.5 секунд.

```sql
SELECT countIf(VoteTypeId = 2) AS upvotes
FROM stackoverflow.votes AS v
INNER JOIN stackoverflow.posts AS p ON v.PostId = p.Id
WHERE has(arrayFilter(t -> (t != ''), splitByChar('|', p.Tags)), 'java') AND (p.CreationDate >= '2020-01-01') AND (v.CreationDate >= '2020-01-01')

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 0.597 sec. Processed 81.14 million rows, 1.31 GB (135.82 million rows/s., 2.19 GB/s.)
Peak memory usage: 249.42 MiB.
```

Этот запрос можно улучшить еще больше, переместив `INNER JOIN` в подзапрос, как замечалось ранее, сохраняя фильтр как в внешнем, так и во внутреннем запросах.

```sql
SELECT count() AS upvotes
FROM stackoverflow.votes
WHERE (VoteTypeId = 2) AND (PostId IN (
        SELECT Id
        FROM stackoverflow.posts
        WHERE (CreationDate >= '2020-01-01') AND has(arrayFilter(t -> (t != ''), splitByChar('|', Tags)), 'java')
))

┌─upvotes─┐
│  261915 │
└─────────┘

1 row in set. Elapsed: 0.383 sec. Processed 99.64 million rows, 804.55 MB (259.85 million rows/s., 2.10 GB/s.)
Peak memory usage: 250.66 MiB.
```

## Выбор алгоритма объединения {#choosing-a-join-algorithm}

ClickHouse поддерживает несколько [алгоритмов объединения](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1). Эти алгоритмы обычно обмениваются использованием памяти на производительность. Ниже приведен обзор алгоритмов объединения ClickHouse на основе их относительного потребления памяти и времени выполнения:

<br />

<Image img={joins_2} size="lg" alt="speed by memory for joins"/>

<br />

Эти алгоритмы определяют способ, которым планируется и выполняется запрос на объединение. По умолчанию ClickHouse использует прямой или хеш-алгоритм объединения в зависимости от типа объединения, строгости и движка объединяемых таблиц. В качестве альтернативы, ClickHouse может быть настроен на адаптивный выбор и динамическую смену алгоритма объединения в режиме выполнения в зависимости от доступности ресурсов и их использования: Когда `join_algorithm=auto`, ClickHouse сначала пробует алгоритм хеш-объединения, и если лимит памяти для этого алгоритма нарушен, алгоритм переключается на лету на частичное слияние. Вы можете наблюдать, какой алгоритм был выбран через журнал трассировки. ClickHouse также позволяет пользователям самостоятельно указывать желаемый алгоритм объединения через настройку `join_algorithm`.

Поддерживаемые типы `JOIN` для каждого алгоритма объединения показаны ниже и должны быть учтены перед оптимизацией:

<br />

<Image img={joins_3} size="lg" alt="join features"/>

<br />

Полное подробное описание каждого алгоритма `JOIN` можно найти [здесь](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2), включая их преимущества, недостатки и свойства масштабирования.

Выбор подходящих алгоритмов объединения зависит от того, оптимизируете ли вы для памяти или производительности.

## Оптимизация производительности JOIN {#optimizing-join-performance}

Если вашим ключевым показателем оптимизации является производительность и вы стремитесь выполнить объединение как можно быстрее, вы можете использовать следующее дерево решений для выбора правильного алгоритма объединения:

<br />

<Image img={joins_4} size="lg" alt="join flowchart"/>

<br />

- **(1)** Если данные из таблицы с правой стороны могут быть предварительно загружены в структуру данных ключ-значение с низкой задержкой, например, словарь, и если ключ объединения соответствует ключевому атрибуту подлежащего хранилища ключ-значение, и если семантика `LEFT ANY JOIN` адекватна - тогда **прямое объединение** применимо и предлагает самый быстрый подход.

- **(2)** Если порядок строк в вашей таблице [физически соответствует](https://guides/best-practices/sparse-primary-indexes#data-is-stored-on-disk-ordered-by-primary-key-columns) порядку сортировки ключа объединения, тогда это зависит от ситуации. В этом случае **полное слияние с сортировкой** [пропускает](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order) фазу сортировки, что приводит к значительному сокращению использования памяти, а также, в зависимости от объема данных и распределения значений ключа объединения, к более быстрому времени выполнения, чем у некоторых алгоритмов хеш-объединения.

- **(3)** Если таблица с правой стороны помещается в память, даже с [дополнительными накладными расходами на память](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#summary) алгоритма **параллельного хеш-объединения**, то этот алгоритм или хеш-объединение могут быть быстрее. Это зависит от размера данных, типов данных и распределения значений столбцов ключей объединения.

- **(4)** Если таблица с правой стороны не помещается в память, тогда это снова зависит от ситуации. ClickHouse предлагает три алгоритма объединения, не зависящих от памяти. Все три временно сбрасывают данные на диск. **Полное слияние с сортировкой** и **частичное слияние** требуют предварительной сортировки данных. **Хеш-объединение Grace** строит хеш-таблицы из данных вместо этого. В зависимости от объема данных, типов данных и распределения значений столбцов ключей объединения могут быть сценарии, когда построение хеш-таблиц из данных быстрее, чем сортировка данных. И наоборот.

Частичное слияние оптимизировано для минимизации использования памяти при объединении больших таблиц, за счет скорости объединения, которая довольно медленная. Это особенно актуально, когда физический порядок строк левой таблицы не соответствует порядку сортировки ключа объединения.

Хеш-объединение Grace является самым гибким из трех алгоритмов объединения, не зависящих от памяти, и предлагает хороший контроль использования памяти по сравнению со скоростью объединения благодаря настройке [grace_hash_join_initial_buckets](https://github.com/ClickHouse/ClickHouse/blob/23.5/src/Core/Settings.h#L759). В зависимости от объема данных хеш-объединение Grace может быть быстрее или медленнее, чем частичное слияние, когда количество [корзинок](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#description-2) выбирается так, чтобы использование памяти обоих алгоритмов было примерно на одном уровне. Когда использование памяти хеш-объединения Grace настроено так, чтобы быть примерно на одном уровне с использованием памяти полного слияния с сортировкой, тогда полное слияние с сортировкой всегда было быстрее в наших тестах.

Какой из трех алгоритмов, не зависящих от памяти, является самым быстрым, зависит от объема данных, типов данных и распределения значений столбцов ключей объединения. Всегда лучше выполнить несколько тестов с реальными объемами данных, чтобы определить, какой алгоритм является самым быстрым.

## Оптимизация для памяти {#optimizing-for-memory}

Если вы хотите оптимизировать объединение для наименьшего использования памяти вместо самой быстрой скорости выполнения, вы можете использовать это дерево решений:

<br />

<Image img={joins_5} size="lg" alt="Join memory optimization decision tree" />

<br />

- **(1)** Если физический порядок строк вашей таблицы соответствует порядку сортировки ключа объединения, то использование памяти при **полном слиянии с сортировкой** будет минимальным. С дополнительным преимуществом хорошей скорости объединения, так как фаза сортировки [отключена](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3#utilizing-physical-row-order).
- **(2)** Алгоритм **хеш-объединения Grace** может быть настроен на очень низкое использование памяти за счет [конфигурирования](https://github.com/ClickHouse/ClickHouse/blob/23.5/src/Core/Settings.h#L759) большого числа [корзинок](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2#description-2) в ущерб скорости объединения. **Частичное слияние** намеренно использует малое количество основной памяти. **Полное слияние с сортировкой** с включенной внешней сортировкой, как правило, использует больше памяти, чем частичное слияние (при условии, что порядок строк не соответствует порядку сортировки по ключу), с преимуществом значительно лучшего времени выполнения объединения.

Для пользователей, нуждающихся в дополнительных деталях по вышеуказанному, мы рекомендуем следующую [серию блогов](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1).
