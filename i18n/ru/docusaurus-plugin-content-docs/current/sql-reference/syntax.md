---
description: 'Документация по синтаксису'
displayed_sidebar: 'sqlreference'
sidebar_label: 'Синтаксис'
sidebar_position: 2
slug: /sql-reference/syntax
title: 'Синтаксис'
---

В этом разделе мы рассмотрим синтаксис SQL ClickHouse. 
ClickHouse использует синтаксис на основе SQL, но предлагает ряд расширений и оптимизаций.

## Разбор запросов {#query-parsing}

В ClickHouse есть два типа парсеров:
- _Полный SQL парсер_ (рекурсивный спускающийся парсер).
- _Парсер формата данных_ (быстрый потоковый парсер).

Полный SQL парсер используется во всех случаях, кроме запроса `INSERT`, который использует оба парсера. 

Рассмотрим приведенный ниже запрос:

```sql
INSERT INTO t VALUES (1, 'Hello, world'), (2, 'abc'), (3, 'def')
```

Как уже упоминалось, запрос `INSERT` использует оба парсера. 
Фрагмент `INSERT INTO t VALUES` разбирается полным парсером, 
а данные `(1, 'Hello, world'), (2, 'abc'), (3, 'def')` разбираются парсером формата данных, или быстрым потоковым парсером.

<details>
<summary>Включение полного парсера</summary>

Вы также можете включить полный парсер для данных, 
используя настройку [`input_format_values_interpret_expressions`](../operations/settings/settings-formats.md#input_format_values_interpret_expressions). 

Когда указанная настройка установлена в `1`, 
ClickHouse сначала пытается разобрать значения с помощью быстрого потокового парсера. 
Если это не удается, ClickHouse пытается использовать полный парсер для данных, рассматривая их как SQL [выражение](#expressions).
</details>


Данные могут иметь любой формат. 
Когда сервер получает запрос, он рассчитывает не более [max_query_size](../operations/settings/settings.md#max_query_size) байтов запроса в ОЗУ 
(по умолчанию 1 МБ), а остальная часть разбирается потоком.
Это позволяет избежать проблем с крупными запросами `INSERT`, что является рекомендуемым способом вставки ваших данных в ClickHouse.

При использовании формата [`Values`](../interfaces/formats.md/#data-format-values) в запросе `INSERT`, 
может показаться, что данные разбираются так же, как и для выражений в запросе `SELECT`, однако это не так. 
Формат `Values` намного более ограничен.

Остальная часть этого раздела охватывает полный парсер. 

:::note
Для получения дополнительной информации о парсерах формата, смотрите раздел [Форматы](../interfaces/formats.md).
:::

## Пробелы {#spaces}

- Между синтаксическими конструкциями (включая начало и конец запроса) может быть любое количество символов пробела. 
- Символы пробела включают пробел, табуляцию, перевод строки, CR и слипающую ленту.

## Комментарии {#comments}

ClickHouse поддерживает как SQL-стиль, так и C-стиль комментарии:

- SQL-стиль комментарии начинаются с `--`, `#!` или `# ` и продолжаются до конца строки. Пробел после `--` и `#!` можно опустить.
- C-стиль комментарии охватывают от `/*` до `*/` и могут быть многострочными. Пробелы также не требуются.

## Ключевые слова {#keywords}

Ключевые слова в ClickHouse могут быть либо _чувствительными к регистру_, либо _не чувствительными к регистру_, в зависимости от контекста.

Ключевые слова являются **не чувствительными к регистру**, когда они соответствуют:

- Стандарту SQL. Например, `SELECT`, `select` и `SeLeCt` все являются допустимыми.
- Реализации в некоторых популярных СУБД (MySQL или Postgres). Например, `DateTime` то же самое, что и `datetime`.

:::note
Вы можете проверить, чувствительно ли имя типа данных с помощью таблицы [system.data_type_families](/operations/system-tables/data_type_families).
:::

В отличие от стандартного SQL, все другие ключевые слова (включая имена функций) являются **чувствительными к регистру**.

Более того, ключевые слова не являются зарезервированными. 
Они рассматриваются как таковые только в соответствующем контексте. 
Если вы используете [идентификаторы](#identifiers) с тем же именем, что и ключевые слова, оберните их в двойные кавычки или обратные кавычки. 

Например, следующий запрос действителен, если в таблице `table_name` есть колонка с именем `"FROM"`:

```sql
SELECT "FROM" FROM table_name
```

## Идентификаторы {#identifiers}

Идентификаторы это:

- Имена кластера, базы данных, таблицы, партиции и колонки.
- [Функции](#functions).
- [Типы данных](../sql-reference/data-types/index.md).
- [Псевдонимы выражений](#expression-aliases).

Идентификаторы могут быть как с кавычками, так и без, хотя последние предпочтительнее.

Необрамленные идентификаторы должны соответствовать регулярному выражению `^[a-zA-Z_][0-9a-zA-Z_]*$` и не могут быть равны [ключевым словам](#keywords).
Смотрите таблицу ниже для примеров допустимых и недопустимых идентификаторов:

| Допустимые идентификаторы                   | Недопустимые идентификаторы                |
|---------------------------------------------|-------------------------------------------|
| `xyz`, `_internal`, `Id_with_underscores_123_` | `1x`, `tom@gmail.com`, `äußerst_schön`   |


Если вы хотите использовать идентификаторы, совпадающие с ключевыми словами, или вы хотите использовать другие символы в идентификаторах, заключите это в двойные кавычки или обратные кавычки, например, `"id"`, `` `id` ``.

:::note
Те же правила, которые применяются для экранирования вquoted идентификаторах, также применяются для строковых литералов. Смотрите раздел [Строка](#string) для получения дополнительных деталей.
:::

## Литералы {#literals}

В ClickHouse литерал – это значение, которое представлено непосредственно в запросе.
Другими словами, это фиксированное значение, которое не изменяется в процессе выполнения запроса.

Литералы могут быть:
- [Строковыми](#string)
- [Числовыми](#numeric)
- [Составными](#compound)
- [`NULL`](#null)
- [Heredocs](#heredoc) (пользовательские строковые литералы)

Мы рассмотрим каждую из этих категорий более подробно в следующих разделах.

### Строка {#string}

Строковые литералы должны быть заключены в одиночные кавычки. Двойные кавычки не поддерживаются.

Экранирование работает либо путем:

- использования предшествующей одиночной кавычки, где символ одиночной кавычки `'` (и только этот символ) может быть экранирован как `''`, или
- использования предшествующей обратной косой черты с перечислением поддерживаемых escape-последовательностей, приведенных в таблице ниже.

:::note
Обратная косая черта теряет свое специальное значение, т.е. она интерпретируется буквально, если она предшествует символам, отличным от тех, что перечислены ниже.
:::

| Поддерживаемое экранирование               | Описание                                                             |
|---------------------------------------------|-------------------------------------------------------------------------|
| `\xHH`                                      | Спецификация 8-битного символа, сопровождаемая любым количеством шестнадцатеричных цифр (H). | 
| `\N`                                        | зарезервировано, ничего не делает (например, `SELECT 'a\Nb'` возвращает `ab`)                |
| `\a`                                        | сигнал                                                                   |
| `\b`                                        | возврат на одну позицию назад                                          |
| `\e`                                        | символ экранирования                                                   |
| `\f`                                        | перевод страницы                                                        |
| `\n`                                        | перевод строки                                                         |
| `\r`                                        | возврат каретки                                                        |
| `\t`                                        | горизонтальная табуляция                                               |
| `\v`                                        | вертикальная табуляция                                                  |
| `\0`                                        | нулевой символ                                                         |
| `\\`                                        | обратная косая черта                                                   |
| `\'` (или ` '' `)                           | одиночная кавычка                                                      |
| `\"`                                        | двойная кавычка                                                        |
| `` ` ``                                     | обратная кавычка                                                      |
| `\/`                                        | косая черта                                                            |
| `\=`                                        | знак равенства                                                          |
| ASCII управляющие символы (c &lt;= 31).    |                                                                      |

:::note
В строковых литералах вы должны экранировать по крайней мере `'` и `\`, используя коды экранирования `\'` (или: `''`) и `\\`.
:::

### Числовой {#numeric}

Числовые литералы разбираются следующим образом:

- Сначала как 64-разрядное знаковое число с использованием функции [strtoull](https://en.cppreference.com/w/cpp/string/byte/strtoul).
- Если это не удается, как 64-разрядное беззнаковое число с использованием функции [strtoll](https://en.cppreference.com/w/cpp/string/byte/strtol).
- Если это не удается, как число с плавающей запятой с использованием функции [strtod](https://en.cppreference.com/w/cpp/string/byte/strtof).
- В противном случае возвращается ошибка.

Литералы преобразуются в наименьший тип, в который они помещаются.
Например:
- `1` интерпретируется как `UInt8`
- `256` интерпретируется как `UInt16`. 

Для получения дополнительной информации смотрите [Типы данных](../sql-reference/data-types/index.md).

Подчеркивания `_` внутри числовых литералов игнорируются и могут использоваться для улучшения читаемости.

Поддерживаются следующие числовые литералы:

| Числовой литерал                           | Примеры                                        |
|--------------------------------------------|-------------------------------------------------|
| **Целые числа**                           | `1`, `10_000_000`, `18446744073709551615`, `01` |
| **Десятичные**                            | `0.1`                                           |
| **Экспоненциальное представление**       | `1e100`, `-1e-100`                              |
| **Числа с плавающей точкой**             | `123.456`, `inf`, `nan`                         |
| **Шестнадцатеричные**                     | `0xc0fe`                                        |
| **Шестнадцатеричная строка, совместимая со стандартом SQL** | `x'c0fe'`                                       |
| **Двоичные**                              | `0b1101`                                        |
| **Двоичная строка, совместимая со стандартом SQL** | `b'1101'`                                       |

:::note
Восьмеричные литералы не поддерживаются, чтобы избежать случайных ошибок интерпретации.
:::

### Составной {#compound}

Массивы создаются с помощью квадратных скобок `[1, 2, 3]`. Кортежи создаются с помощью круглых скобок `(1, 'Hello, world!', 2)`.
Технически это не литералы, а выражения с оператором создания массива и оператором создания кортежа соответственно.
Массив должен состоять как минимум из одного элемента, а кортеж должен содержать как минимум два элемента.

:::note
Существует отдельный случай, когда кортежи появляются в условии `IN` запроса `SELECT`. 
Результаты запроса могут включать кортежи, но кортежи не могут быть сохранены в базе данных (за исключением таблиц, использующих движок [Memory](../engines/table-engines/special/memory.md)).
:::

### NULL {#null}

`NULL` используется для указания на отсутствие значения. 
Чтобы сохранить `NULL` в поле таблицы, оно должно быть типа [Nullable](../sql-reference/data-types/nullable.md).

:::note
Следует отметить следующее о `NULL`:

- В зависимости от формата данных (входного или выходного) `NULL` может иметь разное представление. Для получения дополнительной информации смотрите [форматы данных](/interfaces/formats).
- Обработка `NULL` имеет свои особенности. Например, если хотя бы один из аргументов операции сравнения равен `NULL`, результат этой операции также будет `NULL`. То же самое справедливо для умножения, сложения и других операций. Рекомендуем ознакомиться с документацией для каждой операции.
- В запросах вы можете проверять `NULL`, используя операторы [`IS NULL`](/sql-reference/functions/functions-for-nulls#isnull) и [`IS NOT NULL`](/sql-reference/functions/functions-for-nulls#isnotnull) и связанные функции `isNull` и `isNotNull`.
:::

### Heredoc {#heredoc}

[Heredoc](https://en.wikipedia.org/wiki/Here_document) — это способ определения строки (часто многострочной), сохраняя оригинальное форматирование. 
Heredoc определяется как пользовательский строковый литерал, помещенный между двумя символами `$`.

Например:

```sql
SELECT $heredoc$SHOW CREATE VIEW my_view$heredoc$;

┌─'SHOW CREATE VIEW my_view'─┐
│ SHOW CREATE VIEW my_view   │
└────────────────────────────┘
```

:::note
- Значение между двумя heredocs обрабатывается "как есть".
:::

:::tip
- Вы можете использовать heredoc для встраивания фрагментов SQL, HTML или XML кода и т.д.
:::

## Определение и использование параметров запроса {#defining-and-using-query-parameters}

Параметры запроса позволяют вам писать обобщенные запросы, которые содержат абстрактные заполнители вместо конкретных идентификаторов. 
Когда запрос с параметрами выполняется, 
все заполнители разрешаются и заменяются фактическими значениями параметров запроса.

Существует два способа определения параметра запроса:

- `SET param_<name>=<value>`
- `--param_<name>='<value>'`

При использовании второго варианта он передается в качестве аргумента к `clickhouse-client` на командной строке, где:
- `<name>` – это имя параметра запроса.
- `<value>` – это его значение.

Параметр запроса можно ссылаться в запросе, используя `{<name>: <datatype>}`, где `<name>` – это имя параметра запроса, а `<datatype>` – это тип данных, в который он преобразуется.

<details>
<summary>Пример с командой SET</summary>

Например, следующий SQL определяет параметры с именами `a`, `b`, `c` и `d` - каждый с разным типом данных:

```sql
SET param_a = 13;
SET param_b = 'str';
SET param_c = '2022-08-04 18:30:53';
SET param_d = {'10': [11, 12], '13': [14, 15]};

SELECT
   {a: UInt32},
   {b: String},
   {c: DateTime},
   {d: Map(String, Array(UInt8))};

13    str    2022-08-04 18:30:53    {'10':[11,12],'13':[14,15]}
```
</details>

<details>
<summary>Пример с clickhouse-client</summary>

Если вы используете `clickhouse-client`, параметры указываются как `--param_name=value`. Например, следующий параметр имеет имя `message`, и он извлекается как `String`:

```bash
clickhouse-client --param_message='hello' --query="SELECT {message: String}"

hello
```

Если параметр запроса представляет собой имя базы данных, таблицы, функции или другого идентификатора, используйте `Identifier` для его типа. Например, следующий запрос возвращает строки из таблицы с именем `uk_price_paid`:

```sql
SET param_mytablename = "uk_price_paid";
SELECT * FROM {mytablename:Identifier};
```
</details>

:::note
Параметры запроса не являются общими заменами текста, которые могут использоваться в произвольных местах в произвольных SQL запросах. 
Они в первую очередь предназначены для работы в `SELECT` выражениях на месте идентификаторов или литералов.
:::

## Функции {#functions}

Вызовы функций записываются как идентификатор с перечислением аргументов (возможно, пустых) в круглых скобках. 
В отличие от стандартного SQL, скобки обязательны, даже для пустого списка аргументов. 
Например: 

```sql
now()
```

Также есть:
- [Обычные функции](/sql-reference/functions/overview).
- [Агрегатные функции](/sql-reference/aggregate-functions).

Некоторые агрегатные функции могут содержать два списка аргументов в скобках. Например: 

```sql
quantile (0.9)(x) 
```

Эти агрегатные функции называются "параметрическими" функциями, 
а аргументы в первом списке называются "параметрами".

:::note
Синтаксис агрегатных функций без параметров такой же, как для обычных функций.
:::

## Операторы {#operators}

Операторы преобразуются в соответствующие функции во время разбора запроса с учетом их приоритета и ассоциативности.

Например, выражение 

```text
1 + 2 * 3 + 4
```

преобразуется в 

```text
plus(plus(1, multiply(2, 3)), 4)`
```

## Типы данных и движки таблиц базы данных {#data-types-and-database-table-engines}

Типы данных и движки таблиц в запросе `CREATE` записываются так же, как идентификаторы или функции. 
Другими словами, они могут или не могут содержать список аргументов в скобках. 

Для получения дополнительной информации смотрите разделы:
- [Типы данных](/sql-reference/data-types/index.md)
- [Движки таблиц](/engines/table-engines/index.md)
- [CREATE](/sql-reference/statements/create/index.md).

## Выражения {#expressions}

Выражение может быть следующим: 
- функция
- идентификатор
- литерал
- применение оператора
- выражение в скобках
- подзапрос
- или звездочка. 

Оно также может содержать [псевдоним](#expression-aliases).

Список выражений – это одно или несколько выражений, разделенных запятыми.
Функции и операторы, в свою очередь, могут иметь выражения в качестве аргументов.

## Псевдонимы выражений {#expression-aliases}

Псевдоним – это определенное пользователем имя для [выражения](#expressions) в запросе.

```sql
expr AS alias
```

Части синтаксиса выше объясняются ниже.

| Часть синтаксиса | Описание                                                                                                                                      | Пример                                                                 | Заметки                                                                                                                                                |
|------------------|------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `AS`             | Ключевое слово для определения псевдонимов. Можно определить псевдоним для имени таблицы или имени колонки в предложении `SELECT`, не используя ключевое слово `AS`. | `SELECT table_name_alias.column_name FROM table_name table_name_alias`. | В функции [CAST](/sql-reference/functions/type-conversion-functions#cast) ключевое слово `AS` имеет другое значение. Смотрите описание функции.   |
| `expr`           | Любое выражение, поддерживаемое ClickHouse.                                                                                                   | `SELECT column_name * 2 AS double FROM some_table`                      |                                                                                                                                                      |
| `alias`          | Имя для `expr`. Псевдонимы должны соответствовать синтаксису [идентификаторов](#identifiers).                                                   | `SELECT "table t".column_name FROM table_name AS "table t"`.            |                                                                                                                                                      |

### Заметки по использовании {#notes-on-usage}

- Псевдонимы глобальны для запроса или подзапроса, и вы можете определить псевдоним в любой части запроса для любого выражения. Например:

```sql
SELECT (1 AS n) + 2, n`.
```

- Псевдонимы не видны в подзапросах и между подзапросами. Например, при выполнении следующего запроса ClickHouse генерирует исключение `Unknown identifier: num`:

```sql
`SELECT (SELECT sum(b.a) + num FROM b) - a.a AS num FROM a`
```

- Если псевдоним определен для результирующих колонок в предложении `SELECT` подзапроса, эти колонки видны в внешнем запросе. Например:

```sql
SELECT n + m FROM (SELECT 1 AS n, 2 AS m)`.
```

- Будьте осторожны с псевдонимами, которые совпадают с именами колонок или таблиц. Рассмотрим следующий пример:

```sql
CREATE TABLE t
(
    a Int,
    b Int
)
ENGINE = TinyLog();

SELECT
    argMax(a, b),
    sum(b) AS b
FROM t;

Получено исключение от сервера (версия 18.14.17):
Код: 184. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: Aggregate function sum(b) is found inside another aggregate function in query.
```

В приведенном выше примере мы объявили таблицу `t` с колонкой `b`. 
Затем, при выборе данных, мы определили псевдоним `sum(b) AS b`. 
Поскольку псевдонимы глобальны, 
ClickHouse заменил литерал `b` в выражении `argMax(a, b)` на выражение `sum(b)`. 
Эта замена и вызвала исключение.

:::note
Вы можете изменить это поведение по умолчанию, установив [prefer_column_name_to_alias](/operations/settings/settings#prefer_column_name_to_alias) в `1`.
:::

## Звездочка {#asterisk}

В запросе `SELECT` звездочка может заменить выражение. 
Для получения дополнительной информации смотрите раздел [SELECT](/sql-reference/statements/select/index.md#asterisk).
