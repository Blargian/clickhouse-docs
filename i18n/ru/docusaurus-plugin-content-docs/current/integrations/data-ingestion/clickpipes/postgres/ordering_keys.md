---
sidebar_label: 'Ключи сортировки'
description: 'Как определить пользовательские ключи сортировки.'
slug: /integrations/clickpipes/postgres/ordering_keys
title: 'Ключи Сортировки'
---

Ключи сортировки (также известные как ключи упорядочивания) определяют, как данные сортируются на диске и индексируются для таблицы в ClickHouse. При репликации из Postgres ClickPipes устанавливает первичный ключ Postgres таблицы в качестве ключа сортировки для соответствующей таблицы в ClickHouse. В большинстве случаев первичный ключ Postgres служит достаточно хорошим ключом сортировки, так как ClickHouse уже оптимизирован для быстрых сканов, и пользовательские ключи сортировки часто не требуются.

Как описано в [руководстве по миграции](/migrations/postgresql/data-modeling-techniques), для более крупных случаев использования вы должны включить дополнительные колонки помимо первичного ключа Postgres в ключ сортировки ClickHouse для оптимизации запросов.

По умолчанию при использовании CDC выбор ключа сортировки, отличного от первичного ключа Postgres, может привести к проблемам с дедупликацией данных в ClickHouse. Это происходит потому, что ключ сортировки в ClickHouse выполняет двойную роль: контролирует индексирование и сортировку данных, действуя как ключ дедупликации. Самый простой способ решить эту проблему - это определить обновляемые материализованные представления.

## Использование обновляемых материализованных представлений {#use-refreshable-materialized-views}

Простой способ определить пользовательские ключи сортировки (ORDER BY) - использовать [обновляемые материализованные представления](/materialized-view/refreshable-materialized-view) (МВ). Эти представления позволяют вам периодически (например, каждые 5 или 10 минут) копировать всю таблицу с желаемым ключом сортировки.

Ниже приведен пример обновляемого МВ с кастомным ORDER BY и необходимой дедупликацией:

```sql
CREATE MATERIALIZED VIEW posts_final
REFRESH EVERY 10 second ENGINE = ReplacingMergeTree(_peerdb_version)
ORDER BY (owneruserid,id) -- другой ключ сортировки, но с добавленным первичным ключом postgres
AS
SELECT * FROM posts FINAL 
WHERE _peerdb_is_deleted = 0; -- это выполняет дедупликацию
```

## Пользовательские ключи сортировки без обновляемых материализованных представлений {#custom-ordering-keys-without-refreshable-materialized-views}

Если обновляемые материализованные представления не работают из-за объема данных, вот несколько рекомендаций, которые вы можете использовать для определения пользовательских ключей сортировки на больших таблицах и преодоления проблем, связанных с дедупликацией.

### Выберите колонки ключа сортировки, которые не изменяются для данной строки {#choose-ordering-key-columns-that-dont-change-for-a-given-row}

При включении дополнительных колонок в ключ сортировки для ClickHouse (в дополнение к первичному ключу из Postgres) мы рекомендуем выбирать колонки, которые не изменяются для каждой строки. Это помогает избежать проблем с согласованностью данных и дедупликацией с ReplacingMergeTree.

Например, в многоарендном SaaS-приложении использование (`tenant_id`, `id`) в качестве ключа сортировки является хорошим выбором. Эти колонки уникально идентифицируют каждую строку, и `tenant_id` остается постоянным для `id`, даже если другие колонки изменяются. Поскольку дедупликация по id совпадает с дедупликацией по (tenant_id, id), это помогает избежать проблем с [дедупликацией данных](https://docs.peerdb.io/mirror/ordering-key-different), которые могут возникнуть, если tenant_id изменится.

### Установите Replica Identity для таблиц Postgres на пользовательский ключ сортировки {#set-replica-identity-on-postgres-tables-to-custom-ordering-key}

Для корректной работы CDC Postgres важно изменить `REPLICA IDENTITY` на таблицах, чтобы включить колонки ключа сортировки. Это необходимо для правильной обработки DELETE.

Если `REPLICA IDENTITY` не включает колонки ключа сортировки, CDC Postgres не захватит значения колонок, отличных от первичного ключа - это ограничение логического декодирования Postgres. Все колонки ключа сортировки, помимо первичного ключа в Postgres, будут содержать null. Это влияет на дедупликацию, что означает, что предыдущая версия строки может не быть дедуплицирована с последней удаленной версией (где `_peerdb_is_deleted` установлен в 1).

В приведенном выше примере с `owneruserid` и `id`, если первичный ключ еще не включает `owneruserid`, вам нужно создать `UNIQUE INDEX` на (`owneruserid`, `id`) и установить его в качестве `REPLICA IDENTITY` для таблицы. Это гарантирует, что CDC Postgres захватывает необходимые значения колонок для точной репликации и дедупликации.

Ниже приведен пример, как это сделать на таблице событий. Убедитесь, что вы применили это ко всем таблицам с измененными ключами сортировки.

```sql
-- Создать уникальный индекс на (owneruserid, id)
CREATE UNIQUE INDEX posts_unique_owneruserid_idx ON posts(owneruserid, id);
-- Установить REPLICA IDENTITY для использования этого индекса
ALTER TABLE posts REPLICA IDENTITY USING INDEX posts_unique_owneruserid_idx;
```
