description: 'ClickHouse C++開発のコーディングスタイルガイドライン'
sidebar_label: 'C++スタイルガイド'
sidebar_position: 70
slug: /development/style
title: 'C++スタイルガイド'
```


# C++スタイルガイド

## 一般的な推奨事項 {#general-recommendations}

以下は推奨事項であり、必須ではありません。
コードを編集する場合は、既存のコードのフォーマットに従うことが理にかなっています。
コードスタイルは一貫性のために必要です。一貫性があれば、コードを読みやすくし、検索もしやすくなります。
多くのルールには論理的な理由がない場合があります。それらは確立された慣習によって dictated されています。

## フォーマッティング {#formatting}

**1.** ほとんどのフォーマットは `clang-format` によって自動的に行われます。

**2.** インデントは4スペースです。タブを追加すると4スペースになるように開発環境を構成してください。

**3.** 開始および終了の波括弧は別の行に置かなければなりません。

```cpp
inline void readBoolText(bool & x, ReadBuffer & buf)
{
    char tmp = '0';
    readChar(tmp, buf);
    x = tmp != '0';
}
```

**4.** 関数本体全体が単一の `statement` である場合、それは単一行に配置することができます。波括弧の前後にはスペースを置きます（行の末尾のスペースの他に）。

```cpp
inline size_t mask() const                { return buf_size() - 1; }
inline size_t place(HashValue x) const    { return x & mask(); }
```

**5.** 関数の場合。括弧の周囲にはスペースを入れないでください。

```cpp
void reinsert(const Value & x)
```

```cpp
memcpy(&buf[place_value], &x, sizeof(x));
```

**6.** `if`、`for`、`while` およびその他の式では、開き括弧の前にスペースを挿入します（関数呼び出しとは対照的に）。

```cpp
for (size_t i = 0; i < rows; i += storage.index_granularity)
```

**7.** 二項演算子 (`+`、`-`、`*`、`/`、`%`、…) および三項演算子 `?:` の周りにはスペースを追加します。

```cpp
UInt16 year = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
UInt8 month = (s[5] - '0') * 10 + (s[6] - '0');
UInt8 day = (s[8] - '0') * 10 + (s[9] - '0');
```

**8.** 改行が入力された場合、演算子を新しい行に置き、前にインデントを増やします。

```cpp
if (elapsed_ns)
    message << " ("
        << rows_read_on_server * 1000000000 / elapsed_ns << " rows/s., "
        << bytes_read_on_server * 1000.0 / elapsed_ns << " MB/s.) ";
```

**9.** 行内の整列のためにスペースを使用することができます。

```cpp
dst.ClickLogID         = click.LogID;
dst.ClickEventID       = click.EventID;
dst.ClickGoodEvent     = click.GoodEvent;
```

**10.** 演算子 `.`、`->` の周りにはスペースを使用しないでください。

必要に応じて、演算子を次の行に折り返すことができます。この場合、前のオフセットを増やします。

**11.** 単項演算子（`--`、`++`、`*`、`&`、…) と引数を区切るためにスペースを使用しないでください。

**12.** コンマの後にはスペースを入れますが、前には入れません。同じルールは `for` 式内のセミコロンにも当てはまります。

**13.** `[]` 演算子を区切るためにスペースを使用しないでください。

**14.** `template <...>` 式では、`template` と `<` の間にスペースを使用し、`<` の後や `>` の前にはスペースを置かないでください。

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
{}
```

**15.** クラスおよび構造体では、`public`、`private`、`protected` を `class/struct` と同じレベルに書き、その他のコードをインデントします。

```cpp
template <typename T>
class MultiVersion
{
public:
    /// 使用のためのオブジェクトのバージョン。shared_ptrがバージョンの寿命を管理します。
    using Version = std::shared_ptr<const T>;
    ...
}
```

**16.** 同じ `namespace` がファイル全体で使用されている場合、特に他に重要なものがない限り、`namespace` 内ではオフセットは必要ありません。

**17.** `if`、`for`、`while`、または他の式のブロックが単一の `statement` で構成されている場合、波括弧は省略可能です。代わりに `statement` を別の行に置きます。このルールは入れ子の `if`、`for`、`while` にも適用されます。

ただし、内部の `statement` に波括弧や `else` が含まれている場合は、外部ブロックを波括弧で記述する必要があります。

```cpp
/// 書き込みを完了します。
for (auto & stream : streams)
    stream.second->finalize();
```

**18.** 行の末尾にはスペースを置かないでください。

**19.** ソースファイルはUTF-8でエンコードされています。

**20.** ストリングリテラルに非ASCII文字を使用できます。

```cpp
<< ", " << (timer.elapsed() / chunks_stats.hits) << " μsec/hit.";
```

**21.** 単一の行に複数の式を書くことは避けてください。

**22.** 関数の内部にコードのセクションをグループ化し、それらを1行の空白で区切ります。

**23.** 関数、クラスなどを1行または2行の空白で区切ります。

**24.** `A const`（値に関連する）は型名の前に書かなければなりません。

```cpp
//正しい
const char * pos
const std::string & s
//不正
char const * pos
```

**25.** ポインタや参照を宣言するときは、`*` および `&` 記号は両側にスペースを入れるべきです。

```cpp
//正しい
const char * pos
//不正
const char* pos
const char *pos
```

**26.** テンプレートタイプを使用する場合は、`using` キーワードを使用してエイリアスを付けてください（最も簡単なケースを除く）。

言い換えれば、テンプレートパラメータは `using` だけで指定し、コード中で繰り返すべきではありません。

`using` は、関数内部のようにローカルに宣言できます。

```cpp
//正しい
using FileStreams = std::map<std::string, std::shared_ptr<Stream>>;
FileStreams streams;
//不正
std::map<std::string, std::shared_ptr<Stream>> streams;
```

**27.** 異なる型の複数の変数を1つの文で宣言しないでください。

```cpp
//不正
int x, *y;
```

**28.** Cスタイルのキャストを使用しないでください。

```cpp
//不正
std::cerr << (int)c <<; std::endl;
//正しい
std::cerr << static_cast<int>(c) << std::endl;
```

**29.** クラスおよび構造体では、メンバーと関数を各可視性スコープ内で別々にグループ化します。

**30.** 小さなクラスや構造体の場合は、メソッドの宣言と実装を分ける必要はありません。

同じことが、いかなるクラスや構造体内の小さなメソッドにも当てはまります。

テンプレートクラスや構造体では、メソッドの宣言を実装から分けないでください（そうしないと、同じ翻訳単位で定義しなければならなくなるため）。

**31.** 行を140文字で折り返すことはできますが、80文字で折り返すことはありません。

**32.** 必要でない場合は、後置インクリメント/デクリメント演算子を盲目的に使用しないでください。

```cpp
for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)
```

## コメント {#comments}

**1.** コードの全ての非自明な部分についてコメントを追加してください。

これは非常に重要です。コメントを書くことで、そのコードが不要であるか、または設計が間違っていると気づくことがあります。

```cpp
/** 使用可能なメモリ部分。
  * 例えば、internal_buffer が1MBで、ファイルから読み込んだバイト数が10バイトしかない場合、
  * working_buffer のサイズはわずか10バイトになります。
  * (working_buffer.end() は、10バイトの後ろにある読み取り可能な位置を指します)。
  */
```

**2.** コメントは必要に応じて詳細にしてください。

**3.** コメントは、その内容を記述するコードの前に置いてください。稀に、コメントはコードの後、同じ行に来ることがあります。

```cpp
/** クエリを解析し、実行します。
*/
void executeQuery(
    ReadBuffer & istr, /// どこからクエリを読むか（INSERTにデータが必要な場合）
    WriteBuffer & ostr, /// 結果を書く場所
    Context & context, /// DB、テーブル、データ型、エンジン、関数、集約関数...
    BlockInputStreamPtr & query_plan, /// クエリがどのように実行されたかの説明がここに書かれることがあります
    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// SELECTクエリをどの段階まで処理するか
    )
```

**4.** コメントは英語でのみ書いてください。

**5.** ライブラリを書く場合は、メインヘッダーファイルに詳細なコメントを含めてください。

**6.** 追加情報を提供しないコメントは追加しないでください。特に、次のような空のコメントを残さないでください：

```cpp
/*
* 手続き名：
* 元の手続き名：
* 作者：
* 作成日：
* 修正日：
* 修正者：
* 元のファイル名：
* 目的：
* 意図：
* 指名：
* 使用されるクラス：
* 定数：
* ローカル変数：
* パラメータ：
* 作成日：
* 目的：
*/
```

この例は、リソース http://home.tamk.fi/~jaalto/course/coding-style/doc/unmaintainable-code/ から借用しています。

**7.** 各ファイルの冒頭に、無駄なコメント（作者、作成日など）を書く必要はありません。

**8.** 単一行のコメントは3つのスラッシュ `///` で始まり、複数行のコメントは `/**` で始まります。これらのコメントは「ドキュメンテーション」と見なされます。

注意：これらのコメントからドキュメンテーションを生成するためにDoxygenを使用できます。しかしDoxygenは一般的に使用されません、なぜならIDE内でコードをナビゲートする方が便利だからです。

**9.** 複数行のコメントは、開始と終了に空白行があってはいけません（複数行コメントを閉じる行を除く）。

**10.** コードをコメントアウトするためには基本的なコメントを使用し、"ドキュメンテーション"コメントを使用しないでください。

**11.** コミットする前にコードのコメントアウトされた部分を削除してください。

**12.** コメントやコードに不適切な言葉を使用しないでください。

**13.** 大文字を使用しないでください。過度の句読点を避けます。

```cpp
/// なんだこれは???
```

**14.** デリミタを作成するためにコメントを使用しないでください。

```cpp
///******************************************************
```

**15.** コメント内で議論を開始する必要はありません。

```cpp
/// なぜこれをやったのですか？
```

**16.** ブロックの終わりに、その内容を説明するコメントを書く必要はありません。

```cpp
/// for
```

## 名前 {#names}

**1.** 変数およびクラスメンバーの名前にはアンダースコアを使用して小文字を使用します。

```cpp
size_t max_block_size;
```

**2.** 関数（メソッド）の名前には小文字で始まるキャメルケースを使用します。

```cpp
std::string getName() const override { return "Memory"; }
```

**3.** クラス（構造体）の名前には大文字で始まるキャメルケースを使用します。他のプレフィックスはインターフェースには使用しません。

```cpp
class StorageMemory : public IStorage
```

**4.** `using` はクラスと同じように名前が付けられます。

**5.** テンプレート型引数の名前：単純なケースでは `T`、`T`、`U`、`T1`、`T2` を使用します。

より複雑な場合は、クラス名に関する規則に従うか、プレフィックス `T` を追加します。

```cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
```

**6.** テンプレート定数引数の名前：変数名の規則に従うか、単純な場合は `N` を使用します。

```cpp
template <bool without_www>
struct ExtractDomain
```

**7.** 抽象クラス（インターフェース）では `I` プレフィックスを追加できます。

```cpp
class IProcessor
```

**8.** 変数をローカルで使用する場合は、短い名前を使用することができます。

それ以外の場合は、意味を説明する名前を使用してください。

```cpp
bool info_successfully_loaded = false;
```

**9.** `define`s とグローバル定数の名前はALL_CAPSとアンダースコアを使用します。

```cpp
#define MAX_SRC_TABLE_NAMES_TO_STORE 1000
```

**10.** ファイル名はその内容と同じスタイルを使用するべきです。

ファイルが単一のクラスを含む場合、ファイルの名前はそのクラスと同じにします（キャメルケース）。

ファイルが単一の関数を含む場合、ファイルの名前はその関数と同じにします（キャメルケース）。

**11.** 名前に略語が含まれている場合：

- 変数名の場合、略語は小文字で使用するべきです `mysql_connection`（`mySQL_connection`ではありません）。
- クラスと関数の名前の場合、略語の大文字を保持します `MySQLConnection`（`MySqlConnection`ではありません）。

**12.** クラスメンバーを初期化するためだけに使用されるコンストラクタ引数は、クラスメンバーと同じ方法で名前を付けるべきですが、末尾にアンダースコアを付けます。

```cpp
FileQueueProcessor(
    const std::string & path_,
    const std::string & prefix_,
    std::shared_ptr<FileHandler> handler_)
    : path(path_),
    prefix(prefix_),
    handler(handler_),
    log(&Logger::get("FileQueueProcessor"))
{
}
```

アンダースコアの接尾辞は、引数がコンストラクタ本体で使用されない場合は省略できます。

**13.** ローカル変数とクラスメンバーの名前に違いはありません（プレフィックスは必要ありません）。

```cpp
timer (not m_timer)
```

**14.** `enum` の定数には、キャメルケースの大文字を使用します。ALL_CAPSも許可されます。`enum` が非ローカルな場合は、`enum class` を使用します。

```cpp
enum class CompressionMethod
{
    QuickLZ = 0,
    LZ4     = 1,
};
```

**15.** すべての名前は英語でなければなりません。ヘブライ語の言葉の音訳は許可されていません。

    not T_PAAMAYIM_NEKUDOTAYIM

**16.** 略語は一般に知られていれば受け入れられます（略語の意味を簡単に見つけられる場合）。

    `AST`、`SQL`。

    `NVDH`（ランダムな文字の集まり）は使用しないでください。

不完全な単語は、一般的に使用される短縮版であれば受け入れられます。

フルネームがその隣にコメントとして含まれている場合は、略語を使用することもできます。

**17.** C++ソースコードを含むファイルは `.cpp` 拡張子を持っているべきです。ヘッダーファイルは `.h` 拡張子を持っているべきです。

## コードの書き方 {#how-to-write-code}

**1.** メモリ管理。

手動メモリ解放（`delete`）はライブラリコードでのみ使用できます。

ライブラリコードでは、デストラクタでのみ `delete` 演算子を使用できます。

アプリケーションコードでは、メモリはその所有者によって解放されなければなりません。

例：

- 一番簡単な方法は、オブジェクトをスタック上に置くか、他のクラスのメンバーにすることです。
- 小規模なオブジェクトがたくさんある場合、コンテナを使用します。
- ヒープに存在する少数のオブジェクトを自動的に解放するために `shared_ptr/unique_ptr` を使用します。

**2.** リソース管理。

`RAII` を使用し、上記を参照してください。

**3.** エラーハンドリング。

例外を使用します。ほとんどの場合、例外をスローするだけで、捕まえる必要はありません（`RAII` のため）。

オフラインデータ処理アプリケーションでは、例外を捕まえないことが容認されることがよくあります。

ユーザー要求を処理するサーバーでは、通常、接続ハンドラーのトップレベルで例外を捕まえるだけで十分です。

スレッド関数では、すべての例外を捕まえ、メインスレッドで再スローするために保持するべきです。

```cpp
/// まだ計算が行われていない場合は、最初のブロックを同期的に計算します
if (!started)
{
    calculate();
    started = true;
}
else /// 計算がすでに進行中の場合は、結果を待ちます
    pool.wait();

if (exception)
    exception->rethrow();
```

例外を処理せずに隠さないでください。単に盲目的にすべての例外をログに記録することは決してしないでください。

```cpp
//不正
catch (...) {}
```

いくつかの例外を無視する必要がある場合は、特定の例外に対してのみそうし、残りを再スローしてください。

```cpp
catch (const DB::Exception & e)
{
    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)
        return nullptr;
    else
        throw;
}
```

応答コードや `errno` を使用する関数を使用する場合は、常に結果を確認し、エラーが発生した場合は例外をスローしてください。

```cpp
if (0 != close(fd))
    throw ErrnoException(ErrorCodes::CANNOT_CLOSE_FILE, "Cannot close file {}", file_name);
```

コード内の不変条件を確認するために `assert` を使用することができます。

**4.** 例外の種類。

アプリケーションコードでは、複雑な例外階層を使用する必要はありません。例外のテキストは、システム管理者が理解できるものであるべきです。

**5.** デストラクタからの例外スロー。

これは推奨されていませんが、許可されています。

以下のオプションを使用してください。

- 処理を行う関数（`done()` や `finalize()`）を作成し、その中で例外を引き起こす可能性のあるすべての作業を事前に行います。その関数が呼び出された場合、デストラクタで後に例外が出ることはないはずです。
- ネットワーク経由でメッセージを送信するなど、非常に複雑なタスクは、クラスユーザーが破棄の前に呼び出す必要がある別のメソッドに入れてください。
- デストラクタで例外が発生した場合は、それを隠すのではなくログに記録する方が良いです（ロガーが利用できる場合）。
- 簡単なアプリケーションでは、例外を処理するために `std::terminate` （C++11のデフォルトで `noexcept` の場合）に依存することが許容されます。

**6.** 匿名コードブロック。

特定の変数をローカルにするために、単一の関数内に別のコードブロックを作成し、ブロックを出る時にデストラクタが呼ばれるようにできます。

```cpp
Block block = data.in->read();

{
    std::lock_guard<std::mutex> lock(mutex);
    data.ready = true;
    data.block = block;
}

ready_any.set();
```

**7.** マルチスレッド。

オフラインデータ処理プログラムでは：

- 単一のCPUコアで可能な限り最高のパフォーマンスを得るようにします。その後、必要に応じてコードを並行化できます。

サーバーアプリケーションでは：

- リクエストを処理するためにスレッドプールを使用します。この時点では、ユーザースペースのコンテキストスイッチが必要なタスクはありませんでした。

フォークは並行化のためには使用されません。

**8.** スレッドの同期。

異なるスレッドが異なるメモリセルを使用する（さらに良いことに、異なるキャッシュラインを使用する）ことが可能であり、スレッドの同期を使用しないで済むこともよくあります（`joinAll` を除く）。

同期が必要な場合、ほとんどの場合、`lock_guard` の下でミューテックスを使用するだけで十分です。

他の場合は、システム同期プリミティブを使用してください。ビジーウェイトを使用しないでください。

原子的な操作は、最も単純なケースでのみ使用されるべきです。

ロックフリーのデータ構造を実装しようとはしないでください。そうしないと、その領域の専門でない限り、困難になります。

**9.** ポインタと参照。

ほとんどの場合、参照を優先します。

**10.** `const`。

定数の参照、定数へのポインタ、`const_iterator`、および `const` メソッドを使用します。

`const` をデフォルトとして考え、必要な場合のみ非 `const` を使用します。

変数を値として渡す場合、`const` を使用することは通常意味がありません。

**11.** unsigned。

必要な場合は `unsigned` を使用します。

**12.** 数値型。

`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64` の型、ならびに `size_t`、`ssize_t`、および `ptrdiff_t` を使用します。

これらの型を数値に対して使用しないでください：`signed/unsigned long`、`long long`、`short`、`signed/unsigned char`、`char`。

**13.** 引数の渡し方。

複雑な値は、移動される予定の場合は値で渡し、ループ内で値を更新する場合は参照で渡します。

ヒープで作成されたオブジェクトの所有権を捕らえる関数では、引数タイプを `shared_ptr` または `unique_ptr` にします。

**14.** 戻り値。

ほとんどの場合、単に `return` を使用します。`return std::move(res)` と書かないでください。

関数がヒープ上でオブジェクトを割り当ててそれを返す場合は、`shared_ptr` または `unique_ptr` を使用します。

まれなケース（ループ内での値の更新）では、引数を介して値を返す必要があります。この場合、引数は参照である必要があります。

```cpp
using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;

/** 名前によって集約関数を作成します。
  */
class AggregateFunctionFactory
{
public:
    AggregateFunctionFactory();
    AggregateFunctionPtr get(const String & name, const DataTypes & argument_types) const;
```

**15.** `namespace`。

アプリケーションコードに別の `namespace` を使用する必要はありません。

小規模なライブラリでも必要ありません。

中〜大規模なライブラリでは、すべてを `namespace` に配置します。

ライブラリの `.h` ファイルでは、アプリケーションコードに必要ない実装の詳細を隠すために `namespace detail` を使用できます。

`.cpp` ファイルでは、シンボルを隠すために `static` または匿名の `namespace` を使用できます。

また、`enum` に `namespace` を使用して、対応する名前が外部 `namespace` に入らないようにすることができます（ただし、`enum class` を使用する方が良いです）。

**16.** 遅延初期化。

初期化に引数が必要な場合、通常はデフォルトコンストラクタを書くべきではありません。

後で初期化を遅延させる必要がある場合は、無効なオブジェクトを作成するデフォルトコンストラクタを追加することができます。もしくは、ごく少数のオブジェクトについては `shared_ptr/unique_ptr` を使用できます。

```cpp
Loader(DB::Connection * connection_, const std::string & query, size_t max_block_size_);

/// 遅延初期化用
Loader() {}
```

**17.** 仮想関数。

クラスが多態的な使用を目的としていない場合、関数を仮想にする必要はありません。これもデストラクタに該当します。

**18.** エンコーディング。

どこでもUTF-8を使用してください。`std::string` と `char *` を使用し、`std::wstring` と `wchar_t` は使用しないでください。

**19.** ロギング。

コードのあらゆるところで例を見てください。

コミットする前に、意味のないデバッグログや他のデバッグ出力をすべて削除してください。

サイクル内のロギングは、トレースレベルでさえも避けるべきです。

ログはすべてのロギングレベルで可読可能であるべきです。

ロギングは主にアプリケーションコードでのみ使用されるべきです。

ログメッセージは英語で書かれるべきです。

ログはできるだけシステム管理者に理解できるものでなければなりません。

ログ内で不適切な言葉は使用しないでください。

ログでUTF-8エンコーディングを使用してください。稀に非ASCII文字を使用することができます。

**20.** 入出力。

内部サイクルでアプリケーションパフォーマンスに重要な `iostreams` を使用しないでください（そして `stringstream` は決して使用しないでください）。

代わりに `DB/IO` ライブラリを使用します。

**21.** 日付と時刻。

`DateLUT`ライブラリを参照してください。

**22.** インクルード。

常にインクルードガードの代わりに `#pragma once` を使用してください。

**23.** using。

`using namespace` を使用しない。特定のものとともに `using` を使用できます。ただし、クラスまたは関数内にローカルにしてください。

**24.** 必要でない限り、関数のために `trailing return type` を使用しないでください。

```cpp
auto f() -> void
```

**25.** 変数の宣言と初期化。

```cpp
//正しい方法
std::string s = "Hello";
std::string s{"Hello"};

//不正な方法
auto s = std::string{"Hello"};
```

**26.** 仮想関数に対しては、基底クラスに `virtual` を書きますが、派生クラスには `virtual` の代わりに `override` と書きます。

## C++ の未使用機能 {#unused-features-of-c}

**1.** 仮想継承は使用しません。

**2.** 現代のC++には便利な構文シュガーを持つ構文があります。例：

```cpp
// 構文シュガーなしの従来の方法
template <typename G, typename = std::enable_if_t<std::is_same<G, F>::value, void>> // std::enable_ifによるSFINAE、::valueの使用
std::pair<int, int> func(const E<G> & e) // 明示的に指定された戻り値の型
{
    if (elements.count(e)) // .count() メンバーシップテスト
    {
        // ...
    }

    elements.erase(
        std::remove_if(
            elements.begin(), elements.end(),
            [&](const auto x){
                return x == 1;
            }),
        elements.end()); // remove-eraseイディオム

    return std::make_pair(1, 2); // make_pair() を使用してペアを作成
}

// 構文シュガー（C++14/17/20）
template <typename G>
requires std::same_v<G, F> // C++20の概念によるSFINAE、C++14テンプレートエイリアスの使用
auto func(const E<G> & e) // auto戻り値の型（C++14）
{
    if (elements.contains(e)) // C++20の.contains() メンバーシップテスト
    {
        // ...
    }

    elements.erase_if(
        elements,
        [&](const auto x){
            return x == 1;
        }); // C++20 std::erase_if

    return {1, 2}; // または：return std::pair(1, 2); // 初期化リストまたは値の初期化（C++17）を使用してペアを作成
}
```

## プラットフォーム {#platform}

**1.** 特定のプラットフォーム向けのコードを記述します。

ただし、他の条件が同じである限り、クロスプラットフォームまたはポータブルコードが好まれます。

**2.** 言語：C++20（利用可能な [C++20 機能](https://en.cppreference.com/w/cpp/compiler_support#C.2B.2B20_features) のリストを参照）。

**3.** コンパイラ：`clang`。執筆時点（2025年3月）、コードは clang バージョン >= 19 でコンパイルされます。

標準ライブラリが使用されます（`libc++`）。

**4.** OS：Linux Ubuntu、Precise より古くない。

**5.** コードは x86_64 CPU アーキテクチャのために書かれています。

CPU 命令セットは、私たちのサーバー間でサポートされている最小セットです。現在、これは SSE 4.2 です。

**6.** `-Wall -Wextra -Werror -Weverything` のコンパイルフラグを、いくつかの例外とともに使用します。

**7.** 静的リンクを使用し、静的に接続しにくいライブラリは除外します（`ldd` コマンドの出力を参照）。

**8.** コードはリリース設定で開発され、デバッグされます。

## ツール {#tools}

**1.** KDevelop は良い IDE です。

**2.** デバッグには `gdb`、`valgrind`（`memcheck`）、`strace`、`-fsanitize=...`、または `tcmalloc_minimal_debug` を使用します。

**3.** プロファイリングには `Linux Perf`、`valgrind`（`callgrind`）、または `strace -cf` を使用します。

**4.** ソースは Git にあります。

**5.** アセンブリは `CMake` を使用します。

**6.** プログラムは `deb` パッケージを使用してリリースされます。

**7.** master へのコミットはビルドを壊すべきではありません。

ただし、選択されたリビジョンだけが作業可能と見なされます。

**8.** コードが部分的にしか準備が整っていない場合でも、できるだけ頻繁にコミットを行いましょう。

この目的のためにブランチを使用してください。

`master` ブランチのコードがまだビルド可能でない場合、`push` 前にビルドから除外してください。数日以内に完了するか削除する必要があります。

**9.** 重要でない変更には、ブランチを使用し、それをサーバーに公開します。

**10.** 未使用のコードはリポジトリから削除されます。
