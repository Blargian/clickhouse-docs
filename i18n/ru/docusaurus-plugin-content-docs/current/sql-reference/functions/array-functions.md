
---
description: 'Документация по функциям массивов'
sidebar_label: 'Массивы'
sidebar_position: 10
slug: /sql-reference/functions/array-functions
title: 'Функции массивов'
---

# Функции массивов
## empty {#empty}

Проверяет, является ли входной массив пустым.

**Синтаксис**

```sql
empty([x])
```

Массив считается пустым, если он не содержит никаких элементов.

:::note
Можно оптимизировать с помощью включения [`optimize_functions_to_subcolumns` setting](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только [size0](/sql-reference/data-types/array#array-size) подстолбец, вместо чтения и обработки всего столбца массива. Запрос `SELECT empty(arr) FROM TABLE;` преобразуется в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для [строк](string-functions.md#empty) или [UUID](uuid-functions.md#empty).

**Аргументы**

- `[x]` — Входной массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для пустого массива или `0` для непустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT empty([]);
```

Результат:

```text
┌─empty(array())─┐
│              1 │
└────────────────┘
```
## notEmpty {#notempty}

Проверяет, является ли входной массив непустым.

**Синтаксис**

```sql
notEmpty([x])
```

Массив считается непустым, если он содержит хотя бы один элемент.

:::note
Можно оптимизировать с помощью включения [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только [size0](/sql-reference/data-types/array#array-size) подстолбец, вместо чтения и обработки всего столбца массива. Запрос `SELECT notEmpty(arr) FROM table` преобразуется в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для [строк](string-functions.md#notempty) или [UUID](uuid-functions.md#notempty).

**Аргументы**

- `[x]` — Входной массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для непустого массива или `0` для пустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT notEmpty([1,2]);
```

Результат:

```text
┌─notEmpty([1, 2])─┐
│                1 │
└──────────────────┘
```
## length {#length}

Возвращает количество элементов в массиве.
Тип результата — UInt64.
Функция также работает для строк.

Можно оптимизировать с помощью включения [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только [size0](/sql-reference/data-types/array#array-size) подстолбец, вместо чтения и обработки всего столбца массива. Запрос `SELECT length(arr) FROM table` преобразуется в `SELECT arr.size0 FROM TABLE`.

Псевдоним: `OCTET_LENGTH`
## emptyArrayUInt8 {#emptyarrayuint8}

Возвращает пустой UInt8 массив.

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt8();
```

Результат:

```response
[]
```
## emptyArrayUInt16 {#emptyarrayuint16}

Возвращает пустой UInt16 массив.

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt16();

```

Результат:

```response
[]
```
## emptyArrayUInt32 {#emptyarrayuint32}

Возвращает пустой UInt32 массив.

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt32();
```

Результат:

```response
[]
```
## emptyArrayUInt64 {#emptyarrayuint64}

Возвращает пустой UInt64 массив.

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt64();
```

Результат:

```response
[]
```
## emptyArrayInt8 {#emptyarrayint8}

Возвращает пустой Int8 массив.

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt8();
```

Результат:

```response
[]
```
## emptyArrayInt16 {#emptyarrayint16}

Возвращает пустой Int16 массив.

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt16();
```

Результат:

```response
[]
```
## emptyArrayInt32 {#emptyarrayint32}

Возвращает пустой Int32 массив.

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt32();
```

Результат:

```response
[]
```
## emptyArrayInt64 {#emptyarrayint64}

Возвращает пустой Int64 массив.

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt64();
```

Результат:

```response
[]
```
## emptyArrayFloat32 {#emptyarrayfloat32}

Возвращает пустой Float32 массив.

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat32();
```

Результат:

```response
[]
```
## emptyArrayFloat64 {#emptyarrayfloat64}

Возвращает пустой Float64 массив.

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat64();
```

Результат:

```response
[]
```
## emptyArrayDate {#emptyarraydate}

Возвращает пустой Date массив.

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDate();
```
## emptyArrayDateTime {#emptyarraydatetime}

Возвращает пустой DateTime массив.

**Синтаксис**

```sql
[]
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDateTime();
```

Результат:

```response
[]
```
## emptyArrayString {#emptyarraystring}

Возвращает пустой String массив.

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayString();
```

Результат:

```response
[]
```
## emptyArrayToSingle {#emptyarraytosingle}

Принимает пустой массив и возвращает одноэлементный массив, который равен значению по умолчанию.
## range(end), range(\[start, \] end \[, step\]) {#rangeend-rangestart--end--step}

Возвращает массив чисел от `start` до `end - 1` с шагом `step`. Поддерживаемые типы: [UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64](../data-types/int-uint.md).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

- `start` — Первый элемент массива. Необязательный, требуется, если используется `step`. Значение по умолчанию: 0.
- `end` — Число, перед которым формируется массив. Обязательно.
- `step` — Определяет шаг инкремента между каждым элементом массива. Необязательный. Значение по умолчанию: 1.

**Возвращаемое значение**

- Массив чисел от `start` до `end - 1` с шагом `step`.

**Детали реализации**

- Все аргументы `start`, `end`, `step` должны быть ниже следующих типов данных: `UInt8`, `UInt16`, `UInt32`, `UInt64`,`Int8`, `Int16`, `Int32`, `Int64`, а также элементы возвращаемого массива, тип которого является суперклассом всех аргументов.
- Исключение выбрасывается, если результаты запроса дают массивы с общей длиной более количества элементов, указанного в [function_range_max_elements_in_block](../../operations/settings/settings.md#function_range_max_elements_in_block) настройке.
- Возвращает Null, если любой аргумент имеет тип Nullable(Nothing). Исключение выбрасывается, если любой аргумент имеет значение Null (тип Nullable(T)).

**Примеры**

Запрос:

```sql
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

Результат:

```txt
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```
## array(x1, ...), operator \[x1, ...\] {#arrayx1--operator-x1-}

Создает массив из аргументов функции.
Аргументы должны быть константами и иметь типы с наименьшим общим типом. Обязательно должно быть передано хотя бы одно значение, иначе не будет ясно, какой тип массива создать. То есть, вы не можете использовать эту функцию для создания пустого массива (для этого используйте функцию 'emptyArray*', описанную выше).
Возвращает результат типа 'Array(T)', где 'T' — наименьший общий тип из переданных аргументов.
## arrayWithConstant(length, elem) {#arraywithconstantlength-elem}

Создает массив длины `length`, заполненный константой `elem`.
## arrayConcat {#arrayconcat}

Объединяет массивы, переданные в качестве аргументов.

```sql
arrayConcat(arrays)
```

**Аргументы**

- `arrays` – Произвольное количество аргументов типа [Array](/sql-reference/data-types/array).

**Пример**

```sql
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```text
┌─res───────────┐
│ [1,2,3,4,5,6] │
└───────────────┘
```
## arrayElement(arr, n), operator arr\[n\] {#arrayelementarr-n-operator-arrn}

Получает элемент с индексом `n` из массива `arr`. `n` должен иметь любой целочисленный тип.
Индексы в массиве начинаются с единицы.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумерованный с конца. Например, `arr[-1]` — последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается некоторое значение по умолчанию (0 для чисел, пустая строка для строк и т.д.), за исключением случая, когда массив не является константным, а индекс постоянный 0 (в этом случае будет ошибка `Array indices are 1-based`).
## has(arr, elem) {#hasarr-elem}

Проверяет, содержит ли массив 'arr' элемент 'elem'.
Возвращает 0, если элемент отсутствует в массиве, или 1, если он есть.

`NULL` обрабатывается как значение.

```sql
SELECT has([1, 2, NULL], NULL)
```

```text
┌─has([1, 2, NULL], NULL)─┐
│                       1 │
└─────────────────────────┘
```
## arrayElementOrNull(arr, n) {#arrayelementornullarr-n}

Получает элемент с индексом `n` из массива `arr`. `n` должен иметь любой целочисленный тип.
Индексы в массиве начинаются с единицы.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент, нумерованный с конца. Например, `arr[-1]` — последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается `NULL` вместо значения по умолчанию.
### Примеры {#examples}

```sql
SELECT arrayElementOrNull([1, 2, 3], 2), arrayElementOrNull([1, 2, 3], 4)
```

```text
 ┌─arrayElementOrNull([1, 2, 3], 2)─┬─arrayElementOrNull([1, 2, 3], 4)─┐
 │                                2 │                             ᴺᵁᴸᴸ │
 └──────────────────────────────────┴──────────────────────────────────┘
```
## hasAll {#hasall}

Проверяет, является ли один массив подмножеством другого.

```sql
hasAll(set, subset)
```

**Аргументы**

- `set` – Массив любого типа с набором элементов.
- `subset` – Массив любого типа, который разделяет общий суперкласс с `set`, содержащий элементы, которые должны быть проверены на подмножество `set`.

**Возвращаемые значения**

- `1`, если `set` содержит все элементы из `subset`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы набора и подмножества не разделяют общий суперкласс.

**Особые свойства**

- Пустой массив является подмножеством любого массива.
- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAll([], [])` возвращает 1.

`SELECT hasAll([1, Null], [Null])` возвращает 1.

`SELECT hasAll([1.0, 2, 3, 4], [1, 3])` возвращает 1.

`SELECT hasAll(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasAll([1], ['a'])` вызывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])` возвращает 0.
## hasAny {#hasany}

Проверяет, пересекаются ли два массива по некоторым элементам.

```sql
hasAny(array1, array2)
```

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа, который разделяет общий суперкласс с `array1`.

**Возвращаемые значения**

- `1`, если `array1` и `array2` имеют хотя бы один общий элемент.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы массива1 и массива2 не разделяют общий суперкласс.

**Особые свойства**

- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAny([1], [])` возвращает `0`.

`SELECT hasAny([Null], [Null, 1])` возвращает `1`.

`SELECT hasAny([-128, 1., 512], [1])` возвращает `1`.

`SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])` вызывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])` возвращает `1`.
## hasSubstr {#hassubstr}

Проверяет, появляются ли все элементы array2 в array1 в том же порядке. Следовательно, функция вернет 1, только если `array1 = prefix + array2 + suffix`.

```sql
hasSubstr(array1, array2)
```

Иными словами, функции проверят, содержатся ли все элементы `array2` в `array1`, как и функция `hasAll`. Кроме того, она проверит, что элементы наблюдаются в том же порядке, что и `array1`, и `array2`.

Например:

- `hasSubstr([1,2,3,4], [2,3])` возвращает 1. Однако `hasSubstr([1,2,3,4], [3,2])` вернет `0`.
- `hasSubstr([1,2,3,4], [1,2,3])` возвращает 1. Однако `hasSubstr([1,2,3,4], [1,2,4])` вернет `0`.

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа с набором элементов.

**Возвращаемые значения**

- `1`, если `array1` содержит `array2`.
- `0`, в противном случае.

Вызывает исключение `NO_COMMON_TYPE`, если элементы массива1 и массива2 не разделяют общий суперкласс.

**Особые свойства**

- Функция вернет `1`, если `array2` пуст.
- `Null` обрабатывается как значение. Иными словами, `hasSubstr([1, 2, NULL, 3, 4], [2,3])` вернет `0`. Однако `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` вернет `1`
- Порядок значений в обоих массивах имеет значение.

**Примеры**

`SELECT hasSubstr([], [])` возвращает 1.

`SELECT hasSubstr([1, Null], [Null])` возвращает 1.

`SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])` возвращает 0.

`SELECT hasSubstr(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])` возвращает 0.

`SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])` возвращает 1.
i
`SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])` вызывает исключение `NO_COMMON_TYPE`.
## indexOf(arr, x) {#indexofarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он есть в массиве.
Если массив не содержит искомое значение, функция возвращает 0.

Пример:

```sql
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```text
┌─indexOf([1, 3, NULL, NULL], NULL)─┐
│                                 3 │
└───────────────────────────────────┘
```

Элементы, установленные в `NULL`, обрабатываются как обычные значения.
## indexOfAssumeSorted(arr, x) {#indexofassumesortedarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он есть в массиве.
Если массив не содержит искомое значение, функция возвращает 0.
Предполагает, что массив отсортирован по возрастанию (т.е. функция использует бинарный поиск).
Если массив не отсортирован, результаты неопределенны.
Если внутренний массив имеет тип Nullable, будет вызвана функция 'indexOf'.

Пример:

```sql
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```text
┌─indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)─┐
│                                             5 │
└───────────────────────────────────────────────┘
```
## arrayCount(\[func,\] arr1, ...) {#arraycountfunc-arr1-}

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0. Если `func` не указан, возвращает количество ненулевых элементов в массиве.

Обратите внимание, что `arrayCount` является [высшим порядком функцией](/sql-reference/functions/overview#higher-order-functions). Вы можете передать в нее лямбда-функцию в качестве первого аргумента.
## arrayDotProduct {#arraydotproduct}

Возвращает скалярное произведение двух массивов.

**Синтаксис**

```sql
arrayDotProduct(vector1, vector2)
```

Псевдоним: `scalarProduct`, `dotProduct`

**Параметры**

- `vector1`: Первый вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.
- `vector2`: Второй вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.

:::note
Размеры двух векторов должны быть равны. Массивы и кортежи могут также содержать смешанные типы элементов.
:::

**Возвращаемое значение**

- Скалярное произведение двух векторов. [Numeric](/native-protocol/columns#numeric-types).

:::note
Тип возвращаемого значения определяется типом аргументов. Если массивы или кортежи содержат смешанные типы элементов, то результирующий тип является суперклассом.
:::

**Примеры**

Запрос:

```sql
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

Результат:

```response
32    UInt16
```

Запрос:

```sql
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

Результат:

```response
32    Float64
```
## countEqual(arr, x) {#countequalarr-x}

Возвращает количество элементов в массиве, равных x. Эквивалентно arrayCount (elem -\> elem = x, arr).

Элементы `NULL` обрабатываются как отдельные значения.

Пример:

```sql
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```text
┌─countEqual([1, 2, NULL, NULL], NULL)─┐
│                                    2 │
└──────────────────────────────────────┘
```
## arrayEnumerate(arr) {#arrayenumeratearr}

Возвращает массив \[1, 2, 3, ..., длина (arr) \]

Эта функция обычно используется с ARRAY JOIN. Она позволяет считать что-то только один раз для каждого массива после применения ARRAY JOIN. Пример:

```sql
SELECT
    count() AS Reaches,
    countIf(num = 1) AS Hits
FROM test.hits
ARRAY JOIN
    GoalsReached,
    arrayEnumerate(GoalsReached) AS num
WHERE CounterID = 160656
LIMIT 10
```

```text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

В этом примере "Reaches" — это количество конверсий (строки, полученные после применения ARRAY JOIN), а "Hits" — это количество просмотров страниц (строки до ARRAY JOIN). В данном случае можно получить тот же результат более простым способом:

```sql
SELECT
    sum(length(GoalsReached)) AS Reaches,
    count() AS Hits
FROM test.hits
WHERE (CounterID = 160656) AND notEmpty(GoalsReached)
```

```text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

Эту функцию также можно использовать в функциях высшего порядка. Например, вы можете использовать ее для получения индексов массива для элементов, которые соответствуют условию.
## arrayEnumerateUniq {#arrayenumerateuniq}

Возвращает массив такого же размера, как исходный массив, указывающий для каждого элемента, какую позицию он занимает среди элементов с тем же значением.
Например: arrayEnumerateUniq(\[10, 20, 10, 30\]) = \[1, 1, 2, 1\].

Эта функция полезна при использовании ARRAY JOIN и агрегации элементов массива.
Пример:

```sql
SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```text
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```

В этом примере для каждого идентификатора цели рассчитывается количество конверсий (каждый элемент в вложенной структуре данных "Goals" является целью, которая была достигнута, и мы называем это конверсией) и количество сессий. Без ARRAY JOIN мы посчитали бы количество сессий как sum(Sign). Но в данном случае строки были умножены по вложенной структуре Goals, поэтому, чтобы посчитать каждую сессию один раз после этого, мы применяем условие к значению функции arrayEnumerateUniq(Goals.ID).

Функция arrayEnumerateUniq может принимать несколько массивов одного размера в качестве аргументов. В этом случае уникальность учитывается для кортежей элементов в тех же позициях во всех массивах.

```sql
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]) AS res
```

```text
┌─res───────────┐
│ [1,2,1,1,2,1] │
└───────────────┘
```

Это необходимо при использовании ARRAY JOIN с вложенной структурой данных и дальнейшей агрегацией по нескольким элементам в этой структуре.
## arrayEnumerateUniqRanked {#arrayenumerateuniqranked}

Возвращает массив такого же размера, как исходный массив, указывающий для каждого элемента, какую позицию он занимает среди элементов с тем же значением. Позволяет перечисление многомерного массива с возможностью указать, насколько глубоко следует заглянуть внутрь массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Перечисляет элементы на указанном уровне отдельно. Положительное [Целое число](../data-types/int-uint.md), не превышающее `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Массив](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [Целое число](../data-types/int-uint.md), не превышающее глубины `arr`.

**Пример**

При `clear_depth=1` и `max_array_depth=1` результат `arrayEnumerateUniqRanked` идентичен результату, который бы дала [`arrayEnumerateUniq`](#arrayenumerateuniq) для того же массива.

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(1, [1,2,1], 1);
```

Результат:

```text
[1,1,2]
```

В этом примере `arrayEnumerateUniqRanked` используется для получения массива, указывающего для каждого элемента многомерного массива, какую позицию он занимает среди элементов одного и того же значения. Для первой строки переданного массива `[1,2,3]` соответствующий результат — `[1,1,1]`, что указывает на то, что это первый раз, когда встречаются `1`, `2` и `3`. Для второй строки предоставленного массива `[2,2,1]` соответствующий результат — `[2,3,3]`, что указывает на то, что `2` встречается второй и третий раз, а `1` встречается второй раз. Точно так же, для третьей строки предоставленного массива `[3]` соответствующий результат — `[2]`, что указывает на то, что `3` встречается второй раз.

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(1, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

```text
[[1,1,1],[2,3,2],[2]]
```

При изменении `clear_depth=2` результаты получаются с перечислением отдельных элементов для каждой строки.

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(2, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

```text
[[1,1,1],[1,2,1],[1]]
```
## arrayPopBack {#arraypopback}

Удаляет последний элемент из массива.

```sql
arrayPopBack(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

```sql
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```text
┌─res───┐
│ [1,2] │
└───────┘
```
## arrayPopFront {#arraypopfront}

Удаляет первый элемент из массива.

```sql
arrayPopFront(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

```sql
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```text
┌─res───┐
│ [2,3] │
└───────┘
```
## arrayPushBack {#arraypushback}

Добавляет один элемент в конец массива.

```sql
arrayPushBack(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Одно значение. В массивы с числами можно добавлять только числа, а в массивы со строками — только строки. При добавлении чисел ClickHouse автоматически устанавливает `single_value` тип для типа массива. Для получения дополнительной информации о типах данных в ClickHouse, смотрите "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

```sql
SELECT arrayPushBack(['a'], 'b') AS res;
```

```text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayPushFront {#arraypushfront}

Добавляет один элемент в начало массива.

```sql
arrayPushFront(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Одно значение. В массивы с числами можно добавлять только числа, а в массивы со строками — только строки. При добавлении чисел ClickHouse автоматически устанавливает `single_value` тип для типа массива. Для получения дополнительной информации о типах данных в ClickHouse, смотрите "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

```sql
SELECT arrayPushFront(['b'], 'a') AS res;
```

```text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayResize {#arrayresize}

Изменяет длину массива.

```sql
arrayResize(array, size[, extender])
```

**Аргументы:**

- `array` — Массив.
- `size` — Требуемая длина массива.
  - Если `size` меньше оригинального размера массива, массив обрезается справа.
- Если `size` больше первоначального размера массива, массив расширяется вправо с помощью значений `extender` или значений по умолчанию для типа элементов массива.
- `extender` — Значение для расширения массива. Может быть `NULL`.

**Возвращаемое значение:**

Массив длиной `size`.

**Примеры вызовов**

```sql
SELECT arrayResize([1], 3);
```

```text
┌─arrayResize([1], 3)─┐
│ [1,0,0]             │
└─────────────────────┘
```

```sql
SELECT arrayResize([1], 3, NULL);
```

```text
┌─arrayResize([1], 3, NULL)─┐
│ [1,NULL,NULL]             │
└───────────────────────────┘
```
## arraySlice {#arrayslice}

Возвращает срез массива.

```sql
arraySlice(array, offset[, length])
```

**Аргументы**

- `array` – Массив данных.
- `offset` – Отступ от края массива. Положительное значение указывает на отступ слева, а отрицательное значение — на отступ справа. Нумерация элементов массива начинается с 1.
- `length` – Длина требуемого среза. Если вы укажете отрицательное значение, функция вернет открытый срез `[offset, array_length - length]`. Если вы опустите значение, функция вернет срез `[offset, конец_array]`.

**Пример**

```sql
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```text
┌─res────────┐
│ [2,NULL,4] │
└────────────┘
```

Элементы массива, установленные в `NULL`, обрабатываются как обычные значения.
## arrayShingles {#arrayshingles}

Генерирует массив "шинглов", т.е. последовательных подмассивов с заданной длиной исходного массива.

**Синтаксис**

```sql
arrayShingles(array, length)
```

**Аргументы**

- `array` — Входной массив [Array](/sql-reference/data-types/array).
- `length` — Длина каждого шингла.

**Возвращаемое значение**

- Массив сгенерированных шинглов. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShingles([1,2,3,4], 3) as res;
```

Результат:

```text
┌─res───────────────┐
│ [[1,2,3],[2,3,4]] │
└───────────────────┘
```
```
```yaml
title: 'arraySort'
sidebar_label: 'arraySort'
keywords: ['array', 'sort', 'ClickHouse']
description: 'Сортирует элементы массива в порядке возрастания.'
```

## arraySort(\[func,\] arr, ...) {#sort}

Сортирует элементы массива `arr` в порядке возрастания. Если функция `func` указана, порядок сортировки определяется результатом применения функции `func` к элементам массива. Если `func` принимает несколько аргументов, функции `arraySort` передается несколько массивов, которые будут соответствовать аргументам `func`. Подробные примеры приведены в конце описания `arraySort`.

Пример сортировки целочисленных значений:

```sql
SELECT arraySort([1, 3, 3, 0]);
```

```text
┌─arraySort([1, 3, 3, 0])─┐
│ [0,1,3,3]               │
└─────────────────────────┘
```

Пример сортировки строковых значений:

```sql
SELECT arraySort(['hello', 'world', '!']);
```

```text
┌─arraySort(['hello', 'world', '!'])─┐
│ ['!','hello','world']              │
└────────────────────────────────────┘
```

Рассмотрим следующий порядок сортировки для значений `NULL`, `NaN` и `Inf`:

```sql
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```text
┌─arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf])─┐
│ [-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]                     │
└───────────────────────────────────────────────────────────┘
```

- Значения `-Inf` находятся первыми в массиве.
- Значения `NULL` находятся последними в массиве.
- Значения `NaN` находятся перед `NULL`.
- Значения `Inf` находятся перед `NaN`.

Обратите внимание, что `arraySort` является [высшего порядка функцией](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента. В этом случае порядок сортировки определяется результатом применения лямбда-функции к элементам массива.

Рассмотрим следующий пример:

```sql
SELECT arraySort((x) -> -x, [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [3,2,1] │
└─────────┘
```

Для каждого элемента исходного массива лямбда-функция возвращает ключ сортировки, то есть \[1 –\> -1, 2 –\> -2, 3 –\> -3\]. Поскольку функция `arraySort` сортирует ключи в порядке возрастания, результатом будет \[3, 2, 1\]. Таким образом, лямбда-функция `(x) –> -x` устанавливает [порядок убывания](#arrayreversesort) при сортировке.

Лямбда-функция может принимать несколько аргументов. В этом случае вам нужно передать функции `arraySort` несколько массивов одинаковой длины, аргументы лямбда-функции будут соответствовать им. Результирующий массив будет состоять из элементов первого входного массива; элементы следующих входных массивов определяют ключи сортировки. Например:

```sql
SELECT arraySort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

```text
┌─res────────────────┐
│ ['world', 'hello'] │
└────────────────────┘
```

Здесь элементы, передаваемые во втором массиве (\[2, 1\]), определяют ключ сортировки для соответствующего элемента из исходного массива (\['hello', 'world'\]), то есть \['hello' –\> 2, 'world' –\> 1\]. Поскольку лямбда-функция не использует `x`, фактические значения исходного массива не влияют на порядок в результате. Таким образом, 'hello' будет вторым элементом в результате, а 'world' первым.

Другие примеры приведены ниже.

```sql
SELECT arraySort((x, y) -> y, [0, 1, 2], ['c', 'b', 'a']) as res;
```

```text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

```sql
SELECT arraySort((x, y) -> -y, [0, 1, 2], [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

:::note
Для повышения эффективности сортировки используется [преобразование Шварца](https://en.wikipedia.org/wiki/Schwartzian_transform).
:::
## arrayPartialSort(\[func,\] limit, arr, ...) {#arraypartialsortfunc-limit-arr-}

То же самое, что и `arraySort`, с дополнительным аргументом `limit`, позволяющим частичную сортировку. Возвращает массив того же размера, что и исходный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке возрастания. Оставшиеся элементы `(limit..N]` могут содержать элементы в неопределенном порядке.
## arrayReverseSort {#arrayreversesort}

Сортирует элементы массива `arr` в порядке убывания. Если указана функция `func`, то `arr` сортируется в соответствии с результатом функции `func`, примененной к элементам массива, а затем отсортированный массив обращается. Если `func` принимает несколько аргументов, функции `arrayReverseSort` передается несколько массивов, которые будут соответствовать аргументам `func`. Подробные примеры приведены в конце описания `arrayReverseSort`.

**Синтаксис**

```sql
arrayReverseSort([func,] arr, ...)
```
Пример сортировки целочисленных значений:

```sql
SELECT arrayReverseSort([1, 3, 3, 0]);
```

```text
┌─arrayReverseSort([1, 3, 3, 0])─┐
│ [3,3,1,0]                      │
└────────────────────────────────┘
```

Пример сортировки строковых значений:

```sql
SELECT arrayReverseSort(['hello', 'world', '!']);
```

```text
┌─arrayReverseSort(['hello', 'world', '!'])─┐
│ ['world','hello','!']                     │
└───────────────────────────────────────────┘
```

Рассмотрим следующий порядок сортировки для значений `NULL`, `NaN` и `Inf`:

```sql
SELECT arrayReverseSort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]) as res;
```

```text
┌─res───────────────────────────────────┐
│ [inf,3,2,1,-4,-inf,nan,nan,NULL,NULL] │
└───────────────────────────────────────┘
```

- Значения `Inf` находятся первыми в массиве.
- Значения `NULL` находятся последними в массиве.
- Значения `NaN` находятся перед `NULL`.
- Значения `-Inf` находятся перед `NaN`.

Обратите внимание, что `arrayReverseSort` является [высшего порядка функцией](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента. Пример приведен ниже.

```sql
SELECT arrayReverseSort((x) -> -x, [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [1,2,3] │
└─────────┘
```

Массив сортируется следующим образом:

1. Вначале исходный массив (\[1, 2, 3\]) сортируется в соответствии с результатом применения лямбда-функции к элементам массива. Результат – массив \[3, 2, 1\].
2. Массив, полученный на предыдущем шаге, обращается. Таким образом, конечный результат – \[1, 2, 3\].

Лямбда-функция может принимать несколько аргументов. В этом случае вам нужно передать функции `arrayReverseSort` несколько массивов одинаковой длины, аргументы лямбда-функции будут соответствовать им. Результирующий массив будет состоять из элементов первого входного массива; элементы следующих входных массивов определяют ключи сортировки. Например:

```sql
SELECT arrayReverseSort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

```text
┌─res───────────────┐
│ ['hello','world'] │
└───────────────────┘
```

В этом примере массив сортируется следующим образом:

1. Вначале исходный массив (\['hello', 'world'\]) сортируется в соответствии с результатом применения лямбда-функции к элементам массивов. Элементы, переданные во втором массиве (\[2, 1\]), определяют ключи сортировки для соответствующих элементов из исходного массива. Результат – массив \['world', 'hello'\].
2. Массив, который был отсортирован на предыдущем шаге, обращается. Таким образом, конечный результат – \['hello', 'world'\].

Другие примеры приведены ниже.

```sql
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```text
┌─res─────┐
│ [5,3,4] │
└─────────┘
```

```sql
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```text
┌─res─────┐
│ [4,3,5] │
└─────────┘
```
## arrayPartialReverseSort(\[func,\] limit, arr, ...) {#arraypartialreversesortfunc-limit-arr-}

То же самое, что и `arrayReverseSort`, с дополнительным аргументом `limit`, позволяющим частичную сортировку. Возвращает массив того же размера, что и исходный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке убывания. Оставшиеся элементы `(limit..N]` могут содержать элементы в неопределенном порядке.
## arrayShuffle {#arrayshuffle}

Возвращает массив того же размера, что и исходный массив, содержащий элементы в перемешанном порядке. Элементы переупорядочиваются так, чтобы каждая возможная перестановка этих элементов имела равную вероятность появления.

**Синтаксис**

```sql
arrayShuffle(arr[, seed])
```

**Параметры**

- `arr`: массив, который нужно частично перемешать. [Array](/sql-reference/data-types/array).
- `seed` (необязательно): семя, используемое для генерации случайных чисел. Если не предоставлено, используется случайное. [UInt или Int](../data-types/int-uint.md).

**Возвращаемое значение**

- Массив с перемешанными элементами.

**Подробности реализации**

:::note 
Эта функция не будет материализовать константы.
:::

**Примеры**

В этом примере `arrayShuffle` используется без предоставления `seed` и, следовательно, сгенерирует его случайным образом.

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4]);
```

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции.

Результат: 

```response
[1,4,2,3]
```

В этом примере `arrayShuffle` предоставляется `seed`, и он будет производить стабильные результаты.

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

Результат: 

```response
[3,2,1,4]
```
## arrayPartialShuffle {#arraypartialshuffle}

Данный массив с кардинальностью `N` возвращает массив размера N, в котором элементы в диапазоне `[1...limit]` перемешаны, а оставшиеся элементы в диапазоне `(limit...n]` не перемешаны.

**Синтаксис**

```sql
arrayPartialShuffle(arr[, limit[, seed]])
```

**Параметры**

- `arr`: массив размером `N`, который нужно частично перемешать. [Array](/sql-reference/data-types/array).
- `limit` (необязательно): количество, ограничивающее замену элементов, в пределах `[1..N]`. [UInt или Int](../data-types/int-uint.md).
- `seed` (необязательно): значение семени, используемое с генерацией случайных чисел. Если не предоставлено, используется случайное. [UInt или Int](../data-types/int-uint.md)

**Возвращаемое значение**

- Массив с частично перемешанными элементами.

**Подробности реализации**

:::note 
Эта функция не будет материализовать константы.

Значение `limit` должно быть в диапазоне `[1..N]`. Значения, выходящие за пределы этого диапазона, эквивалентны выполнению полного [arrayShuffle](#arrayshuffle).
:::

**Примеры**

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции. 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)
```

Результат:

Порядок элементов сохраняется (`[2,3,4,5], [7,8,9,10]`), за исключением двух перемешанных элементов `[1, 6]`. Семя не предоставляется, поэтому функция выбирает его случайно.

```response
[6,2,3,4,5,1,7,8,9,10]
```

В этом примере `limit` увеличен до `2`, и предоставляется значение `seed`. Порядок 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2);
```

Порядок элементов сохраняется (`[4, 5, 6, 7, 8], [10]`), за исключением четырех перемешанных элементов `[1, 2, 3, 9]`.

Результат: 
```response
[3,9,1,4,5,6,7,8,2,10]
```
## arrayUniq(arr, ...) {#arrayuniqarr-}

Если передан один аргумент, он подсчитывает количество различных элементов в массиве. Если передано несколько аргументов, он подсчитывает количество различных кортежей элементов в соответствующих позициях в нескольких массивах.

Если вы хотите получить список уникальных элементов в массиве, вы можете использовать arrayReduce('groupUniqArray', arr).
## arrayJoin(arr) {#arrayjoinarr}

Специальная функция. См. раздел ["Функция ArrayJoin"](/sql-reference/functions/array-join).
## arrayDifference {#arraydifference}

Вычисляет массив разностей между смежными элементами массива. Первый элемент результирующего массива будет равен 0, второй `a[1] - a[0]`, третий `a[2] - a[1]` и т.д. Тип элементов в результирующем массиве определяется правилами вывода типов для вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(array)
```

**Аргументы**

- `array` – [Array](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив разностей между смежными элементами массива. [UInt\*](/sql-reference/data-types/int-uint#integer-ranges), [Int\*](/sql-reference/data-types/int-uint#integer-ranges), [Float\*](/sql-reference/data-types/float).

**Пример**

Запрос:

```sql
SELECT arrayDifference([1, 2, 3, 4]);
```

Результат:

```text
┌─arrayDifference([1, 2, 3, 4])─┐
│ [0,1,1,1]                     │
└───────────────────────────────┘
```

Пример переполнения из-за результирующего типа Int64:

Запрос:

```sql
SELECT arrayDifference([0, 10000000000000000000]);
```

Результат:

```text
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```
## arrayDistinct {#arraydistinct}

Принимает массив, возвращает массив, содержащий только уникальные элементы.

**Синтаксис**

```sql
arrayDistinct(array)
```

**Аргументы**

- `array` – [Array](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив, содержащий уникальные элементы.

**Пример**

Запрос:

```sql
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

Результат:

```text
┌─arrayDistinct([1, 2, 2, 3, 1])─┐
│ [1,2,3]                        │
└────────────────────────────────┘
```
## arrayEnumerateDense {#arrayenumeratedense}

Возвращает массив того же размера, что и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Пример**

Запрос:

```sql
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

Результат:

```text
┌─arrayEnumerateDense([10, 20, 10, 30])─┐
│ [1,2,1,3]                             │
└───────────────────────────────────────┘
```
## arrayEnumerateDenseRanked {#arrayenumeratedenseranked}

Возвращает массив того же размера, что и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве. Позволяет перечисление многомерного массива с возможностью указания, насколько глубоко следует искать внутри массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Перечисляет элементы на указанном уровне отдельно. Положительное [Целое](../data-types/int-uint.md), меньшее или равное `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Array](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [Целое](../data-types/int-uint.md), меньшее или равное глубине `arr`.

**Пример**

С `clear_depth=1` и `max_array_depth=1`, результат идентичен тому, что даст [arrayEnumerateDense](#arrayenumeratedense).

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

Результат:

```text
[1,2,1,3]
```

В этом примере `arrayEnumerateDenseRanked` используется для получения массива, указывающего, для каждого элемента многомерного массива, какова его позиция среди элементов того же значения. Для первой строки переданного массива,`[10,10,30,20]`, соответствующая первая строка результата – `[1,1,2,3]`, указывающая, что `10` - это первое число, встреченное на позициях 1 и 2, `30` - второе число, встреченное на позиции 3, а `20` - третье число, встреченное на позиции 4. Для второй строки `[40, 50, 10, 30]`, соответствующая вторая строка результата – `[4,5,1,2]`, указывающая, что `40` и `50` - это четвертое и пятое числа, встреченные на позициях 1 и 2 в этой строке, а другое `10` (первое встреченное число) находится на позиции 3, а `30` (второе встреченное число) - на последней позиции. 


Запрос:

```sql
SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

Результат:

```text
[[1,1,2,3],[4,5,1,2]]
```

Изменение `clear_depth=2` приводит к тому, что перечисление происходит отдельно для каждой строки заново.

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```
Результат:

```text
[[1,1,2,3],[1,2,3,4]]
```
## arrayUnion {#arrayunion}

Принимает несколько массивов и возвращает массив, который содержит все элементы, присутствующие в одном из исходных массивов. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с отличительными элементами из исходных массивов.

**Пример**

Запрос:

```sql
SELECT
    arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
    arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
    arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

Результат:

```text
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```
## arrayIntersect {#arrayintersect}

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с отличительными элементами, присутствующими во всех исходных массивах.

**Пример**

Запрос:

```sql
SELECT
    arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
    arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

Результат:

```text
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arraySymmetricDifference {#arraysymmetricdifference}

Принимает несколько массивов и возвращает массив с элементами, которые не присутствуют во всех исходных массивах. Результат содержит только уникальные значения.

:::note
Симметричная разность _более чем двух множеств_ определяется математически как множество всех входных элементов, которые встречаются в нечетном количестве входных множеств. В отличие от этого, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые не встречаются во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с отличительными элементами, не присутствующими во всех исходных массивах.

**Пример**

Запрос:

```sql
SELECT
    arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
    arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference
```

Результат:

```text
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```
## arrayJaccardIndex {#arrayjaccardindex}

Возвращает [коэффициент Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) двух массивов.

**Пример**

Запрос:
```sql
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

Результат:
```text
┌─res────────────────┐
│ 0.3333333333333333 │
└────────────────────┘
```
## arrayReduce {#arrayreduce}

Применяет агрегатную функцию к элементам массива и возвращает его результат. Имя агрегатной функции передается в виде строки в одинарных кавычках `'max'`, `'sum'`. При использовании параметрических агрегатных функций параметр указывается после имени функции в скобках `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_func, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — имя агрегатной функции, которая должна быть константной [строкой](../data-types/string.md).
- `arr` — любое количество [array](/sql-reference/data-types/array) столбцов в качестве параметров агрегатной функции.

**Возвращаемое значение**

**Пример**

Запрос:

```sql
SELECT arrayReduce('max', [1, 2, 3]);
```

Результат:

```text
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

Если агрегатная функция принимает несколько аргументов, то эта функция должна применяться к нескольким массивам одинакового размера.

Запрос:

```sql
SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

Результат:

```text
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

Пример с параметрической агрегатной функцией:

Запрос:

```sql
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

Результат:

```text
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```

**См. также**

- [arrayFold](#arrayfold)
## arrayReduceInRanges {#arrayreduceinranges}

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив, содержащий результат для каждого диапазона. Функция вернет тот же результат, что и несколько `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_func, ranges, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — имя агрегатной функции, которая должна быть константной [строкой](../data-types/string.md).
- `ranges` — диапазоны, которые необходимо агрегировать, должны быть [массивом](/sql-reference/data-types/array) [кортежей](../data-types/tuple.md), содержащих индекс и длину каждого диапазона.
- `arr` — любое количество [Array](/sql-reference/data-types/array) столбцов в качестве параметров агрегатной функции.

**Возвращаемое значение**

- Массив, содержащий результаты агрегатной функции по указанным диапазонам. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

Результат:

```text
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```
## arrayFold {#arrayfold}

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и собирает результат в аккумулятор.

**Синтаксис**

```sql
arrayFold(lambda_function, arr1, arr2, ..., accumulator)
```

**Пример**

Запрос:

```sql
SELECT arrayFold( acc,x -> acc + x*2,  [1, 2, 3, 4], toInt64(3)) AS res;
```

Результат:

```text
┌─res─┐
│  23 │
└─────┘
```

**Пример с последовательностью Фибоначчи**

```sql
SELECT arrayFold( acc,x -> (acc.2, acc.2 + acc.1), range(number), (1::Int64, 0::Int64)).1 AS fibonacci
FROM numbers(1,10);

┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**См. также**

- [arrayReduce](#arrayreduce)
## arrayReverse {#arrayreverse}

Возвращает массив того же размера, что и исходный массив, содержащий элементы в обратном порядке.

**Синтаксис**

```sql
arrayReverse(arr)
```

Пример:

```sql
SELECT arrayReverse([1, 2, 3])
```

```text
┌─arrayReverse([1, 2, 3])─┐
│ [3,2,1]                 │
└─────────────────────────┘
```
## reverse(arr) {#reversearr}

Синоним для ["arrayReverse"](#arrayreverse)
## arrayFlatten {#arrayflatten}

Преобразует массив массивов в плоский массив.

Функция:

- Применяется ко всем уровням вложенности массивов.
- Не изменяет массивы, которые уже являются плоскими.

Плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
flatten(array_of_arrays)
```

Псевдоним: `flatten`.

**Параметры**

- `array_of_arrays` — [Array](/sql-reference/data-types/array) массивов. Например, `[[1,2,3], [4,5]]`.

**Примеры**

```sql
SELECT flatten([[[1]], [[2], [3]]]);
```

```text
┌─flatten(array(array([1]), array([2], [3])))─┐
│ [1,2,3]                                     │
└─────────────────────────────────────────────┘
```
## arrayCompact {#arraycompact}

Удаляет последовательные дублирующие элементы из массива. Порядок значений результата определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

`arr` — [array](/sql-reference/data-types/array) для проверки.

**Возвращаемое значение**

Массив без дубликатов. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

Результат:

```text
┌─arrayCompact([1, 1, nan, nan, 2, 3, 3, 3])─┐
│ [1,nan,nan,2,3]                            │
└────────────────────────────────────────────┘
```
## arrayZip {#arrayzip}

Объединяет несколько массивов в один. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов. Все входные массивы должны быть одинакового размера.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже такие же, как в типах входных массивов и в том же порядке, в котором массивы передаются. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```


Результат:

```text
┌─arrayZip(['a', 'b', 'c'], [5, 2, 1])─┐
│ [('a',5),('b',2),('c',1)]            │
└──────────────────────────────────────┘
```
## arrayZipUnaligned {#arrayzipunaligned}

Объединяет несколько массивов в один массив, позволяя не выровненные массивы. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже такие же, как в типах входных массивов, и в том же порядке, в котором массивы передаются. [Array](/sql-reference/data-types/array). Если массивы имеют разные размеры, более короткие массивы будут дополнены значениями `null`.

**Пример**

Запрос:

```sql
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

Результат:

```text
┌─arrayZipUnaligned(['a'], [1, 2, 3])─┐
│ [('a',1),(NULL,2),(NULL,3)]         │
└─────────────────────────────────────┘
```
## arrayROCAUC {#arrayrocauc}

Вычисляет площадь под кривой операционной характеристики (ROC). Кривая ROC создается путем нанесения на ось Y доли истинных положительных результатов (TPR) и на ось X доли ложных положительных результатов (FPR) для всех порогов. Полученное значение варьируется от 0 до 1, при этом более высокое значение указывает на лучшую производительность модели. ROC AUC (также известная просто как AUC) является понятием в машинном обучении. Для получения дополнительных сведений смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(arr_scores, arr_labels[, scale[, arr_partial_offsets]])
```

Псевдоним: `arrayAUC`

**Аргументы**

- `arr_scores` — оценки, которые выдает модель прогнозирования. [Array](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Чисел с плавающей запятой](../data-types/float.md).
- `arr_labels` — метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Array](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Перечислений](../data-types/enum.md).
- `scale` — решает, следует ли возвращать нормализованную площадь. Если ложь, возвращает площадь под кривой TP (истинные положительные) x FP (ложные положительные) вместо этого. Значение по умолчанию: true. [Bool](../data-types/boolean.md). Необязательно.
- `arr_partial_offsets` — массив из четырех неотрицательных целых чисел для вычисления частичной площади под кривой ROC (равносильно вертикальной полосе ROC пространства) вместо всей AUC. Этот параметр полезен для распределенных вычислений ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) из неотрицательных [Целых чисел](../data-types/int-uint.md). Необязательно.
    - `higher_partitions_tp`: Количество положительных меток в высоко оцененных разделах.
    - `higher_partitions_fp`: Количество отрицательных меток в высоко оцененных разделах.
    - `total_positives`: Общее количество положительных образцов на всем наборе данных.
    - `total_negatives`: Общее количество отрицательных образцов на всем наборе данных.

::::note
При использовании `arr_partial_offsets` `arr_scores` и `arr_labels` должны составлять лишь часть всего набора данных, содержащую интервал оценок. Набор данных должен быть разделен на непрерывные разделы, каждый из которых содержит подмножество данных, чьи оценки попадают в определенный диапазон. Например:
- Один раздел может содержать все оценки в диапазоне [0, 0.5).
- Другой раздел может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой операционной характеристики (ROC). [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
select arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

```text
┌─arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                                             0.75 │
└──────────────────────────────────────────────────┘
```
```yaml
title: 'arrayAUCPR'
sidebar_label: 'arrayAUCPR'
keywords: ['array', 'AUC', 'precision', 'recall']
description: 'Вычисляет площадь под кривой точности-отзыва (PR).'
```

## arrayAUCPR {#arrayaucpr}

Вычисляет площадь под кривой точности-отзыва (PR).
Кривая точности-отзыва создается путем отображения точности по оси y и отзыва по оси x во всех пределах.
Результирующее значение варьируется от 0 до 1, при этом более высокое значение указывает на лучшую производительность модели.
PR AUC особенно полезен для несбалансированных наборов данных, обеспечивая более ясное сравнение производительности по сравнению с ROC AUC в таких случаях.
Для получения дополнительных сведений смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(arr_scores, arr_labels[, arr_partial_offsets])
```

Псевдоним: `arrayPRAUC`

**Аргументы**

- `arr_scores` — Оценки, которые выдает модель прогноза. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Чисел с плавающей запятой](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Enums](../data-types/enum.md).
- `arr_partial_offsets` — Необязательный. [Массив](/sql-reference/data-types/array) из трех неотрицательных целых чисел для вычисления частичной площади под кривой PR (эквивалентно вертикальной полосе в пространстве PR) вместо всей площади AUC. Эта опция полезна для распределенного вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]. [Массив](/sql-reference/data-types/array) неотрицательных [Целых чисел](../data-types/int-uint.md). Обязательно.
    - `higher_partitions_tp`: Количество положительных меток в разделах с более высокими оценками.
    - `higher_partitions_fp`: Количество отрицательных меток в разделах с более высокими оценками.
    - `total_positives`: Общее количество положительных образцов в полном наборе данных.

::::note
Когда `arr_partial_offsets` используется, `arr_scores` и `arr_labels` должны составлять только раздел всего набора данных, содержащий интервал оценок.
Набор данных должен быть разбит на непрерывные разделы, где каждый раздел содержит подмножество данных, оценки которых попадают в определенный диапазон.
Например:
- Один раздел мог бы содержать все оценки в диапазоне [0, 0.5).
- Другой раздел мог бы содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой точности-отзыва (PR). [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
select arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

```text
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayMap(func, arr1, ...) {#arraymapfunc-arr1-}

Возвращает массив, полученный из оригинальных массивов путем применения `func(arr1[i], ..., arrN[i])` к каждому элементу. Массивы `arr1` ... `arrN` должны иметь одинаковое количество элементов.

Примеры:

```sql
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [3,4,5] │
└─────────┘
```

Следующий пример показывает, как создать кортеж элементов из разных массивов:

```sql
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```text
┌─res─────────────────┐
│ [(1,4),(2,5),(3,6)] │
└─────────────────────┘
```

Обратите внимание, что `arrayMap` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayFilter(func, arr1, ...) {#arrayfilterfunc-arr1-}

Возвращает массив, содержащий только элементы в `arr1`, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0.

Примеры:

```sql
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```text
┌─res───────────┐
│ ['abc World'] │
└───────────────┘
```

```sql
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```text
┌─res─┐
│ [2] │
└─────┘
```

Обратите внимание, что `arrayFilter` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayFill(func, arr1, ...) {#arrayfillfunc-arr1-}

Просматривает `arr1` с первого элемента до последнего элемента и заменяет `arr1[i]` на `arr1[i - 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Первый элемент `arr1` не будет заменен.

Примеры:

```sql
SELECT arrayFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

```text
┌─res──────────────────────────────┐
│ [1,1,3,11,12,12,12,5,6,14,14,14] │
└──────────────────────────────────┘
```

Обратите внимание, что `arrayFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayReverseFill(func, arr1, ...) {#arrayreversefillfunc-arr1-}

Просматривает `arr1` с последнего элемента до первого элемента и заменяет `arr1[i]` на `arr1[i + 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Последний элемент `arr1` не будет заменен.

Примеры:

```sql
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

```text
┌─res────────────────────────────────┐
│ [1,3,3,11,12,5,5,5,6,14,NULL,NULL] │
└────────────────────────────────────┘
```

Обратите внимание, что `arrayReverseFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arraySplit(func, arr1, ...) {#arraysplitfunc-arr1-}

Разделяет `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0, массив будет разбит по левой стороне элемента. Массив не будет разбит перед первым элементом.

Примеры:

```sql
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```text
┌─res─────────────┐
│ [[1,2,3],[4,5]] │
└─────────────────┘
```

Обратите внимание, что `arraySplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayReverseSplit(func, arr1, ...) {#arrayreversesplitfunc-arr1-}

Разделяет `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0, массив будет разбит по правой стороне элемента. Массив не будет разбит после последнего элемента.

Примеры:

```sql
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```text
┌─res───────────────┐
│ [[1],[2,3,4],[5]] │
└───────────────────┘
```

Обратите внимание, что `arrayReverseSplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayExists(\[func,\] arr1, ...) {#arrayexistsfunc-arr1-}

Возвращает 1, если в `arr` есть хотя бы один элемент, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0. В противном случае возвращает 0.

Обратите внимание, что `arrayExists` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.
## arrayAll(\[func,\] arr1, ...) {#arrayallfunc-arr1-}

Возвращает 1, если `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0 для всех элементов в массивах. В противном случае возвращает 0.

Обратите внимание, что `arrayAll` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.
## arrayFirst(func, arr1, ...) {#arrayfirstfunc-arr1-}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0.
## arrayFirstOrNull {#arrayfirstornull}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Первый элемент в переданном массиве.
- В противном случае возвращает `NULL`

**Детали реализации**

Обратите внимание, что `arrayFirstOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.

**Пример**

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
2
```

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```

Запрос:

```sql
SELECT arrayLastOrNull((x,f) -> f, [1,2,3,NULL], [0,1,0,1]);
```

Результат:

```response
\N
```
## arrayLast(func, arr1, ...) {#arraylastfunc-arr1-}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0.

Обратите внимание, что `arrayLast` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayLastOrNull {#arraylastornull}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0, в противном случае возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Последний элемент в переданном массиве.
- В противном случае возвращает `NULL`

**Детали реализации**

Обратите внимание, что `arrayLastOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.

**Пример**

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
3
```

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```
## arrayFirstIndex(func, arr1, ...) {#arrayfirstindexfunc-arr1-}

Возвращает индекс первого элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0.

Обратите внимание, что `arrayFirstIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayLastIndex(func, arr1, ...) {#arraylastindexfunc-arr1-}

Возвращает индекс последнего элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0.

Обратите внимание, что `arrayLastIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать лямбда-функцию в качестве первого аргумента, и ее нельзя пропустить.
## arrayMin {#arraymin}

Возвращает минимум элементов в исходном массиве.

Если функция `func` задана, возвращает минимум элементов, преобразованных этой функцией.

Обратите внимание, что `arrayMin` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayMin([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Минимум значений функции (или минимум массива).

:::note
Если `func` задан, то тип возвращаемого значения совпадает с типом возвращаемого значения `func`, иначе он совпадает с типом элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMin([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   1 │
└─────┘
```

Запрос:

```sql
SELECT arrayMin(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -4 │
└─────┘
```
## arrayMax {#arraymax}

Возвращает максимум элементов в исходном массиве.

Если функция `func` задана, возвращает максимум элементов, преобразованных этой функцией.

Обратите внимание, что `arrayMax` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayMax([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Максимум значений функции (или максимум массива).

:::note
если `func` задан, то тип возвращаемого значения совпадает с типом возвращаемого значения `func`, иначе он совпадает с типом элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMax([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   4 │
└─────┘
```

Запрос:

```sql
SELECT arrayMax(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -1 │
└─────┘
```
## arraySum {#arraysum}

Возвращает сумму элементов в исходном массиве.

Если функция `func` задана, возвращает сумму элементов, преобразованных этой функцией.

Обратите внимание, что `arraySum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arraySum([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Сумма значений функции (или сумма массива).

:::note
Тип возвращаемого значения:

- Для десятичных чисел в исходном массиве (или для преобразованных значений, если `func` задан) — [Decimal128](../data-types/decimal.md).
- Для чисел с плавающей запятой — [Float64](../data-types/float.md).
- Для чисел без знака — [UInt64](../data-types/int-uint.md).
- Для чисел со знаком — [Int64](../data-types/int-uint.md).
:::

**Примеры**

Запрос:

```sql
SELECT arraySum([2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│   5 │
└─────┘
```

Запрос:

```sql
SELECT arraySum(x -> x*x, [2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│  13 │
└─────┘
```
## arrayAvg {#arrayavg}

Возвращает среднее элементов в исходном массиве.

Если функция `func` задана, возвращает среднее элементов, преобразованных этой функцией.

Обратите внимание, что `arrayAvg` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayAvg([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Среднее значений функции (или среднее массива). [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayAvg([1, 2, 4]) AS res;
```

Результат:

```text
┌────────────────res─┐
│ 2.3333333333333335 │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayAvg(x -> (x * x), [2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  10 │
└─────┘
```
## arrayCumSum(\[func,\] arr1, ...) {#arraycumsumfunc-arr1-}

Возвращает массив частичных (накопительных) сумм элементов в исходном массиве `arr1`. Если функция `func` задана, то сумма вычисляется путем применения `func` к `arr1`, `arr2`, ..., `arrN`, т.е. `func(arr1[i], ..., arrN[i])`.

**Синтаксис**

```sql
arrayCumSum(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив частичных сумм элементов в исходном массиве. [UInt\*](/sql-reference/data-types/int-uint#integer-ranges), [Int\*](/sql-reference/data-types/int-uint#integer-ranges), [Float\*](/sql-reference/data-types/float/).

Пример:

```sql
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```text
┌─res──────────┐
│ [1, 2, 3, 4] │
└──────────────┘
```

Обратите внимание, что `arrayCumSum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.
## arrayCumSumNonNegative(\[func,\] arr1, ...) {#arraycumsumnonnegativefunc-arr1-}

Так же, как и `arrayCumSum`, возвращает массив частичных (накопительных) сумм элементов в исходном массиве. Если функция `func` задана, сумма вычисляется путем применения `func` к `arr1`, `arr2`, ..., `arrN`, т.е. `func(arr1[i], ..., arrN[i])`. В отличие от `arrayCumSum`, если текущая сумма меньше `0`, она заменяется на `0`.

**Синтаксис**

```sql
arrayCumSumNonNegative(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив неотрицательных частичных сумм элементов в исходном массиве. [UInt\*](/sql-reference/data-types/int-uint#integer-ranges), [Int\*](/sql-reference/data-types/int-uint#integer-ranges), [Float\*](/sql-reference/data-types/float/).

```sql
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```text
┌─res───────┐
│ [1,2,0,1] │
└───────────┘
```

Обратите внимание, что `arraySumNonNegative` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.
## arrayProduct {#arrayproduct}

Умножает элементы [массива](/sql-reference/data-types/array).

**Синтаксис**

```sql
arrayProduct(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Произведение элементов массива. [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayProduct([1,2,3,4,5,6]) as res;
```

Результат:

```text
┌─res───┐
│ 720   │
└───────┘
```

Запрос:

```sql
SELECT arrayProduct([toDecimal64(1,8), toDecimal64(2,8), toDecimal64(3,8)]) as res, toTypeName(res);
```

Тип возвращаемого значения всегда [Float64](../data-types/float.md). Результат:

```text
┌─res─┬─toTypeName(arrayProduct(array(toDecimal64(1, 8), toDecimal64(2, 8), toDecimal64(3, 8))))─┐
│ 6   │ Float64                                                                                  │
└─────┴──────────────────────────────────────────────────────────────────────────────────────────┘
```
## arrayRotateLeft {#arrayrotateleft}

Поворачивает [массив](/sql-reference/data-types/array) влево на указанное количество элементов.
Если количество элементов отрицательное, массив поворачивается вправо.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для поворота.

**Возвращаемое значение**

- Массив, повернутый влево на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateLeft(['a','b','c','d','e'], 3) as res;
```

Результат:

```text
┌─res───────────────────┐
│ ['d','e','a','b','c'] │
└───────────────────────┘
```
## arrayRotateRight {#arrayrotateright}

Поворачивает [массив](/sql-reference/data-types/array) вправо на указанное количество элементов.
Если количество элементов отрицательное, массив поворачивается влево.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для поворота.

**Возвращаемое значение**

- Массив, повернутый вправо на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateRight(['a','b','c','d','e'], 3) as res;
```

Результат:

```text
┌─res───────────────────┐
│ ['c','d','e','a','b'] │
└───────────────────────┘
```
## arrayShiftLeft {#arrayshiftleft}

Сдвигает [массив](/sql-reference/data-types/array) влево на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элемента массива.
Если количество элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательный. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый влево на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

```text
┌─res─────────────┐
│ [3,4,5,6,42,42] │
└─────────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

```text
┌─res─────────────────────────────┐
│ ['d','e','f','foo','foo','foo'] │
└─────────────────────────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

```text
┌─res─────────────────┐
│ [3,4,5,6,4242,4242] │
└─────────────────────┘
```
## arrayShiftRight {#arrayshiftright}

Сдвигает [массив](/sql-reference/data-types/array) вправо на указанное количество элементов.
Новые элементы заполняются переданным аргументом или значением по умолчанию для типа элемента массива.
Если количество элементов отрицательное, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательный. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый вправо на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

```text
┌─res─────────────┐
│ [42,42,1,2,3,4] │
└─────────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

```text
┌─res─────────────────────────────┐
│ ['foo','foo','foo','a','b','c'] │
└─────────────────────────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

```text
┌─res─────────────────┐
│ [4242,4242,1,2,3,4] │
└─────────────────────┘
```
## arrayRandomSample {#arrayrandomsample}

Функция `arrayRandomSample` возвращает подмножество из `samples` случайных элементов входного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, т.е. возвращаются все элементы массива, но их порядок не гарантируется. Функция может обрабатывать как плоские массивы, так и вложенные массивы.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

- `arr` — Входной массив, из которого следует выбирать элементы. ([Array(T)](/sql-reference/data-types/array))
- `samples` — Количество элементов, которые необходимо включить в случайную выборку ([UInt*](../data-types/int-uint.md))

**Возвращаемое значение**

- Массив, содержащий случайную выборку элементов из входного массива. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

Результат:

```response
┌─res────────────────┐
│ ['cherry','apple'] │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

Результат:

```response
┌─res───────────┐
│ [[3,4],[5,6]] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([1, 2, 3], 5) as res;
```

Результат:

```response
┌─res─────┐
│ [3,1,2] │
└─────────┘
```
## arrayNormalizedGini {#arraynormalizedgini}

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

- `predicted` — Предсказанные значения ([Array(T)](/sql-reference/data-types/array))
- `label` — Фактические значения ([Array(T)](/sql-reference/data-types/array))

**Возвращаемое значение**

- Кортеж, содержащий коэффициенты Джини предсказанных значений, коэффициент Джини нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух коэффициентов Джини).

**Примеры**

Запрос:

```sql
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2]);
```

Результат:

```response
┌─arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2])──────────┐
│ (0.18055555555555558,0.2638888888888889,0.6842105263157896) │
└─────────────────────────────────────────────────────────────┘
```
## Distance functions {#distance-functions}

Все поддерживаемые функции описаны в [документации по функциям расстояний](../../sql-reference/functions/distance-functions.md).
```
