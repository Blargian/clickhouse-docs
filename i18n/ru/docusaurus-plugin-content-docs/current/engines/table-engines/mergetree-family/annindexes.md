---
description: 'Документация по точному и приближенному поиску ближайших соседей'
keywords: ['векторный поиск по сходству', 'ann', 'knn', 'hnsw', 'индексы', 'индекс', 'ближайший сосед']
sidebar_label: 'Точный и приближенный поиск ближайших соседей'
slug: /engines/table-engines/mergetree-family/annindexes
title: 'Точный и приближенный поиск ближайших соседей'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import PrivatePreviewBadge from '@theme/badges/PrivatePreviewBadge';


# Точный и приближенный поиск ближайших соседей

<ExperimentalBadge/>
<PrivatePreviewBadge/>

Проблема нахождения N ближайших точек в многомерном (векторном) пространстве для данной точки называется [поиском ближайших соседей](https://en.wikipedia.org/wiki/Nearest_neighbor_search). 
Существует два общих подхода для решения задачи поиска ближайших соседей:
- Точный поиск ближайших соседей вычисляет расстояние между заданной точкой и всеми точками в векторном пространстве. Это обеспечивает максимальную точность, т.е. возвращаемые точки гарантированно являются фактическими ближайшими соседями. Поскольку пространство векторов исследуется исчерпывающе, точный поиск может быть слишком медленным для практического применения.
- Приближенный поиск ближайших соседей относится к группе техник (например, специальные структуры данных, такие как графы и случайные леса), которые вычисляют результаты намного быстрее, чем точный поиск ближайших соседей. Точность результатов, как правило, «достаточно хороша» для практического использования. Многие приближенные техники предоставляют параметры для настройки компромисса между точностью результата и временем поиска.

Поиск ближайших соседей (точный или приближенный) можно записать в SQL следующим образом:

```sql
WITH [...] AS reference_vector
SELECT [...]
FROM table
WHERE [...] -- предложение WHERE является необязательным
ORDER BY <DistanceFunction>(vectors, reference_vector)
LIMIT <N>
```

Точки в векторном пространстве хранятся в колонке `vectors` типа массив, например, [Array(Float64)](../../../sql-reference/data-types/array.md), [Array(Float32)](../../../sql-reference/data-types/array.md) или [Array(BFloat16)](../../../sql-reference/data-types/array.md).
Ссылка вектора - это постоянный массив и задается в качестве общего табличного выражения.
`<DistanceFunction>` вычисляет расстояние между опорной точкой и всеми сохраненными точками.
Для этого можно использовать любую из доступных [функций расстояния](/sql-reference/functions/distance-functions).
`N` определяет, сколько соседей должно быть возвращено.

## Точный поиск ближайших соседей {#exact-nearest-neighbor-search}

Точный поиск ближайших соседей можно выполнить, используя указанный выше запрос SELECT без изменений. 
Время выполнения таких запросов, как правило, пропорционально количеству сохраненных векторов и их размерности, т.е. количеству элементов массива. 
Кроме того, поскольку ClickHouse выполняет проверку всех векторов, время выполнения также зависит от количества потоков в запросе (см. настройку [max_threads](../../../operations/settings/settings.md#max_threads)).

Одним из распространенных подходов к ускорению точного поиска ближайших соседей является использование типа данных с более низкой точностью [float](../../../sql-reference/data-types/float.md). 
Например, если векторы хранятся в виде `Array(BFloat16)` вместо `Array(Float32)`, то размер данных уменьшается вдвое, и ожидается, что время выполнения запросов также уменьшится вдвое. 
Этот метод известен как квантование, и он может снизить точность результата, несмотря на исчерпывающее сканирование всех векторов. 
Приемлема ли потеря точности, зависит от случая использования и, как правило, требует экспериментов.

## Пример {#exact-nearest-neighbor-search-example}

```sql
CREATE TABLE tab(id Int32, vec Array(Float32)) ENGINE = MergeTree ORDER BY id;

INSERT INTO tab VALUES (0, [1.0, 0.0]), (1, [1.1, 0.0]), (2, [1.2, 0.0]), (3, [1.3, 0.0]), (4, [1.4, 0.0]), (5, [1.5, 0.0]), (6, [0.0, 2.0]), (7, [0.0, 2.1]), (8, [0.0, 2.2]), (9, [0.0, 2.3]), (10, [0.0, 2.4]), (11, [0.0, 2.5]);

WITH [0., 2.] AS reference_vec
SELECT id, vec
FROM tab
ORDER BY L2Distance(vec, reference_vec) ASC
LIMIT 3;
```

возвращает

```result
   ┌─id─┬─vec─────┐
1. │  6 │ [0,2]   │
2. │  7 │ [0,2.1] │
3. │  8 │ [0,2.2] │
   └────┴─────────┘
```


# Приближенный поиск ближайших соседей {#approximate-nearest-neighbor-search}

ClickHouse предоставляет специальный индекс "векторного сходства" для выполнения приближенного поиска ближайших соседей.

:::note
Индексы векторного сходства в настоящее время являются экспериментальными. 
Чтобы включить их, сначала выполните `SET allow_experimental_vector_similarity_index = 1`. 
Если возникнут проблемы, пожалуйста, откройте проблему на github.com/clickhouse/clickhouse/issues.
:::

## Создание индекса векторного сходства {#creating-a-vector-similarity-index}

Индекс векторного сходства можно создать на новой таблице следующим образом:

```sql
CREATE TABLE table
(
  [...],
  vectors Array(Float*),
  INDEX <index_name> vectors TYPE vector_similarity(<type>, <distance_function>, <dimensions>) [GRANULARITY <N>]
)
ENGINE = MergeTree
ORDER BY [...]
```

Либо, чтобы добавить индекс векторного сходства в существующую таблицу:

```sql
ALTER TABLE table ADD INDEX <index_name> vectors TYPE vector_similarity(<type>, <distance_function>, <dimensions>) [GRANULARITY N];
```

Индексы векторного сходства - это особые виды индексов пропуска (см. [здесь](mergetree.md#table_engine-mergetree-data_skipping-indexes) и [здесь](../../../optimize/skipping-indexes)). 
Соответственно, вышеуказанное утверждение `ALTER TABLE` вызывает построение индекса только для новых данных, вставляемых в таблицу. 
Чтобы построить индекс для существующих данных, его необходимо материализовать:

```sql
ALTER TABLE table MATERIALIZE <index_name> SETTINGS mutations_sync = 2;
```

Функция `<distance_function>` должна быть либо
- `L2Distance`, [Евклидово расстояние](https://en.wikipedia.org/wiki/Euclidean_distance), представляющее длину линии между двумя точками в евклидовой пространстве, либо
- `cosineDistance`, [косинусное расстояние](https://en.wikipedia.org/wiki/Cosine_similarity#Cosine_distance), представляющее угол между двумя ненулевыми векторами.

Для нормализованных данных `L2Distance` обычно является лучшим выбором, в противном случае рекомендуется использовать `cosineDistance`, чтобы компенсировать масштаб.

`<dimensions>` ограничивает количество элементов, которые должен содержать каждый массив в основной колонке (значение должно быть > 0). 
Если ClickHouse находит массив с другим количеством элементов во время создания индекса, индекс отклоняется, и возвращается ошибка.

Параметр GRANULARITY `<N>` относится к размеру гранул индекса (см. [здесь](../../../optimize/skipping-indexes)). 
Значение по умолчанию 100 миллионов должно хорошо подходить для большинства случаев использования, но его также можно настраивать. 
Мы рекомендуем настраивать только для опытных пользователей, которые понимают последствия своих действий (см. ниже).

Индексы векторного сходства являются универсальными, поскольку они могут адаптироваться к различным методам приближенного поиска. 
Фактически используемый метод указывается параметром `<type>`. 
На данный момент единственный доступный метод - HNSW ([академическая статья](https://arxiv.org/abs/1603.09320)), популярная и современная техника для приближенного векторного поиска, основанная на иерархических графах близости. 
Если HNSW используется в качестве типа, пользователи могут дополнительно указать параметры, специфичные для HNSW:

```sql
CREATE TABLE table
(
  [...],
  vectors Array(Float*),
  INDEX index_name vectors TYPE vector_similarity('hnsw', <distance_function>, <dimensions>[, quantization, hnsw_max_connections_per_layer, hnsw_candidate_list_size_for_construction]) [GRANULARITY N]
)
ENGINE = MergeTree
ORDER BY [...]
```

Эти параметры, специфичные для HNSW, доступны:
- `quantization` контролирует квантование векторов в графе близости. Возможные значения: `f64`, `f32`, `f16`, `bf16` или `i8`. Значение по умолчанию - `bf16`. Обратите внимание, что этот параметр не влияет на представление векторов в основной колонке.
- `hnsw_max_connections_per_layer` контролирует количество соседей на графовом узле, также известное как параметр HNSW `M`. Значение по умолчанию - `32`. Значение `0` означает использование значения по умолчанию.
- `hnsw_candidate_list_size_for_construction` контролирует размер динамического списка кандидатов во время построения графа HNSW, также известное как параметр HNSW `ef_construction`. Значение по умолчанию - `128`. Значение `0` означает использование значения по умолчанию.

Все параметры, специфичные для HNSW, имеют разумные значения по умолчанию, которые хорошо работают в большинстве случаев использования. В связи с этим мы поэтому не рекомендуем настраивать параметры, специфичные для HNSW.

Дополнительные ограничения:
- Индексы векторного сходства могут быть построены только на колонках типа [Array(Float32)](../../../sql-reference/data-types/array.md) или [Array(Float64)](../../../sql-reference/data-types/array.md). Массивы nullable и low-cardinality, такие как `Array(Nullable(Float32))` и `Array(LowCardinality(Float32))`, не допускаются.
- Индексы векторного сходства должны строиться на отдельных колонках.
- Индексы векторного сходства могут быть построены на вычисленных выражениях (например, `INDEX index_name arraySort(vectors) TYPE vector_similarity([...])`), но такие индексы не могут быть использованы для приближенного поиска соседей позже.
- Индексы векторного сходства требуют, чтобы все массивы в основной колонке имели `<dimension>`-много элементов. Это проверяется во время создания индекса. Чтобы как можно быстрее обнаружить нарушения этого требования, пользователи могут добавить [ограничение](/sql-reference/statements/create/table.md#constraints) для векторной колонки, например, `CONSTRAINT same_length CHECK length(vectors) = 256`.
- Аналогично, значения массивов в основной колонке не должны быть (`[]`) или иметь значение по умолчанию (также `[]`).

## Использование индекса векторного сходства {#using-a-vector-similarity-index}

:::note
Чтобы использовать индексы векторного сходства, настройка [compatibility](../../../operations/settings/settings.md) должна равняться `''` (значение по умолчанию), или `'25.1'` или новее.
:::

Индексы векторного сходства поддерживают SELECT-запросы следующей формы:

```sql
WITH [...] AS reference_vector
SELECT [...]
FROM table
WHERE [...] -- предложение WHERE является необязательным
ORDER BY <DistanceFunction>(vectors, reference_vector)
LIMIT <N>
```

Оптимизатор запросов ClickHouse пытается сопоставить вышеуказанный шаблон запроса и использовать доступные индексы векторного сходства. 
Запрос может использовать индекс векторного сходства только в том случае, если функция расстояния в запросе SELECT совпадает с функцией расстояния в определении индекса.

Опытные пользователи могут указать пользовательское значение для настройки `hnsw_candidate_list_size_for_search` (также известного как параметр HNSW `ef_search`), чтобы настроить размер списка кандидатов во время поиска (например, `SELECT [...] SETTINGS hnsw_candidate_list_size_for_search = <value>`). 
Значение по умолчанию 256 хорошо работает в большинстве случаев применения. 
Более высокие значения настройки означают лучшую точность за счет более медленной производительности.

Если запрос может использовать индекс векторного сходства, ClickHouse проверяет, что LIMIT `<N>`, указанный в запросах SELECT, находится в разумных пределах. 
Более конкретно, возвращается ошибка, если `<N>` больше значения настройки `max_limit_for_ann_queries` со значением по умолчанию 100. 
Слишком большие LIMIT могут замедлить поиск и обычно указывают на ошибку использования.

Чтобы проверить, использует ли запрос SELECT индекс векторного сходства, можно предварить запрос `EXPLAIN indexes = 1`.

В качестве примера, запрос

```sql
EXPLAIN indexes = 1
WITH [0., 2.] AS reference_vec
SELECT id, vec
FROM tab
ORDER BY L2Distance(vec, reference_vec) ASC
LIMIT 3;
```

может вернуть

```result
    ┌─explain─────────────────────────────────────────────────────────────────────────────────────────┐
 1. │ Expression (Project names)                                                                      │
 2. │   Limit (preliminary LIMIT (without OFFSET))                                                    │
 3. │     Sorting (Sorting for ORDER BY)                                                              │
 4. │       Expression ((Before ORDER BY + (Projection + Change column names to column identifiers))) │
 5. │         ReadFromMergeTree (default.tab)                                                         │
 6. │         Indexes:                                                                                │
 7. │           PrimaryKey                                                                            │
 8. │             Condition: true                                                                     │
 9. │             Parts: 1/1                                                                          │
10. │             Granules: 4/4                                                                       │
11. │           Skip                                                                                  │
12. │             Name: idx                                                                           │
13. │             Description: vector_similarity GRANULARITY 100000000                                │
14. │             Parts: 1/1                                                                          │
15. │             Granules: 2/4                                                                       │
    └─────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Индексы векторного сходства используются, если вывод содержит `Skip` и имя вместе с типом векторного индекса (в этом примере, `idx` и `vector_similarity`). 
В этом случае индекс векторного сходства пропустил два из четырех гранул, то есть 50% данных. 
Чем больше гранул может быть пропущено, тем более эффективным становится использование индекса.

:::tip
Чтобы обеспечить использование индекса, вы можете выполнить SELECT-запрос с настройкой [force_data_skipping_indexes](../../../operations/settings/settings#force_data_skipping_indices) (укажите имя индекса в качестве значения настройки).
:::

** Постфильтрация и предфильтрация**

Пользователи могут дополнительно указать `WHERE`-клауза с дополнительными условиями фильтрации в запросах SELECT. 
В зависимости от этих условий фильтрации ClickHouse будет использовать постфильтрацию или предфильтрацию. 
Эти две стратегии определяют порядок, в котором оцениваются фильтры:
- При постфильтрации индекс векторного сходства оценивается первым, после чего ClickHouse оценивает дополнительные фильтры, указанные в предложении `WHERE`.
- При предфильтрации порядок оценки фильтров обратный.

Обе стратегии имеют разные компромиссы:
- Постфильтрация имеет общую проблему, что она может вернуть меньше, чем количество строк, запрошенное в предложении `LIMIT <N>`. Это происходит, когда хотя бы одна из строк результата, возвращаемая индексом векторного сходства, не соответствует дополнительным фильтрам. В ClickHouse, к счастью, такая ситуация маловероятна, потому что индексы векторного сходства не возвращают строки, а блоки с тысячами строк (см. "Различия с обычными индексами пропуска" ниже).
- Предфильтрация является неразрешенной задачей. Некоторые специализированные векторные базы данных реализуют ее, но большинство баз данных, включая ClickHouse, будут возвращаться к точному поиску соседей, т.е. к сканированию без индекса.

Какой подход будет использоваться, зависит от того, может ли ClickHouse использовать индексы для дополнительных условий фильтрации.

Если индекс использовать невозможно, будет применена постфильтрация.

Если дополнительное условие фильтрации является частью ключа партиции, то ClickHouse применит обрезку партиций.

Например, предположим, что таблица партиционирована по диапазону по полю `year`:

```sql
WITH [0., 2.] AS reference_vec
SELECT id, vec
FROM tab
WHERE year = 2025
ORDER BY L2Distance(vec, reference_vec) ASC
LIMIT 3;
```

ClickHouse проигнорирует все партии, кроме партии для 2025 года. 
В пределах этой партиции будет применена стратегия постфильтрации.

Если дополнительное условие фильтрации является частью первичного ключа, ClickHouse всегда будет применять предфильтрацию.

## Администрирование {#administration}

Размер индексов векторного сходства на диске можно получить из [system.data_skipping_indices](../../../operations/system-tables/data_skipping_indices):

```sql
SELECT database, table, name, formatReadableSize(data_compressed_bytes)
FROM system.data_skipping_indices
WHERE type = 'vector_similarity';
```

Пример вывода:

```result
┌─database─┬─table─┬─name─┬─formatReadab⋯ssed_bytes)─┐
│ default  │ tab   │ idx  │ 348.00 MB                │
└──────────┴───────┴──────┴──────────────────────────┘
```

## Настройка производительности {#performance-tuning}

**Настройка создания индекса**

Жизненный цикл индексов векторного сходства связан с жизненным циклом частей. 
Другими словами, всякий раз, когда создается новая часть с определенным индексом векторного сходства, индекс также создается. 
Это обычно происходит, когда данные [вставляются](https://clickhouse.com/docs/guides/inserting-data) или во время [слияний](https://clickhouse.com/docs/merges). 
К сожалению, HNSW известен длительным временем создания индекса, что может значительно замедлить вставки и слияния. 
Индексы векторного сходства, в идеале, следует использовать только если данные неизменяемы или редко изменяются.

Чтобы ускорить создание индекса, можно использовать следующие методы:

Во-первых, создание индекса можно параллelizовать. 
Максимальное количество потоков для создания индекса можно настроить с помощью серверной настройки [max_build_vector_similarity_index_thread_pool_size](/operations/server-configuration-parameters/settings#max_build_vector_similarity_index_thread_pool_size). 
Для получения оптимальной производительности значение настройки должно быть настроено в соответствии с количеством ядер CPU.

Во-вторых, чтобы ускорить операторы INSERT, пользователи могут отключить создание индексов пропуска для вновь вставленных частей, используя настройку сессии [materialize_skip_indexes_on_insert](../../../operations/settings/settings.md). 
Запросы SELECT по таким частям будут возвращаться к точному поиску. 
Поскольку вставленные части обычно малы по сравнению с общим размером таблицы, ожидается, что влияние на производительность будет незначительным.

В-третьих, чтобы ускорить слияния, пользователи могут отключить создание индексов пропуска для объединенных частей, используя настройку сессии [materialize_skip_indexes_on_merge](../../../operations/settings/merge-tree-settings.md#materialize_skip_indexes_on_merge). 
Это, в сочетании с оператором [ALTER TABLE \[...\] MATERIALIZE INDEX \[...\]](../../../sql-reference/statements/alter/skipping-index.md#materialize-index), предоставляет явный контроль над жизненным циклом индексов векторного сходства. 
Например, создание индекса можно отложить до тех пор, пока все данные не будут загружены, или до периода низкой загрузки системы, такого как выходные дни.

**Настройка использования индекса**

Запросы SELECT должны загружать индексы векторного сходства в основную память для их использования. 
Чтобы избежать повторной загрузки одного и того же индекса векторного сходства в основную память, ClickHouse предоставляет выделенный кэш в памяти для таких индексов. 
Чем больше этот кэш, тем меньше ненужных загрузок произойдет. 
Максимальный размер кэша можно настроить с помощью серверной настройки [vector_similarity_index_cache_size](../../../operations/server-configuration-parameters/settings.md#vector_similarity_index_cache_size). 
По умолчанию кэш может увеличиваться до 5 ГБ.

Текущий размер кэша отображается в [system.metrics](../../../operations/system-tables/metrics.md):

```sql
SELECT metric, value
FROM system.metrics
WHERE metric = 'VectorSimilarityIndexCacheSize'
```

Количество попаданий и промахов кэша для запроса с некоторым идентификатором запроса можно получить из [system.query_log](../../../operations/system-tables/query_log.md):

```sql
SYSTEM FLUSH LOGS query_log;

SELECT ProfileEvents['VectorSimilarityIndexCacheHits'], ProfileEvents['VectorSimilarityIndexCacheMisses']
FROM system.query_log
WHERE type = 'QueryFinish' AND query_id = '<...>'
ORDER BY event_time_microseconds;
```

Для производственных случаев мы рекомендуем, чтобы кэш был достаточно велик, чтобы все индексы векторов оставались в памяти в любое время.

## Различия с обычными индексами пропуска {#differences-to-regular-skipping-indexes}

Как и все обычные [индексы пропуска](/optimize/skipping-indexes), индексы векторного сходства строятся по гранулам, и каждый индексированный блок состоит из `GRANULARITY = [N]`-многих гранул (`[N]` = 1 по умолчанию для обычных индексов пропуска). 
Например, если первичная гранулярность индекса таблицы составляет 8192 (настройка `index_granularity = 8192`), и `GRANULARITY = 2`, то каждый индексированный блок будет содержать 16384 строки. 
Тем не менее, структуры данных и алгоритмы для приближенного поиска соседей являются по своей природе ориентированными на строки. 
Они хранят компактное представление набора строк и также возвращают строки для запросов векторного поиска. 
Это вызывает некоторые довольно неинтуитивные различия в том, как ведут себя индексы векторного сходства по сравнению с обычными индексами пропуска.

Когда пользователь определяет индекс векторного сходства на колонке, ClickHouse внутренне создает "суб-индекс" векторного сходства для каждого индексированного блока. 
Суб-индекс является "локальным" в том смысле, что он знает только о строках своего содержащего индекса блока. 
В приведенном выше примере и при условии, что колонка содержит 65536 строк, мы получаем четыре индексированных блока (охватывающих восемь гранул) и суб-индекс векторного сходства для каждого индексированного блока. 
Суб-индекс теоретически способен вернуть строки с N ближайшими точками в пределах своего индексированного блока напрямую. 
Тем не менее, поскольку ClickHouse загружает данные с диска в память с гранулярностью гранул, суб-индексы экстраполируют соответствующие строки до гранулярности гранул. 
Это отличается от обычных индексов пропуска, которые пропускают данные на гранулярности индексных блоков.

Параметр `GRANULARITY` определяет, сколько суб-индексов векторного сходства создается. 
Большие значения `GRANULARITY` означают меньше, но большие суб-индексы векторного сходства, до той точки, где колонка (или часть данных колонки) имеет только один суб-индекс. 
В этом случае суб-индекс имеет "глобальное" представление всех строк колонки и может напрямую вернуть все гранулы колонки (части) с соответствующими строками (максимум `LIMIT [N]`-много таких гранул). 
На втором этапе ClickHouse загружает эти гранулы и определяет фактически лучшие строки, производя брутфорс-вычисление расстояния по всем строкам гранул. 
При небольшом значении `GRANULARITY` каждый из суб-индексов возвращает до `LIMIT N`-многих гранул. 
В результате необходимо загружать и постфильтровать больше гранул. 
Обратите внимание, что точность поиска в обоих случаях одинакова, только производительность обработки различается. 
Как правило, рекомендуется использовать большое значение `GRANULARITY` для индексов векторного сходства и возвращаться к меньшим значениям `GRANULARITY` только в случае проблем, таких как чрезмерное использование памяти структур векторного сходства. 
Если значение `GRANULARITY` не было указано для индексов векторного сходства, то его значение по умолчанию составляет 100 миллионов.

## Пример {#approximate-nearest-neighbor-search-example}

```sql
CREATE TABLE tab(id Int32, vec Array(Float32), INDEX idx vec TYPE vector_similarity('hnsw', 'L2Distance', 2)) ENGINE = MergeTree ORDER BY id;

INSERT INTO tab VALUES (0, [1.0, 0.0]), (1, [1.1, 0.0]), (2, [1.2, 0.0]), (3, [1.3, 0.0]), (4, [1.4, 0.0]), (5, [1.5, 0.0]), (6, [0.0, 2.0]), (7, [0.0, 2.1]), (8, [0.0, 2.2]), (9, [0.0, 2.3]), (10, [0.0, 2.4]), (11, [0.0, 2.5]);

WITH [0., 2.] AS reference_vec
SELECT id, vec
FROM tab
ORDER BY L2Distance(vec, reference_vec) ASC
LIMIT 3;
```

возвращает

```result
   ┌─id─┬─vec─────┐
1. │  6 │ [0,2]   │
2. │  7 │ [0,2.1] │
3. │  8 │ [0,2.2] │
   └────┴─────────┘
```


# Ссылки {#references}

Блоги:
- [Векторный Поиск с ClickHouse - Часть 1](https://clickhouse.com/blog/vector-search-clickhouse-p1)
- [Векторный Поиск с ClickHouse - Часть 2](https://clickhouse.com/blog/vector-search-clickhouse-p2)
