---
description: 'Буферизирует данные для записи в ОЗУ, периодически сбрасывая их в другую
  таблицу. В ходе операции чтения данные считываются как из буфера, так и из другой таблицы одновременно.'
sidebar_label: 'Буфер'
sidebar_position: 120
slug: /engines/table-engines/special/buffer
title: 'Движок таблицы Буфер'
---


# Движок таблицы Буфер

Буферизирует данные для записи в ОЗУ, периодически сбрасывая их в другую таблицу. В ходе операции чтения данные считываются как из буфера, так и из другой таблицы одновременно.

:::note
Рекомендуемая альтернатива движку таблицы Буфер — включение [асинхронных вставок](/guides/best-practices/asyncinserts.md).
:::

```sql
Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes [,flush_time [,flush_rows [,flush_bytes]]])
```

### Параметры движка: {#engine-parameters}

#### database {#database}

`database` – Имя базы данных. Вы можете использовать `currentDatabase()` или другое константное выражение, которое возвращает строку.

#### table {#table}

`table` – Таблица, в которую будут сбрасываться данные.

#### num_layers {#num_layers}

`num_layers` – Уровень параллелизма. Физически таблица будет представлена в виде `num_layers` независимых буферов.

#### min_time, max_time, min_rows, max_rows, min_bytes, и max_bytes {#min_time-max_time-min_rows-max_rows-min_bytes-and-max-bytes}

Условия для сброса данных из буфера.

### Дополнительные параметры движка: {#optional-engine-parameters}

#### flush_time, flush_rows, и flush_bytes {#flush_time-flush_rows-and-flush_bytes}

Условия для сброса данных из буфера в фоновом режиме (опущенные или ноль означают отсутствие параметров `flush*`).

Данные сбрасываются из буфера и записываются в целевую таблицу, если выполнены все условия `min*` или хотя бы одно условие `max*`.

Кроме того, если выполнено хотя бы одно условие `flush*`, в фоновом режиме инициируется сброс. Это отличается от `max*`, так как `flush*` позволяет вам настраивать фоновые сбросы отдельно, чтобы избежать добавления задержки для запросов `INSERT` в таблицы Буфер.

#### min_time, max_time, и flush_time {#min_time-max_time-and-flush_time}

Условие для времени в секундах с момента первой записи в буфер.

#### min_rows, max_rows, и flush_rows {#min_rows-max_rows-and-flush_rows}

Условие для количества строк в буфере.

#### min_bytes, max_bytes, и flush_bytes {#min_bytes-max_bytes-and-flush_bytes}

Условие для количества байт в буфере.

В ходе операции записи данные вставляются в один или несколько произвольных буферов (настраиваемых с помощью `num_layers`). Или, если часть данных для вставки достаточно велика (больше чем `max_rows` или `max_bytes`), она записывается напрямую в целевую таблицу, обходя буфер.

Условия для сброса данных рассчитываются отдельно для каждого из `num_layers` буферов. Например, если `num_layers = 16` и `max_bytes = 100000000`, максимальное потребление ОЗУ составит 1.6 ГБ.

Пример:

```sql
CREATE TABLE merge.hits_buffer AS merge.hits ENGINE = Buffer(merge, hits, 1, 10, 100, 10000, 1000000, 10000000, 100000000)
```

Создание таблицы `merge.hits_buffer` с той же структурой, что и `merge.hits`, и использование движка Buffer. При записи в эту таблицу данные буферизуются в ОЗУ и позже записываются в таблицу 'merge.hits'. Создается один буфер, и данные сбрасываются, если выполнено хотя бы одно из следующих условий:
- Прошло 100 секунд с последнего сброса (`max_time`) или
- Записано 1 миллион строк (`max_rows`) или
- Записано 100 МБ данных (`max_bytes`) или
- Прошло 10 секунд (`min_time`) и записано 10,000 строк (`min_rows`) и 10 МБ (`min_bytes`) данных

Например, если была записана всего одна строка, после 100 секунд она будет сброшена, независимо от других условий. Но если было записано много строк, данные будут сброшены раньше.

Когда сервер останавливается, с помощью `DROP TABLE` или `DETACH TABLE`, буферизированные данные также сбрасываются в целевую таблицу.

Вы можете установить пустые строки в одинарные кавычки для имени базы данных и таблицы. Это указывает на отсутствие целевой таблицы. В этом случае, когда условия сброса данных достигаются, буфер просто очищается. Это может быть полезно для удержания окна данных в памяти.

При чтении из таблицы Буфер данные обрабатываются как из буфера, так и из целевой таблицы (если она существует).
Обратите внимание, что таблица Буфер не поддерживает индекс. Другими словами, данные в буфере полностью просматриваются, что может быть медленным для больших буферов. (Для данных в подчиненной таблице будет использоваться поддерживаемый индекс.)

Если набор столбцов в таблице Буфер не совпадает с набором столбцов в подчиненной таблице, осуществляется вставка подмножества столбцов, которые присутствуют в обеих таблицах.

Если типы не совпадают для одного из столбцов в таблице Буфер и подчиненной таблице, в журнал сервера записывается сообщение об ошибке, и буфер очищается.
То же самое происходит, если подчиненная таблица не существует при сбросе буфера.

:::note
Запуск ALTER на таблице Буфер в выпусках, сделанных до 26 октября 2021 года, вызовет ошибку `Block structure mismatch` (см. [#15117](https://github.com/ClickHouse/ClickHouse/issues/15117) и [#30565](https://github.com/ClickHouse/ClickHouse/pull/30565)), поэтому единственным вариантом является удаление таблицы Буфер и ее последующее воссоздание. Проверьте, что эта ошибка исправлена в вашем выпуске, прежде чем пытаться выполнить ALTER на таблице Буфер.
:::

Если сервер перезагружается ненормально, данные в буфере теряются.

`FINAL` и `SAMPLE` не работают корректно для таблиц Буфер. Эти условия передаются в целевую таблицу, но не используются для обработки данных в буфере. Если эти функции необходимы, мы рекомендуем использовать таблицу Буфер только для записи, а для чтения — целевую таблицу.

При добавлении данных в таблицу Буфер один из буферов блокируется. Это вызывает задержки, если одновременно выполняется операция чтения из таблицы.

Данные, вставленные в таблицу Буфер, могут оказаться в подчиненной таблице в другом порядке и в разных блоках. Из-за этого таблицу Буфер сложно использовать для корректной записи в CollapsingMergeTree. Чтобы избежать проблем, вы можете установить `num_layers` в 1.

Если целевая таблица реплицирована, некоторые ожидаемые характеристики реплицированных таблиц теряются при записи в таблицу Буфер. Случайные изменения в порядке строк и размерах частей данных приводят к прекращению работы дедупликации данных, что означает, что невозможно выполнить надежную запись 'exactly once' в реплицированные таблицы.

Из-за этих недостатков мы можем рекомендовать использовать таблицу Буфер только в редких случаях.

Таблица Буфер используется, когда поступает слишком много INSERT с большого числа серверов за единицу времени, и данные не могут быть буферизированы перед вставкой, что означает, что INSERT не могут выполняться достаточно быстро.

Обратите внимание, что нет смысла вставлять данные по одной строке, даже для таблиц Буфер. Это обеспечит скорость лишь в несколько тысяч строк в секунду, в то время как вставка больших блоков данных может обеспечить более миллиона строк в секунду.
