---
description: 'Позволяет быстро записывать состояния объектов, которые постоянно меняются, и удалять старые состояния объектов в фоновом режиме.'
sidebar_label: 'VersionedCollapsingMergeTree'
sidebar_position: 80
slug: /engines/table-engines/mergetree-family/versionedcollapsingmergetree
title: 'VersionedCollapsingMergeTree'
---


# VersionedCollapsingMergeTree

Этот движок:

- Позволяет быстро записывать состояния объектов, которые постоянно меняются.
- Удаляет старые состояния объектов в фоновом режиме. Это значительно снижает объем хранения.

Смотрите раздел [Collapsing](#table_engines_versionedcollapsingmergetree) для подробностей.

Движок наследуется от [MergeTree](/engines/table-engines/mergetree-family/versionedcollapsingmergetree) и добавляет логику для коллапса строк к алгоритму слияния частей данных. `VersionedCollapsingMergeTree` выполняет ту же задачу, что и [CollapsingMergeTree](../../../engines/table-engines/mergetree-family/collapsingmergetree.md), но использует другой алгоритм коллапса, который позволяет вставлять данные в любом порядке с помощью нескольких потоков. В частности, столбец `Version` помогает правильно коллапсировать строки, даже если они вставляются в неправильном порядке. В отличие от этого, `CollapsingMergeTree` допускает только строго последовательную вставку.

## Создание таблицы {#creating-a-table}

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE = VersionedCollapsingMergeTree(sign, version)
[PARTITION BY expr]
[ORDER BY expr]
[SAMPLE BY expr]
[SETTINGS name=value, ...]
```

Для описания параметров запроса смотрите [описание запроса](../../../sql-reference/statements/create/table.md).

### Параметры движка {#engine-parameters}

```sql
VersionedCollapsingMergeTree(sign, version)
```

| Параметр  | Описание                                                                            | Тип                                                                                                                                                                                                                                                                                    |
|-----------|----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `sign`    | Имя столбца с типом строки: `1` — это строка "состояния", `-1` — это строка "отмены". | [`Int8`](/sql-reference/data-types/int-uint)                                                                                                                                                                                                                                    |
| `version` | Имя столбца с версией состояния объекта.                               | [`Int*`](/sql-reference/data-types/int-uint), [`UInt*`](/sql-reference/data-types/int-uint), [`Date`](/sql-reference/data-types/date), [`Date32`](/sql-reference/data-types/date32), [`DateTime`](/sql-reference/data-types/datetime) или [`DateTime64`](/sql-reference/data-types/datetime64) |

### Условия запроса {#query-clauses}

При создании таблицы `VersionedCollapsingMergeTree` требуются те же [условия](../../../engines/table-engines/mergetree-family/mergetree.md), что и при создании таблицы `MergeTree`.

<details markdown="1">

<summary>Устаревший метод создания таблицы</summary>

:::note
Не используйте этот метод в новых проектах. Если возможно, переключите старые проекты на описанный выше метод.
:::

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2],
    ...
) ENGINE [=] VersionedCollapsingMergeTree(date-column [, samp#table_engines_versionedcollapsingmergetreeling_expression], (primary, key), index_granularity, sign, version)
```

Все параметры, кроме `sign` и `version`, имеют то же значение, что и в `MergeTree`.

- `sign` — Имя столбца с типом строки: `1` — это строка "состояния", `-1` — это строка "отмены".

    Тип данных столбца — `Int8`.

- `version` — Имя столбца с версией состояния объекта.

    Тип данных столбца должен быть `UInt*`.

</details>

## Коллапс {#table_engines_versionedcollapsingmergetree}

### Данные {#data}

Рассмотрим ситуацию, когда необходимо сохранить постоянно изменяющиеся данные для какого-то объекта. Разумно иметь одну строку для объекта и обновлять её всякий раз, когда происходят изменения. Однако операция обновления является дорогостоящей и медленной для СУБД, поскольку требует перезаписи данных в хранилище. Обновление неприемлемо, если нужно быстро записывать данные, но можно записывать изменения объекта последовательно следующим образом.

Используйте столбец `Sign` при записи строки. Если `Sign = 1`, это означает, что строка является состоянием объекта (назовем её "строкой состояния"). Если `Sign = -1`, это обозначает отмену состояния объекта с теми же атрибутами (назовем её "строкой отмены"). Также используйте столбец `Version`, который должен идентифицировать каждое состояние объекта отдельным номером.

Например, мы хотим подсчитать, сколько страниц пользователи посетили на каком-то сайте и как долго они там были. В какой-то момент времени мы записываем следующую строку с состоянием активности пользователя:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Позже мы фиксируем изменение активности пользователя и записываем это с помощью следующих двух строк.

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Первая строка отменяет предыдущее состояние объекта (пользователя). Она должна копировать все поля отменяемого состояния, кроме `Sign`.

Вторая строка содержит текущее состояние.

Поскольку нам нужно только последнее состояние активности пользователя, строки

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

можно удалить, коллапсируя недействительное (старое) состояние объекта. `VersionedCollapsingMergeTree` делает это во время слияния частей данных.

Чтобы узнать, почему нам нужны две строки для каждого изменения, смотрите [Алгоритм](#table_engines-versionedcollapsingmergetree-algorithm).

**Примечания к использованию**

1. Программа, которая записывает данные, должна помнить состояние объекта, чтобы иметь возможность отменить его. Строка "Отмена" должна содержать копии полей первичного ключа и версию строки "состояния" и противоположный `Sign`. Это увеличивает начальный размер хранения, но позволяет быстро записывать данные.
2. Долгие массивы в столбцах снижают эффективность движка из-за нагрузки при записи. Чем проще данные, тем лучше эффективность.
3. Результаты `SELECT` сильно зависят от согласованности истории изменений объекта. Будьте аккуратны при подготовке данных для вставки. Вы можете получить непредсказуемые результаты с несогласованными данными, такими как отрицательные значения для ненегативных метрик, таких как глубина сеанса.

### Алгоритм {#table_engines-versionedcollapsingmergetree-algorithm}

Когда ClickHouse сливает части данных, он удаляет каждую пару строк, которые имеют одинаковый первичный ключ и версию и разные `Sign`. Порядок строк не имеет значения.

Когда ClickHouse вставляет данные, он упорядочивает строки по первичному ключу. Если столбец `Version` не входит в первичный ключ, ClickHouse добавляет его в первичный ключ неявно как последнее поле и использует его для упорядочивания.

## Выбор данных {#selecting-data}

ClickHouse не гарантирует, что все строки с одинаковым первичным ключом будут в одной результирующей части данных или даже на одном физическом сервере. Это верно как для записи данных, так и для последующего слияния частей данных. Кроме того, ClickHouse обрабатывает запросы `SELECT` с помощью нескольких потоков, и он не может предсказать порядок строк в результате. Это означает, что агрегация требуется, если необходимо получить полностью "коллапсированные" данные из таблицы `VersionedCollapsingMergeTree`.

Чтобы закончить коллапс, напишите запрос с условием `GROUP BY` и агрегатными функциями, которые учитывают знак. Например, чтобы подсчитать количество, используйте `sum(Sign)`, а не `count()`. Чтобы получить сумму чего-либо, используйте `sum(Sign * x)`, а не `sum(x)`, и добавьте `HAVING sum(Sign) > 0`.

Агрегаты `count`, `sum` и `avg` можно вычислить таким образом. Агрегат `uniq` можно вычислить, если у объекта есть хотя бы одно неколлапсированное состояние. Агрегаты `min` и `max` не могут быть рассчитаны, потому что `VersionedCollapsingMergeTree` не сохраняет историю значений коллапсированных состояний.

Если вам нужно извлечь данные с "коллапсом", но без агрегации (например, чтобы проверить, есть ли строки, у которых новейшие значения соответствуют определенным условиям), вы можете использовать модификатор `FINAL` для условия `FROM`. Этот подход неэффективен и не должен использоваться с большими таблицами.

## Пример использования {#example-of-use}

Пример данных:

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 |
│ 4324182021466249494 │         5 │      146 │   -1 │       1 |
│ 4324182021466249494 │         6 │      185 │    1 │       2 |
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Создание таблицы:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8,
    Version UInt8
)
ENGINE = VersionedCollapsingMergeTree(Sign, Version)
ORDER BY UserID
```

Вставка данных:

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1, 1)
```

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1, 1),(4324182021466249494, 6, 185, 1, 2)
```

Мы используем два запроса `INSERT`, чтобы создать две разные части данных. Если мы вставим данные одним запросом, ClickHouse создаст одну часть данных и никогда не выполнит слияние.

Получение данных:

```sql
SELECT * FROM UAct
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │    1 │       1 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         5 │      146 │   -1 │       1 │
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Что мы здесь видим и где коллапсированные части?
Мы создали две части данных, используя два запроса `INSERT`. Запрос `SELECT` был выполнен в двух потоках, и результат представляет собой случайный порядок строк.
Коллапс не произошел, потому что части данных еще не были слиты. ClickHouse сливает части данных в неизвестный момент времени, который мы не можем предсказать.

Вот почему нам нужна агрегация:

```sql
SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration,
    Version
FROM UAct
GROUP BY UserID, Version
HAVING sum(Sign) > 0
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │       2 │
└─────────────────────┴───────────┴──────────┴─────────┘
```

Если нам не нужна агрегация и мы хотим принудительно выполнить коллапс, мы можем использовать модификатор `FINAL` для условия `FROM`.

```sql
SELECT * FROM UAct FINAL
```

```text
┌──────────────UserID─┬─PageViews─┬─Duration─┬─Sign─┬─Version─┐
│ 4324182021466249494 │         6 │      185 │    1 │       2 │
└─────────────────────┴───────────┴──────────┴──────┴─────────┘
```

Это очень неэффективный способ выбора данных. Не используйте его для больших таблиц.
