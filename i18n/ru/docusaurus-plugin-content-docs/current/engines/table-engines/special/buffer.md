---
description: 'Буферизует данные для записи в RAM, периодически сбрасывая их в другую таблицу. Во время операции чтения данные считываются из буфера и другой таблицы одновременно.'
sidebar_label: 'Buffer'
sidebar_position: 120
slug: /engines/table-engines/special/buffer
title: 'Двигатель таблицы Буфер'
---

# Двигатель таблицы Буфер

Буферизует данные для записи в RAM, периодически сбрасывая их в другую таблицу. Во время операции чтения данные считываются из буфера и другой таблицы одновременно.

:::note
Рекомендуемая альтернатива двигателю таблицы Буфер - включение [асинхронных вставок](/guides/best-practices/asyncinserts.md).
:::

```sql
Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes [,flush_time [,flush_rows [,flush_bytes]]])
```

### Параметры двигателя: {#engine-parameters}

#### database {#database}

`database` – Название базы данных. Вы можете использовать `currentDatabase()` или другое постоянное выражение, которое возвращает строку.

#### table {#table}

`table` – Таблица, в которую будут сбрасываться данные.

#### num_layers {#num_layers}

`num_layers` – Уровень параллелизма. Физически таблица будет представлена как `num_layers` независимых буферов.

#### min_time, max_time, min_rows, max_rows, min_bytes и max_bytes {#min_time-max_time-min_rows-max_rows-min_bytes-and-max_bytes}

Условия для сброса данных из буфера.

### Необязательные параметры двигателя: {#optional-engine-parameters}

#### flush_time, flush_rows и flush_bytes {#flush_time-flush_rows-and-flush_bytes}

Условия для сброса данных из буфера в фоновом режиме (опущенные или ноль означают отсутствие параметров `flush*`).

Данные сбрасываются из буфера и записываются в целевую таблицу, если выполнены все условия `min*` или хотя бы одно условие `max*`.

Также, если выполнено хотя бы одно условие `flush*`, инициируется сброс в фоновом режиме. Это отличается от `max*`, поскольку `flush*` позволяет настраивать фоновые сбросы отдельно, чтобы избежать добавления задержки для запросов `INSERT` в таблицы Буфер.

#### min_time, max_time и flush_time {#min_time-max_time-and-flush_time}

Условие по времени в секундах с момента первой записи в буфер.

#### min_rows, max_rows и flush_rows {#min_rows-max_rows-and-flush_rows}

Условие по количеству строк в буфере.

#### min_bytes, max_bytes и flush_bytes {#min_bytes-max_bytes-and-flush_bytes}

Условие по количеству байт в буфере.

Во время операции записи данные вставляются в один или несколько случайных буферов (настраивается с помощью `num_layers`). Или, если часть данных для вставки достаточно велика (больше `max_rows` или `max_bytes`), она записывается напрямую в целевую таблицу, минуя буфер.

Условия сброса данных рассчитываются отдельно для каждого из `num_layers` буферов. Например, если `num_layers = 16` и `max_bytes = 100000000`, максимальное использование RAM составляет 1,6 ГБ.

Пример:

```sql
CREATE TABLE merge.hits_buffer AS merge.hits ENGINE = Buffer(merge, hits, 1, 10, 100, 10000, 1000000, 10000000, 100000000)
```

Создание таблицы `merge.hits_buffer` с такой же структурой, как у `merge.hits`, и использование двигателя Буфер. При записи в эту таблицу данные буферизуются в RAM и позже записываются в таблицу 'merge.hits'. Создается один буфер, и данные сбрасываются, если произошло одно из следующих событий:
- Прошло 100 секунд с последнего сброса (`max_time`), или
- Записано 1 миллион строк (`max_rows`), или
- Записано 100 МБ данных (`max_bytes`), или
- Прошло 10 секунд (`min_time`), и записано 10,000 строк (`min_rows`) и 10 МБ (`min_bytes`) данных.

Например, если была записана только одна строка, через 100 секунд она будет сброшена, независимо от прочего. Но если было записано много строк, данные будут сброшены раньше.

Когда сервер останавливается, при `DROP TABLE` или `DETACH TABLE` буферизованные данные также сбрасываются в целевую таблицу.

Вы можете установить пустые строки в одинарных кавычках для имени базы данных и таблицы. Это обозначает отсутствие целевой таблицы. В этом случае, когда условия сброса данных достигаются, буфер просто очищается. Это может быть полезно для хранения окна данных в памяти.

При чтении из таблицы Буфер данные обрабатываются как из буфера, так и из целевой таблицы (если она существует). Обратите внимание, что таблица Буфер не поддерживает индекс. Другими словами, данные в буфере полностью сканируются, что может быть медленным для больших буферов. (Для данных во вспомогательной таблице будет использован индекс, который она поддерживает.)

Если набор колонок в таблице Буфер не совпадает с набором колонок во вспомогательной таблице, вставляется подмножество колонок, которые существуют в обеих таблицах.

Если типы не совпадают для одной из колонок в таблице Буфер и во вспомогательной таблице, в журнал сервера записывается сообщение об ошибке, и буфер очищается. То же самое происходит, если вспомогательная таблица не существует при сбросе буфера.

:::note
Выполнение ALTER на таблице Буфер в выпусках, сделанных до 26 октября 2021 года, вызовет ошибку `Block structure mismatch` (см. [#15117](https://github.com/ClickHouse/ClickHouse/issues/15117) и [#30565](https://github.com/ClickHouse/ClickHouse/pull/30565)), поэтому единственным вариантом является удаление таблицы Буфер, а затем ее повторное создание. Убедитесь, что эта ошибка исправлена в вашем выпуске, прежде чем пытаться выполнить ALTER на таблице Буфер.
:::

Если сервер перезапускается ненормально, данные в буфере теряются.

`FINAL` и `SAMPLE` не работают корректно для таблиц Буфер. Эти условия передаются в целевую таблицу, но не используются для обработки данных в буфере. Если эти функции требуются, мы рекомендуем использовать таблицу Буфер только для записи, в то время как чтение следует делать из целевой таблицы.

При добавлении данных в таблицу Буфер один из буферов блокируется. Это вызывает задержки, если одновременно выполняется операция чтения из таблицы.

Данные, которые вставляются в таблицу Буфер, могут оказаться во вспомогательной таблице в другом порядке и в разных блоках. Из-за этого таблица Буфер сложно использовать для корректной записи в CollapsingMergeTree. Чтобы избежать проблем, вы можете установить `num_layers` в 1.

Если целевая таблица реплицируется, некоторые ожидаемые характеристики реплицированных таблиц теряются при записи в таблицу Буфер. Случайные изменения порядка строк и размеры частей данных приводят к тому, что дедупликация данных перестает работать, что означает, что невозможно осуществить надежную запись 'exactly once' в реплицированные таблицы.

Из-за этих недостатков мы можем рекомендовать использовать таблицу Буфер только в редких случаях.

Таблица Буфер используется, когда слишком много INSERTs поступает от большого количества серверов за единицу времени, и данные не могут быть буферизованы перед вставкой, что означает, что INSERTs не могут выполняться достаточно быстро.

Обратите внимание, что нет смысла вставлять данные по одной строке, даже для таблиц Буфер. Это даст скорость всего несколько тысяч строк в секунду, в то время как вставка больших блоков данных может обеспечить более миллиона строк в секунду.
