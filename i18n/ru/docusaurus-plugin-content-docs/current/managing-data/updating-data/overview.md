---
slug: /updating-data/overview
title: 'Обзор'
description: 'Как обновить данные в ClickHouse'
keywords: ['обновление', 'обновление данных']
---

## Различия между обновлением данных в ClickHouse и OLTP базах данных {#differences-between-updating-data-in-clickhouse-and-oltp-databases}

Когда дело доходит до обработки обновлений, ClickHouse и OLTP базы данных значительно расходятся из-за своих основных проектных философий и целевых случаев использования. Например, PostgreSQL, реляционная база данных с ориентацией на строки и соответствующая ACID, поддерживает надежные и транзакционные операции обновления и удаления, обеспечивая согласованность и целостность данных через механизмы, такие как управление многоверсионной конкурентностью (MVCC). Это позволяет безопасно и надежно модифицировать данные даже в условиях высокой конкуренции.

С другой стороны, ClickHouse представляет собой столбцовую базу данных, оптимизированную для аналитики с высокой нагрузкой на чтение и операций только добавления с высокой пропускной способностью. Хотя он действительно поддерживает обновления и удаления на месте, их необходимо использовать с осторожностью, чтобы избежать высокого ввода-вывода. Альтернативно, таблицы могут быть перестроены, чтобы преобразовать удаление и обновление в добавленные операции, которые обрабатываются асинхронно и/или во время чтения, тем самым отражая акцент на высокой пропускной способности приема данных и эффективном выполнении запросов выше манипуляции с данными в реальном времени.

## Методы обновления данных в ClickHouse {#methods-to-update-data-in-clickhouse}

Существует несколько способов обновления данных в ClickHouse, каждый из которых имеет свои преимущества и характеристики производительности. Вы должны выбрать соответствующий метод в зависимости от вашей модели данных и объема данных, которые вы намерены обновить.

Для обеих операций, если количество поданных мутаций постоянно превышает количество мутаций, которые обрабатываются в фоновом режиме в течение некоторого временного интервала, очередь нематериализованных мутаций, которые необходимо применить, будет продолжать расти. Это приведет к ухудшению производительности `SELECT` запросов.

В общем, операции обновления должны выдаваться с осторожностью, а очередь мутаций должна тщательно контролироваться с использованием таблицы `system.mutations`. Не выдавайте обновления часто, как вы это делали бы в OLTP базах данных. Если у вас есть необходимость в частых обновлениях, смотрите [ReplacingMergeTree](/engines/table-engines/mergetree-family/replacingmergetree).

| Метод                                                                                 | Синтаксис                           | Когда использовать                                                                                                                                                                                                                              |
|---------------------------------------------------------------------------------------|-------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [Обновляющая мутация](/sql-reference/statements/alter/update)                       | `ALTER TABLE [table] UPDATE`       | Используйте, когда данные должны быть немедленно обновлены на диске (например, для соблюдения требований). Негативно влияет на производительность `SELECT`.                                                                                   |
| [Легковесное обновление](/guides/developer/lightweight-update)                      | `ALTER TABLE [table] UPDATE`       | Включите с помощью `SET apply_mutations_on_fly = 1;`. Используйте, когда обновляете небольшие объемы данных. Строки немедленно возвращаются с обновленными данными во всех последующих `SELECT` запросах, но изначально помечены только как обновленные на диске. |
| [ReplacingMergeTree](/engines/table-engines/mergetree-family/replacingmergetree)    | `ENGINE = ReplacingMergeTree`      | Используйте, когда обновляете большие объемы данных. Этот движок таблиц оптимизирован для дедупликации данных при слиянии.                                                                                                                 |
| [CollapsingMergeTree](/engines/table-engines/mergetree-family/collapsingmergetree)  | `ENGINE = CollapsingMergeTree(Sign)` | Используйте, когда часто обновляете отдельные строки или в сценариях, когда необходимо поддерживать последнее состояние объектов, которые изменяются с течением времени. Например, отслеживание активности пользователя или статистики статей.                                       |

Вот резюме различных способов обновления данных в ClickHouse:

## Обновляющие Мутации {#update-mutations}

Обновляющие мутации могут быть выданы через команду `ALTER TABLE ... UPDATE`, например:

```sql
ALTER TABLE posts_temp
        (UPDATE AnswerCount = AnswerCount + 1 WHERE AnswerCount = 0)
```
Эти операции потребляют много ввода-вывода, переписывая все части, которые соответствуют выражению `WHERE`. У этого процесса нет атомарности — части заменяются мутационными частями, как только они готовы, а запрос `SELECT`, который начинает выполняться во время мутации, увидит данные из частей, которые уже были изменены, наряду с данными из частей, которые еще не были изменены. Пользователи могут отслеживать состояние прогресса через таблицу [systems.mutations](/operations/system-tables/mutations). Это операции с интенсивным использованием I/O и должны использоваться экономно, так как они могут повлиять на производительность кластерного `SELECT`.

Читать далее о [обновляющих мутациях](/sql-reference/statements/alter/update).

## Легковесные Обновления {#lightweight-updates}

Легковесные обновления предоставляют механизм для обновления строк так, чтобы они обновлялись немедленно, а последующие запросы `SELECT` автоматически возвращали измененные значения (это влечет за собой накладные расходы и замедляет запросы). Это эффективно решает проблему ограничения атомарности обычных мутаций. Мы показываем пример ниже:

```sql
SET apply_mutations_on_fly = 1;

SELECT ViewCount
FROM posts
WHERE Id = 404346

┌─ViewCount─┐
│       26762   │
└───────────┘

1 row in set. Elapsed: 0.115 sec. Processed 59.55 million rows, 238.25 MB (517.83 million rows/s., 2.07 GB/s.)
Peak memory usage: 113.65 MiB.

-инкрементировать счётчик
ALTER TABLE posts
        (UPDATE ViewCount = ViewCount + 1 WHERE Id = 404346)

SELECT ViewCount
FROM posts
WHERE Id = 404346

┌─ViewCount─┐
│       26763   │
└───────────┘

1 row in set. Elapsed: 0.149 sec. Processed 59.55 million rows, 259.91 MB (399.99 million rows/s., 1.75 GB/s.)
```

Обратите внимание, что для легковесных обновлений мутация все еще используется для обновления данных; она просто не материализуется немедленно и применяется во время запросов `SELECT`. Она все равно будет применена в фоновом режиме как асинхронный процесс и имеет такие же большие накладные расходы, как и мутация, и, следовательно, является операцией с интенсивным использованием I/O, которую следует использовать экономно. Выражения, которые могут быть использованы с этой операцией, также ограничены (см. здесь для [подробностей](/guides/developer/lightweight-update#support-for-subqueries-and-non-deterministic-functions)).

Читать далее о [легковесных обновлениях](/guides/developer/lightweight-update).

## Collapsing Merge Tree {#collapsing-merge-tree}

Исходя из идеи, что обновления дороги, но вставки могут быть использованы для выполнения обновлений,
движок таблиц [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree)
может использоваться вместе со столбцом `sign` как способом сообщить ClickHouse обновить конкретную строку, объединяя (удаляя)
пару строк со знаком `1` и `-1`.
Если `-1` вставлен в столбец `sign`, вся строка будет удалена.
Если `1` вставлен в столбец `sign`, ClickHouse сохранит строку.
Строки для обновления идентифицируются на основе ключа сортировки, используемого в операторе `ORDER BY ()` при создании таблицы.

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8 -- Специальный столбец, используемый с движком таблиц CollapsingMergeTree
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID

INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, -1) -- sign = -1 сигнализирует о том, чтобы обновить состояние этой строки
INSERT INTO UAct VALUES (4324182021466249494, 6, 185, 1) -- строка заменяется на новое состояние

SELECT
    UserID,
    sum(PageViews * Sign) AS PageViews,
    sum(Duration * Sign) AS Duration
FROM UAct
GROUP BY UserID
HAVING sum(Sign) > 0

┌──────────────UserID─┬─PageViews─┬─Duration─┐
│ 4324182021466249494 │         6 │      185 │
└─────────────────────┴───────────┴──────────┘
```

:::note
Вышеуказанный подход к обновлению требует, чтобы пользователи поддерживали состояние на стороне клиента.
Хотя это наиболее эффективно с точки зрения ClickHouse, это может быть сложно в больших масштабах.

Рекомендуем ознакомиться с документацией
по [`CollapsingMergeTree`](/engines/table-engines/mergetree-family/collapsingmergetree)
для более полного представления.
:::

## Дополнительные ресурсы {#more-resources}

- [Обработка обновлений и удалений в ClickHouse](https://clickhouse.com/blog/handling-updates-and-deletes-in-clickhouse)
