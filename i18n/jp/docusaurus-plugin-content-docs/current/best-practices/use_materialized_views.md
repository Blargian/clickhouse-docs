---
slug: /best-practices/use-materialized-views
sidebar_position: 10
sidebar_label: 'マテリアライズドビューの使用'
title: 'マテリアライズドビューの使用'
description: 'マテリアライズドビューに関するページ'
---

import Image from '@theme/IdealImage';
import incremental_materialized_view from '@site/static/images/bestpractices/incremental_materialized_view.gif';
import refreshable_materialized_view from '@site/static/images/bestpractices/refreshable_materialized_view.gif';


ClickHouse は、[**インクリメンタル**](/materialized-view/incremental-materialized-view) と [**リフレッシュ可能**](/materialized-view/refreshable-materialized-view) の 2 種類のマテリアライズドビューをサポートしています。両者は、結果を事前に計算して保存することでクエリを加速するように設計されていますが、基盤となるクエリを実行するタイミングや方法、適しているワークロード、データの新鮮さの扱い方において大きな違いがあります。

**ユーザーは、前提として以前のベストプラクティス [に関するタイプ](/best-practices/select-data-types) と [主キーの最適化](/best-practices/choosing-a-primary-key) が行われていることを考慮し、特定のクエリパターンの加速にマテリアライズドビューを検討すべきです。**

**インクリメンタルマテリアライズドビュー** はリアルタイムで更新されます。新しいデータがソーステーブルに挿入されると、ClickHouse はマテリアライズドビューのクエリを新しいデータブロックに自動的に適用し、結果を別のターゲットテーブルに書き込みます。時間が経つにつれて、ClickHouse はこれらの部分的な結果をマージして完全で最新のビューを生成します。このアプローチは非常に効率的で、計算コストを挿入時にシフトさせ、新しいデータのみを処理します。その結果、ターゲットテーブルに対して `SELECT` クエリは高速で軽量になります。インクリメンタルビューはすべての集約関数をサポートし、ペタバイトのデータに対してもスケールが良好です。なぜなら、各クエリは挿入されるデータセットの小さく最近のサブセットのみを操作するからです。

<Image img={incremental_materialized_view} size="lg" alt="マテリアライズドビュー" />

**リフレッシュ可能なマテリアライズドビュー** は対照的に、スケジュールに従って更新されます。これらのビューは定期的に完全なクエリを再実行し、ターゲットテーブルに結果を上書きします。これは、Postgres のような従来の OLTP データベースのマテリアライズドビューに類似しています。

<Image img={refreshable_materialized_view} size="lg" alt="リフレッシュ可能なマテリアライズドビューの図" />

インクリメンタルとリフレッシュ可能なマテリアライズドビューの選択は、クエリの性質、データの変更頻度、ビューの更新が挿入されるたびにすべての行を反映する必要があるか、または定期的なリフレッシュが許容されるかどうかに大きく依存します。これらのトレードオフを理解することは、ClickHouse でパフォーマンスが高く、スケーラブルなマテリアライズドビューを設計するための鍵です。

## インクリメンタルマテリアライズドビューを使用するタイミング {#when-to-use-incremental-materialized-views}

インクリメンタルマテリアライズドビューは、一般に優先されます。なぜなら、ソーステーブルに新しいデータが挿入されるたびにリアルタイムで自動的に更新されるからです。これらはすべての集約関数をサポートし、単一のテーブルに対する集約に特に効果的です。挿入時に結果をインクリメンタルに計算することにより、クエリはかなり小さなデータサブセットに対して実行されるため、これらのビューはペタバイトのデータに対しても容易にスケールします。ほとんどの場合、全体のクラスターの性能に対する影響はほとんどありません。

インクリメンタルマテリアライズドビューを使用する場合：

- 各挿入ごとに更新されたリアルタイムのクエリ結果が必要です。
- 大量のデータを頻繁に集約またはフィルタリングしています。
- クエリが単一のテーブルに対する単純な変換や集約を含みます。

インクリメンタルマテリアライズドビューの例については、[こちら](/materialized-view/incremental-materialized-view)をご覧ください。

## リフレッシュ可能なマテリアライズドビューを使用するタイミング {#when-to-use-refreshable-materialized-views}

リフレッシュ可能なマテリアライズドビューは、インクリメンタルではなく定期的にクエリを実行し、クエリ結果セットを迅速に取得できるように保存します。

これらは、クエリのパフォーマンスが重要な場合（例：サブミリ秒のレイテンシ）で、やや古い結果が許容される場合に最も有用です。クエリは完全に再実行されるため、リフレッシュ可能なビューは、計算が比較的速く行えるクエリ、または頻繁でない間隔（例：毎時）で計算できるクエリ（例：“トップ N” 結果やルックアップテーブルのキャッシュなど）に最適です。

実行頻度は、システムに過度の負荷をかけないように慎重に調整する必要があります。リソースを大幅に消費する非常に複雑なクエリは、慎重にスケジュールする必要があります。これらはキャッシュに影響を与え、CPU とメモリを消費することで、全体のクラスターのパフォーマンスを低下させる可能性があります。クエリはリフレッシュ間隔に比べて相対的に迅速に実行される必要があり、クラスターに過負荷をかけないようにする必要があります。たとえば、クエリ自体が計算に少なくとも 10 秒かかる場合、10 秒ごとにビューを更新するようにスケジュールしないでください。

## まとめ {#summary}

まとめると、リフレッシュ可能なマテリアライズドビューを使用するのは次の場合です：

- キャッシュされたクエリ結果をすぐに利用でき、わずかな新鮮さの遅延が許容される場合。
- クエリ結果セットのトップ N が必要です。
- 結果セットのサイズが時間とともに無限に増えない場合。これにより、ターゲットビューのパフォーマンスが低下します。
- 複数のテーブルに関与する複雑なジョインまたは非正規化を行い、ソーステーブルのいずれかが変更されるたびに更新が必要です。
- バッチワークフロー、非正規化タスク、または DBT DAGs に似たビュー依存関係を構築しています。

リフレッシュ可能なマテリアライズドビューの例については、[こちら](/materialized-view/refreshable-materialized-view)をご覧ください。

### APPEND モードと REPLACE モード {#append-vs-replace-mode}

リフレッシュ可能なマテリアライズドビューは、ターゲットテーブルにデータを書き込むための 2 種類のモード、`APPEND` と `REPLACE` をサポートしています。これらのモードは、ビューがリフレッシュされたときにクエリの結果がどのように書き込まれるかを定義します。

`REPLACE` はデフォルトの動作です。ビューがリフレッシュされるたびに、ターゲットテーブルの既存の内容は最新のクエリ結果で完全に上書きされます。これは、ビューが常に最新の状態を反映する必要があるユースケース（例：結果セットのキャッシュ）に適しています。

対照的に `APPEND` は、ターゲットテーブルの内容を置き換えるのではなく、新しい行を追加できます。これは、定期的なスナップショットをキャプチャするなどの追加のユースケースを可能にします。`APPEND` は、各リフレッシュが特定の時点を表すときや、結果の履歴的蓄積が求められる場合に特に役立ちます。

`APPEND` モードを選択する場合：

- 過去のリフレッシュの履歴を保持したい。
- 定期的なスナップショットやレポートを作成している。
- 時間とともにリフレッシュされた結果をインクリメンタルに収集する必要があります。

`REPLACE` モードを選択する場合：

- 最新の結果のみが必要です。
- 古いデータは完全に除去されるべきです。
- ビューは現在の状態やルックアップを表します。

ユーザーは、`APPEND` 機能を使用する例として、[メダリオンアーキテクチャ](https://clickhouse.com/blog/building-a-medallion-architecture-for-bluesky-json-data-with-clickhouse)を構築する場合があります。
