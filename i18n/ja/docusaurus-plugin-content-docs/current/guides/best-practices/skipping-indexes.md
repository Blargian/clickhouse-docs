---
slug: /optimize/skipping-indexes
sidebar_label: データスキッピングインデックス
sidebar_position: 2
description: スキップインデックスにより、ClickHouseは一致する値が存在しないことが保証されたデータの重要なチャンクを読み取るのをスキップできます。
---

# ClickHouseのデータスキッピングインデックスの理解

## はじめに {#introduction}

多くの要因がClickHouseのクエリパフォーマンスに影響を与えます。ほとんどのシナリオで重要な要素は、ClickHouseがクエリのWHERE句条件を評価する際に主キーを使用できるかどうかです。したがって、最も一般的なクエリパターンに適用される主キーを選択することは、効果的なテーブル設計にとって重要です。

それでも、主キーがどんなに注意深く調整されていても、それを効率的に利用できないクエリのユースケースは必ず存在します。ユーザーは通常、ClickHouseを時間系列型データのために使用しますが、同じデータを顧客ID、ウェブサイトURL、または製品番号など、他のビジネスディメンションに従って分析したいと考えます。その場合、WHERE句条件を適用するために各カラム値の全スキャンが必要となるため、クエリパフォーマンスはかなり悪化する可能性があります。このような状況でも、ClickHouseは比較的高速ですが、数百万または数十億の個々の値を評価することは、主キーに基づくクエリに比べて「非インデックス」クエリをはるかに遅く実行させます。

従来のリレーショナルデータベースでは、この問題へのアプローチの一つは、テーブルに一つ以上の「セカンダリ」インデックスを付加することです。これはb-tree構造で、データベースがO(log(n))の時間でディスク上のすべての一致する行を見つけることを可能にします（ここでnは行数）。しかし、この種のセカンダリインデックスはClickHouse（あるいは他の列指向データベース）では機能しません。なぜなら、インデックスを追加できる個々の行がディスク上に存在しないからです。

代わりに、ClickHouseは異なるタイプのインデックスを提供します。このインデックスは特定の状況下でクエリ速度を大幅に改善することができます。これらの構造は、「スキップ」インデックスと呼ばれ、ClickHouseが一致しない値が保証されている重要なデータのチャンクを読み取ることをスキップすることを可能にします。

## 基本操作 {#basic-operation}

ユーザーはMergeTreeファミリーのテーブルにのみデータスキッピングインデックスを使用できます。各データスキッピングインデックスには4つの主要な引数があります：

- インデックス名。インデックス名は、各パーティション内にインデックスファイルを作成するために使用されます。また、インデックスを削除またはマテリアライズする際のパラメーターとしても必要です。
- インデックス式。インデックス式は、インデックスに保存される値の集合を計算するために使用されます。カラムの組み合わせ、単純な演算子、およびインデックスタイプによって決定される関数のサブセットが含まれる場合があります。
- タイプ。インデックスタイプは、各インデックスブロックの読み取りと評価をスキップできるかどうかを判断する計算を制御します。
- グラニュラリティ。各インデックスブロックは、グラニュラリティのグラニュールで構成されています。たとえば、主テーブルインデックスのグラニュラリティが8192行であり、インデックスのグラニュラリティが4の場合、各インデックス「ブロック」は32768行になります。

ユーザーがデータスキッピングインデックスを作成すると、テーブルの各データパートディレクトリに2つの追加ファイルが作成されます。

- `skp_idx_{index_name}.idx`、これは順序付けられた式値を含みます
- `skp_idx_{index_name}.mrk2`、これは関連するデータカラムファイルへの対応するオフセットを含みます。

クエリを実行し、関連するカラムファイルを読み取る際にWHERE句のフィルタリング条件の一部がスキップインデックス式に一致する場合、ClickHouseはインデックスファイルのデータを使用して、各関連データブロックを処理する必要があるか、スキップできるかを判断します（ブロックが主キーを適用することで既に除外されていないと仮定）。非常に簡易化した例では、次のような予測可能なデータで読み込まれたテーブルを考えてみましょう。

```sql
CREATE TABLE skip_table
(
  my_key UInt64,
  my_value UInt64
)
ENGINE MergeTree primary key my_key
SETTINGS index_granularity=8192;

INSERT INTO skip_table SELECT number, intDiv(number,4096) FROM numbers(100000000);
```

主キーを使用しない簡単なクエリを実行すると、`my_value`カラムの全1億エントリがスキャンされます：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192行がセットに含まれています。経過時間: 0.079 秒。処理された行数: 1億行、サイズ: 800.10 MB (1.26億行/s., 10.10 GB/s.)
```

次に、非常に基本的なスキップインデックスを追加します：

```sql
ALTER TABLE skip_table ADD INDEX vix my_value TYPE set(100) GRANULARITY 2;
```

通常、スキップインデックスは新しく挿入されたデータにのみ適用されるため、インデックスを追加するだけでは上記のクエリには影響しません。

既存のデータにインデックスを作成するには、このステートメントを使用します：

```sql
ALTER TABLE skip_table MATERIALIZE INDEX vix;
```

新しく作成されたインデックスでクエリを再実行します：

```sql
SELECT * FROM skip_table WHERE my_value IN (125, 700)

┌─my_key─┬─my_value─┐
│ 512000 │      125 │
│ 512001 │      125 │
│    ... |      ... |
└────────┴──────────┘

8192行がセットに含まれています。経過時間: 0.051 秒。処理された行数: 32.77千行、サイズ: 360.45 KB (643.75千行/s., 7.08 MB/s.)
```

ClickHouseは100百万行の800メガバイトを処理するのではなく、32768行の360キロバイトのみを読み取って分析しました -- それぞれ8192行の4つのグラニュールです。

より視覚的に言えば、`my_value`が125である4096行がどのように読み取られ、選択され、次の行がどのようにディスクから読み取られることなくスキップされたかを示します：

![Simple Skip](images/simple_skip.svg)

ユーザーはクエリを実行する際にトレースを有効にすることで、スキップインデックスの使用に関する詳細な情報にアクセスできます。clickhouse-clientから、`send_logs_level`を設定します：

```sql
SET send_logs_level='trace';
```
これにより、クエリSQLやテーブルインデックスを調整する際に役立つデバッグ情報が提供されます。上記の例から、デバッグログはスキップインデックスが6102/6104のグラニュールを除去したことを示しています：

```sql
<Debug> default.skip_table (933d4b2c-8cea-4bf9-8c93-c56e900eefd1) (SelectExecutor): Index `vix` has dropped 6102/6104 granules.
```
## スキップインデックスタイプ {#skip-index-types}

### minmax {#minmax}

この軽量インデックスタイプにはパラメーターは必要ありません。インデックス式の各ブロックの最小値と最大値を保存します（式がタプルの場合、タプルの各メンバーの値を個別に保存します）。このタイプは、値によってあまりソートされないカラムに最適です。このインデックスタイプは、クエリ処理中に適用するコストが最も少ない場合が一般的です。

このインデックスタイプはスカラーまたはタプル式でのみ正しく機能します -- 配列やマップデータ型を返す式には決して適用されません。

### set {#set}

この軽量インデックスタイプは、各ブロックの値セットのmax_sizeの単一パラメーターを受け入れます（0は無限の離散値を許可します）。このセットには、ブロック内のすべての値が含まれます（値の数がmax_sizeを超えた場合は空になります）。このインデックスタイプは、各グラニュールの中で低いカーディナリティを持つカラム（本質的に「塊になっている」）と、全体として高いカーディナリティを持つカラムとよく機能します。

このインデックスのコスト、パフォーマンス、および効果は、ブロック内のカーディナリティに依存します。各ブロックに多くのユニークな値が含まれている場合、クエリ条件を大きなインデックスセットに対して評価することが非常に高価になるか、もしくはmax_sizeを超えているためにインデックスが空となり、適用されない可能性があります。

### ブルームフィルタタイプ {#bloom-filter-types}

*ブルームフィルタ*は、わずかな偽陽性の可能性をコストに、セットメンバーシップの検査を空間的に効率的に行えるデータ構造です。スキップインデックスの場合、偽陽性は重大な懸念ではないため、いくつかの不必要なブロックを読み取るだけの不利益があります。しかし、偽陽性の可能性があるため、インデックス式は真であることが期待されるべきであり、そうでなければ有効なデータがスキップされる可能性があります。

ブルームフィルタは、多数の離散値の検査をより効率的に処理できるため、テストする値が多い条件式に適用することができます。特に、ブルームフィルタインデックスは配列に適用でき、配列のすべての値がテストされ、マップにはmapKeysまたはmapValues関数を使用してキーまたは値のいずれかを配列に変換することで適用できます。

ブルームフィルタに基づくデータスキッピングインデックスには、3つのタイプがあります：

* 基本的な**bloom_filter**。これは、許可された「偽陽性」率の単一のオプションパラメーターを取ります（指定がない場合は0.025が使用されます）。

* 専門的な**tokenbf_v1**。これは、ブルームフィルタの調整に関連する3つのパラメーターを取ります：(1) フィルタのサイズ（バイト単位）（大きなフィルタは偽陽性が少なくなりますが、ストレージのコストがかかります）、(2) 適用されるハッシュ関数の数（再び、より多くのハッシュフィルタが偽陽性を減少させます）、(3) ブルームフィルタハッシュ関数のシード。これらのパラメーターがブルームフィルタ機能にどのように影響するかの詳細については、[こちらの計算機](https://hur.st/bloomfilter/)を参照してください。このインデックスは、文字列、固定文字列、およびマップデータ型でのみ機能します。入力式は、非英数字で区切られた文字列の配列に分割されます。たとえば、`This is a candidate for a "full text" search`というカラム値は、トークン`This` `is` `a` `candidate` `for` `full` `text` `search`を持ちます。これは、LIKE、EQUALS、IN、hasToken()などの検索で単語や他の値を長い文字列の中で検索するために使用されることを意図しています。たとえば、小さなクラス名や行番号を自由形式のアプリケーションログ行のカラムで検索するための使用例があります。

* 専門的な**ngrambf_v1**。このインデックスはトークンインデックスと同様に機能します。ブルームフィルタ設定の前に、インデックスするngramのサイズという1つの追加パラメーターを取ります。ngramは、任意の文字の長さ`n`の文字列です。したがって、`A short string`という文字列がngramサイズ4でインデックス化されると、次のようになります：
  ```text
  'A sh', ' sho', 'shor', 'hort', 'ort ', 'rt s', 't st', ' str', 'stri', 'trin', 'ring'
  ```
このインデックスも、特に単語の区切りがない言語（たとえば、中国語）のテキスト検索に役立ちます。

## スキップインデックス関数 {#skip-index-functions}

データスキッピングインデックスの主な目的は、人気のあるクエリによって分析されるデータの量を制限することです。ClickHouseデータの分析的な性質を考えると、それらのクエリのパターンはほとんどの場合、関数式を含みます。したがって、スキップインデックスは、効率的になるために一般的な関数と正しく相互作用しなければなりません。これは、以下のいずれかの状況で発生する可能性があります：
* データが挿入され、インデックスが関数式として定義されている場合（式の結果はインデックスファイルに保存されます）、または
* クエリが処理され、式が保存されたインデックス値に適用されてブロックを除外するかどうかを判断する場合。

各タイプのスキップインデックスは、インデックス実装に適したClickHouseの関数のサブセットで機能します。一般に、セットインデックスとブルームフィルタに基づくインデックス（別のタイプのセットインデックス）はどちらも順序がないため、範囲には機能しません。対照的に、minmaxインデックスは範囲と特によく機能します。範囲が交差しているかどうかを決定するのは非常に迅速だからです。部分一致関数LIKE、startsWith、endsWith、hasTokenの効果は、使用されるインデックスタイプ、インデックス式、およびデータの特定の形状に依存します。

## スキップインデックス設定 {#skip-index-settings}

スキップインデックスに適用される2つの設定があります。

* **use_skip_indexes**（0または1、デフォルトは1）。すべてのクエリがスキップインデックスを効率的に使用できるわけではありません。特定のフィルタリング条件がほとんどのグラニュールを含む可能性が高い場合、データスキッピングインデックスを適用することは不必要で、時には大きなコストがかかります。スキップインデックスの利益が得られそうにないクエリのために、値を0に設定します。
* **force_data_skipping_indices**（カンマ区切りのインデックス名のリスト）。この設定は、一部の種類の非効率なクエリを防ぐために使用できます。テーブルのクエリがスキップインデックスを使用しなければ高価すぎる状況では、この設定を1つ以上のインデックス名と共に使用することで、リストに載っていないインデックスを使用しないクエリに対して例外を返すことができます。これにより、ひどく書かれたクエリがサーバーリソースを消費するのを防ぐことができます。

## スキップのベストプラクティス {#skip-best-practices}

スキップインデックスは直感的ではなく、特にRDMS領域のセカンダリ行ベースのインデックスやドキュメントストアの逆インデックスに慣れているユーザーには難しいです。任意の利益を得るには、ClickHouseのデータスキッピングインデックスの適用は、インデックスを計算するコストを相殺するために十分なグラニュールの読み取りを避ける必要があります。特に、インデックス化されたブロック内に値が1回でも現れると、そのブロック全体をメモリに読み込んで評価する必要があるため、インデックスコストが不必要に発生します。

次のデータ分布を考えてみましょう：

![Bad Skip!](images/bad_skip_1.svg)

主キー/順序キーが`timestamp`で、`visitor_id`にインデックスがあると仮定します。次のクエリを考えます：

```sql
SELECT timestamp, url FROM table WHERE visitor_id = 1001`
```

従来のセカンダリインデックスは、この種のデータ分布に非常に有利です。要求されたvisitor_idを持つ5行を見つけるために32768行すべてを読み取る代わりに、セカンダリインデックスは単に5つの行の位置を含み、これらの5行のみがディスクから読み取られます。クリックハウスのデータスキッピングインデックスでは、その正反対が真です。スキップインデックスのタイプに関係なく、`visitor_id`カラムのすべての32768値がテストされます。

したがって、ClickHouseのクエリを加速させるために、単純にキー列にインデックスを追加しようとする自然な衝動は、しばしば誤りです。この高度な機能は、主キーを変更する（[スパース主インデックスの選択方法](../best-practices/sparse-primary-indexes.md)を参照）、プロジェクションを使用する、またはマテリアライズドビューを使用するなど、他の代替手段を調査した後にのみ使用するべきです。データスキッピングインデックスが適切な場合であっても、インデックスとテーブルの両方を注意深く調整する必要があることが多いです。

多くのケースで、便利なスキップインデックスは、主キーとターゲットにした非主キーのカラム/式との間に強い相関が必要です。相関がない場合（上記の図のように）、ブロック内の何千もの値のいずれかの行がフィルタリング条件を満たす可能性が高く、スキップされるブロックはほとんどありません。対照的に、主キーの値の範囲（たとえば、一日の時間）が潜在的なインデックスカラムの値（たとえば、テレビ視聴者の年齢）と強く関連している場合、minmaxタイプのインデックスが有益である可能性が高くなります。データを挿入する際に、追加のカラムをソート/ORDER BYキーに含めるか、主キーに関連する値が挿入時にグループ化されるようにバッチ処理を行うことで、この相関を強化することは可能です。たとえば、特定のsite_idのすべてのイベントが、一時スタンプが多くのサイトからのイベントを含んでいる場合でも、インジェストプロセスによって一緒にグループ化され挿入されることがあります。これにより、特定のsite_id値を検索するときにスキップされる可能性が高い少数のsite_idのみを含む多くのグラニュールが生成されます。

スキップインデックスのもう一つの良い候補は、データ内で相対的にスパースである任意の値に対する高いカーディナリティ式です。1つの例は、APIリクエスト内のエラーコードを追跡する可観察性プラットフォームかもしれません。特定のエラーコードは、データ内では希少ですが、検索にとって特に重要な場合があります。エラーコードカラムに対するセットスキップインデックスを使用すれば、エラーを含まないブロックの大部分を回避できるため、エラーに特化したクエリを大幅に改善できます。

最後に、最も重要なベストプラクティスは、テストすることです。再度、b-treeセカンダリインデックスやドキュメント検索用の逆インデックスとは異なり、データスキッピングインデックスの動作は予測が容易ではありません。それらをテーブルに追加すると、データの取り込みと、インデックスから恩恵を受けない理由が何であれ、クエリに対して意味のあるコストがかかります。実際のデータのタイプに対して常にテストする必要があり、テストにはタイプやグラニュラリティサイズおよび他のパラメーターのバリエーションを含めるべきです。テストは、思考実験だけでは明らかでないパターンや落とし穴を明らかにすることがよくあります。
