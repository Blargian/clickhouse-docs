---

description: 'Документация для CREATE VIEW'
sidebar_label: 'VIEW'
sidebar_position: 37
slug: /sql-reference/statements/create/view
title: 'CREATE VIEW'

---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import DeprecatedBadge from '@theme/badges/DeprecatedBadge';
import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';


# CREATE VIEW

Создаёт новое представление. Представления могут быть [обычными](#normal-view), [материализованными](#materialized-view), [обновляемыми материализованными](#refreshable-materialized-view) и [оконными](/sql-reference/statements/create/view#window-view) (обновляемое материализованное представление и оконное представление являются экспериментальными функциями).

## Обычное представление {#normal-view}

Синтаксис:

```sql
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [(alias1 [, alias2 ...])] [ON CLUSTER cluster_name]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

Обычные представления не хранят никаких данных. Они просто выполняют чтение из другой таблицы при каждом доступе. Иными словами, обычное представление — это не что иное, как сохранённый запрос. При чтении из представления этот сохранённый запрос используется как подзапрос в предложении [FROM](../../../sql-reference/statements/select/from.md).

Например, предположим, что вы создали представление:

```sql
CREATE VIEW view AS SELECT ...
```

и написали запрос:

```sql
SELECT a, b, c FROM view
```

Этот запрос полностью эквивалентен использованию подзапроса:

```sql
SELECT a, b, c FROM (SELECT ...)
```

## Параметризованное представление {#parameterized-view}

Параметризованные представления похожи на обычные представления, но могут быть созданы с параметрами, которые не разрешаются немедленно. Эти представления могут быть использованы с табличными функциями, которые указывают имя представления как имя функции и значения параметров как её аргументы.

```sql
CREATE VIEW view AS SELECT * FROM TABLE WHERE Column1={column1:datatype1} and Column2={column2:datatype2} ...
```
Выше создаётся представление для таблицы, которое может быть использовано как табличная функция, подставив параметры, как показано ниже.

```sql
SELECT * FROM view(column1=value1, column2=value2 ...)
```

## Материализованное представление {#materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster_name] [TO[db.]name [(columns)]] [ENGINE = engine] [POPULATE]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

:::tip
Здесь содержится пошаговое руководство по использованию [материализованных представлений](/guides/developer/cascading-materialized-views.md).
:::

Материализованные представления хранят данные, преобразованные соответствующим запросом [SELECT](../../../sql-reference/statements/select/index.md).

При создании материализованного представления без указания `TO [db].[table]`, необходимо указать `ENGINE` — движок таблицы для хранения данных.

При создании материализованного представления с использованием `TO [db].[table]`, нельзя использовать `POPULATE`.

Материализованное представление реализовано следующим образом: при вставке данных в таблицу, указанную в `SELECT`, часть вставленных данных преобразуется этим запросом `SELECT`, и результат вставляется в представление.

:::note
Материализованные представления в ClickHouse используют **имена столбцов** вместо порядка столбцов во время вставки в целевую таблицу. Если некоторые имена столбцов отсутствуют в результате запроса `SELECT`, ClickHouse использует значение по умолчанию, даже если столбец не является [Nullable](../../data-types/nullable.md). Безопасной практикой будет добавление алиасов для каждого столбца при использовании материализованных представлений.

Материализованные представления в ClickHouse реализованы больше как триггеры вставки. Если в запросе представления есть агрегация, она применяется только к партии свежевставленных данных. Любые изменения существующих данных исходной таблицы (например, обновление, удаление, удаление раздела и т.д.) не влияют на материализованное представление.

Материализованные представления в ClickHouse не обладают детерминированным поведением в случае ошибок. Это означает, что блоки, которые уже были записаны, будут сохранены в целевой таблице, но все блоки после ошибки не будут записаны.

По умолчанию, если вставка в одно из представлений не удалась, запрос INSERT также не удастся, и некоторые блоки могут не быть записаны в целевую таблицу. Это можно изменить, используя настройку `materialized_views_ignore_errors` (её нужно установить для запроса `INSERT`), если установить `materialized_views_ignore_errors=true`, то любые ошибки при записи в представления будут игнорироваться и все блоки будут записаны в целевую таблицу.

Также обратите внимание, что `materialized_views_ignore_errors` установлено на `true` по умолчанию для таблиц `system.*_log`.
:::

Если вы указываете `POPULATE`, существующие данные таблицы вставляются в представление при его создании, как будто выполняется `CREATE TABLE ... AS SELECT ...`. В противном случае запрос содержит только данные, вставленные в таблицу после создания представления. Мы **не рекомендуем** использовать `POPULATE`, так как данные, вставленные в таблицу во время создания представления, не будут вставлены в него.

:::note
Учитывая, что `POPULATE` работает как `CREATE TABLE ... AS SELECT ...`, он имеет ограничения:
- Не поддерживается с реплицируемой базой данных
- Не поддерживается в ClickHouse cloud

Вместо этого можно использовать отдельный `INSERT ... SELECT`.
:::

Запрос `SELECT` может содержать `DISTINCT`, `GROUP BY`, `ORDER BY`, `LIMIT`. Обратите внимание, что соответствующие преобразования выполняются независимо для каждого блока вставленных данных. Например, если установлен `GROUP BY`, данные агрегируются при вставке, но только в пределах одного пакета вставленных данных. Данные не будут дополнительно агрегироваться. Исключение составляет использование движка `ENGINE`, который самостоятельно выполняет агрегацию данных, например `SummingMergeTree`.

Выполнение запросов [ALTER](/sql-reference/statements/alter/view.md) на материализованных представлениях имеет ограничения, например, нельзя обновить запрос `SELECT`, что может быть неудобно. Если материализованное представление использует конструкцию `TO [db.]name`, вы можете `DETACH` представить, выполнить `ALTER` для целевой таблицы и затем `ATTACH` ранее отсоединенное (`DETACH`) представление.

Обратите внимание, что на материализованное представление влияет настройка [optimize_on_insert](/operations/settings/settings#optimize_on_insert). Данные сливаются перед вставкой в представление.

Представления выглядят так же, как и обычные таблицы. Например, они перечислены в результате запроса `SHOW TABLES`.

Чтобы удалить представление, используйте [DROP VIEW](../../../sql-reference/statements/drop.md#drop-view). Однако `DROP TABLE` работает и для представлений.

## Безопасность SQL {#sql_security}

`DEFINER` и `SQL SECURITY` позволяют указать, какого пользователя ClickHouse использовать при выполнении базового запроса представления.
`SQL SECURITY` имеет три допустимых значения: `DEFINER`, `INVOKER` или `NONE`. Вы можете указать любого существующего пользователя или `CURRENT_USER` в предложении `DEFINER`.

Следующая таблица объяснит, какие права требуются от какого пользователя для того, чтобы выбрать данные из представления.
Обратите внимание, что независимо от опции безопасности SQL в каждом случае требуется наличие `GRANT SELECT ON <view>` для чтения из него.

| Опция безопасности SQL | Представление                                                 | Материализованное представление                                                                                      |
|------------------------|--------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| `DEFINER alice`        | `alice` должна иметь грант `SELECT` для исходной таблицы представления. | `alice` должна иметь грант `SELECT` для исходной таблицы представления и грант `INSERT` для целевой таблицы представления. |
| `INVOKER`              | Пользователь должен иметь грант `SELECT` для исходной таблицы представления. | `SQL SECURITY INVOKER` не может быть указан для материализованных представлений. |
| `NONE`                 | -                                                            | -                                                                                                                    |

:::note
`SQL SECURITY NONE` — это устаревшая опция. Любой пользователь с правами на создание представлений с `SQL SECURITY NONE` сможет выполнить любой произвольный запрос.
Таким образом, требуется наличие `GRANT ALLOW SQL SECURITY NONE TO <user>` для создания представления с этой опцией.
:::

Если `DEFINER`/`SQL SECURITY` не указаны, используются значения по умолчанию:
- `SQL SECURITY`: `INVOKER` для обычных представлений и `DEFINER` для материализованных представлений ([настраивается через параметры](../../../operations/settings/settings.md#default_normal_view_sql_security))
- `DEFINER`: `CURRENT_USER` ([настраивается через параметры](../../../operations/settings/settings.md#default_view_definer))

Если представление подключено без указания `DEFINER`/`SQL SECURITY`, значение по умолчанию — это `SQL SECURITY NONE` для материализованного представления и `SQL SECURITY INVOKER` для обычного представления.

Чтобы изменить безопасность SQL для существующего представления, используйте:
```sql
ALTER TABLE MODIFY SQL SECURITY { DEFINER | INVOKER | NONE } [DEFINER = { user | CURRENT_USER }]
```

### Примеры {#examples}
```sql
CREATE VIEW test_view
DEFINER = alice SQL SECURITY DEFINER
AS SELECT ...
```

```sql
CREATE VIEW test_view
SQL SECURITY INVOKER
AS SELECT ...
```

## Live-представление {#live-view}

<DeprecatedBadge/>

Эта функция устарела и будет удалена в будущем.

Для вашего удобства старая документация находится [здесь](https://pastila.nl/?00f32652/fdf07272a7b54bda7e13b919264e449f.md)

## Обновляемое материализованное представление {#refreshable-materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
REFRESH EVERY|AFTER interval [OFFSET interval]
[RANDOMIZE FOR interval]
[DEPENDS ON [db.]name [, [db.]name [, ...]]]
[SETTINGS name = value [, name = value [, ...]]]
[APPEND]
[TO[db.]name] [(columns)] [ENGINE = engine]
[EMPTY]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```
где `interval` — это последовательность простых интервалов:
```sql
number SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR
```

периодически выполняет соответствующий запрос и сохраняет его результат в таблице.
 * Если в запросе указано `APPEND`, каждое обновление добавляет строки в таблицу без удаления существующих строк. Вставка не является атомарной, как и обычный INSERT SELECT.
 * В противном случае каждое обновление атомарно заменяет предыдущие данные в таблице.

Различия от обычных необновляемых материализованных представлений:
 * Нет триггера вставки. Т.е. когда новые данные вставляются в таблицу, указанную в SELECT, они НЕ автоматически попадают в обновляемое материализованное представление. Периодическое обновление выполняет весь запрос.
 * Нет ограничений на запрос SELECT. Табличные функции (например, `url()`), представления, UNION, JOIN разрешены.

:::note
Настройки в части запроса `REFRESH ... SETTINGS` являются настройками обновления (например, `refresh_retries`), отличными от обычных настроек (например, `max_threads`). Обычные настройки можно указать, используя `SETTINGS` в конце запроса.
:::

### Расписание обновления {#refresh-schedule}

Пример расписания обновления:
```sql
REFRESH EVERY 1 DAY -- каждый день в полночь (UTC)
REFRESH EVERY 1 MONTH -- в первый день каждого месяца в полночь
REFRESH EVERY 1 MONTH OFFSET 5 DAY 2 HOUR -- на шестой день каждого месяца в 2:00
REFRESH EVERY 2 WEEK OFFSET 5 DAY 15 HOUR 10 MINUTE -- каждую вторую субботу в 15:10
REFRESH EVERY 30 MINUTE -- в 00:00, 00:30, 01:00, 01:30 и т.д.
REFRESH AFTER 30 MINUTE -- через 30 минут после завершения предыдущего обновления, без привязки к времени суток
-- REFRESH AFTER 1 HOUR OFFSET 1 MINUTE -- синтаксическая ошибка, OFFSET не допускается с AFTER
REFRESH EVERY 1 WEEK 2 DAYS -- каждое 9-е число, не в конкретный день недели или месяца;
                            -- если номер дня (с 1969-12-29) делится на 9
REFRESH EVERY 5 MONTHS -- каждые 5 месяцев, разные месяцы каждый год (так как 12 не делится на 5);
                       -- если номер месяца (с 1970-01) делится на 5
```

`RANDOMIZE FOR` случайным образом корректирует время каждого обновления, напр.:
```sql
REFRESH EVERY 1 DAY OFFSET 2 HOUR RANDOMIZE FOR 1 HOUR -- каждый день в случайное время между 01:30 и 02:30
```

В одно и то же время для данного представления может выполняться не более одного обновления. Например, если представление с `REFRESH EVERY 1 MINUTE` обновляется 2 минуты, оно будет обновляться каждые 2 минуты. Если потом оно станет быстрее и начнёт обновляться за 10 секунд, оно вернется к обновлению каждую минуту. (В частности, оно не будет обновляться каждые 10 секунд, чтобы догнать отставание по пропущенным обновлениям — такого отставания нет.)

Кроме того, обновление начинается сразу после создания материализованного представления, если в запросе `CREATE` не указано `EMPTY`. Если `EMPTY` указано, первое обновление происходит по расписанию.

### В реплицируемых базах данных {#in-replicated-db}

Если обновляемое материализованное представление находится в [реплицируемой базе данных](../../../engines/database-engines/replicated.md), реплики координируются друг с другом таким образом, чтобы только одна реплика выполняла обновление в каждое запланированное время. Требуется движок таблицы [ReplicatedMergeTree](../../../engines/table-engines/mergetree-family/replication.md), чтобы все реплики видели данные, полученные в результате обновления.

В режиме `APPEND` координация может быть отключена, используя `SETTINGS all_replicas = 1`. Это заставляет реплики выполнять обновления независимо друг от друга. В этом случае ReplicatedMergeTree не требуется.

В нет режиме `APPEND` поддерживается только координированное обновление. Для некоординированного используется база данных `Atomic` и запрос `CREATE ... ON CLUSTER` для создания обновляемых материализованных представлений на всех репликах.

Координация осуществляется через Keeper. Путь znode определяется настройкой сервера [default_replica_path](../../../operations/server-configuration-parameters/settings.md#default_replica_path).

### Зависимости {#refresh-dependencies}

`DEPENDS ON` синхронизирует обновления разных таблиц. Например, предположим, что существует цепочка из двух обновляемых материализованных представлений:

```sql
CREATE MATERIALIZED VIEW source REFRESH EVERY 1 DAY AS SELECT * FROM url(...)
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY AS SELECT ... FROM source
```
Без `DEPENDS ON` оба представления начнут обновление в полночь, и `destination`, как правило, будет видеть вчерашние данные в `source`. Если мы добавим зависимость:

```sql
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY DEPENDS ON source AS SELECT ... FROM source
```
тогда обновление `destination` начнёт выполняться только после завершения обновления `source` за этот день, так что `destination` будет основано на свежих данных.

Или, тот же результат можно достичь с помощью:
```sql
CREATE MATERIALIZED VIEW destination REFRESH AFTER 1 HOUR DEPENDS ON source AS SELECT ... FROM source
```
где `1 HOUR` может быть любым интервалом, меньшим, чем период обновления `source`. Зависимая таблица не будет обновляться чаще, чем любая из её зависимостей. Это действительный способ установить цепочку обновляемых представлений, не указывая реальный период обновления больше одного раза.

Ещё несколько примеров:
 * `REFRESH EVERY 1 DAY OFFSET 10 MINUTE` (`destination`) зависит от `REFRESH EVERY 1 DAY` (`source`)<br/>
   Если обновление `source` занимает больше 10 минут, `destination` будет ждать его.
 * `REFRESH EVERY 1 DAY OFFSET 1 HOUR` зависит от `REFRESH EVERY 1 DAY OFFSET 23 HOUR`<br/>
   Похоже на вышеприведённое, хотя соответствующие обновления происходят в разные календарные дни.
   Обновление `destination` на день X+1 будет ждать завершения обновления `source` за день X (если оно занимает более 2 часов).
 * `REFRESH EVERY 2 HOUR` зависит от `REFRESH EVERY 1 HOUR`<br/>
   2-часовое обновление происходит после 1-часового обновления каждые два часа, например, после полуночи,
   затем после 2 часов ночи и т.д.
 * `REFRESH EVERY 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH AFTER 2 HOUR`<br/>
   `destination` обновляется один раз после каждого обновления `source`, то есть каждые 2 часа. Фактически `1 MINUTE` игнорируется.
 * `REFRESH AFTER 1 HOUR` зависит от `REFRESH AFTER 1 HOUR`<br/>
   В настоящее время это не рекомендуется.

:::note
`DEPENDS ON` работает только между обновляемыми материализованными представлениями. Указание обычной таблицы в списке `DEPENDS ON` приведёт к тому, что представление никогда не будет обновляться (зависимости могут быть удалены с помощью `ALTER`, см. ниже).
:::

### Настройки {#settings}

Доступные настройки обновления:
 * `refresh_retries` - сколько раз повторить попытку, если запрос обновления завершится с исключением. Если все попытки не удачны, пропустить до следующего запланированного времени обновления. 0 означает отсутствие повторов, -1 означает бесконечные повторы. По умолчанию: 0.
 * `refresh_retry_initial_backoff_ms` - задержка перед первой попыткой повтора, если `refresh_retries` не равен нулю. Каждая последующая попытка повтора удваивает задержку, вплоть до `refresh_retry_max_backoff_ms`. По умолчанию: 100 мс.
 * `refresh_retry_max_backoff_ms` - ограничение на экспоненциальный рост задержки между попытками обновления. По умолчанию: 60000 мс (1 минута).

### Изменение параметров обновления {#changing-refresh-parameters}

Чтобы изменить параметры обновления:
```sql
ALTER TABLE [db.]name MODIFY REFRESH EVERY|AFTER ... [RANDOMIZE FOR ...] [DEPENDS ON ...] [SETTINGS ...]
```

:::note
Это заменяет *все* параметры обновления одновременно: расписание, зависимости, настройки и добавление (APPEND). Например, если таблица имела `DEPENDS ON`, выполнение `MODIFY REFRESH` без указания `DEPENDS ON` удалит зависимости.
:::

### Другие операции {#other-operations}

Статус всех обновляемых материализованных представлений доступен в таблице [`system.view_refreshes`](../../../operations/system-tables/view_refreshes.md). В частности, она содержит прогресс обновления (если оно выполняется), время последнего и следующего обновления, сообщение об исключении, если обновление завершилось ошибкой.

Для ручной остановки, запуска, вызова или отмены обновлений используйте [`SYSTEM STOP|START|REFRESH|WAIT|CANCEL VIEW`](../system.md#refreshable-materialized-views).

Чтобы дождаться завершения обновления, используйте [`SYSTEM WAIT VIEW`](../system.md#refreshable-materialized-views). В частности, это полезно для ожидания начального обновления после создания представления.

:::note
Интересный факт: запрос обновления может читать из представления, которое обновляется, видя до-обновлённую версию данных. Это значит, что вы можете реализовать Игру Жизни Конуэя: https://pastila.nl/?00021a4b/d6156ff819c83d490ad2dcec05676865#O0LGWTO7maUQIA4AcGUtlA==
:::

## Оконное представление {#window-view}

<ExperimentalBadge/>
<CloudNotSupportedBadge/>

:::info
Это экспериментальная функция, которая в будущем может измениться и стать несовместимой с предыдущими версиями. Включите использование оконных представлений и запроса `WATCH`, используя настройку [allow_experimental_window_view](/operations/settings/settings#allow_experimental_window_view). Введите команду `set allow_experimental_window_view = 1`.
:::

```sql
CREATE WINDOW VIEW [IF NOT EXISTS] [db.]table_name [TO [db.]table_name] [INNER ENGINE engine] [ENGINE engine] [WATERMARK strategy] [ALLOWED_LATENESS interval_function] [POPULATE]
AS SELECT ...
GROUP BY time_window_function
[COMMENT 'comment']
```

Оконное представление может агрегировать данные по временным окнам и выводить результаты, когда окно готово к срабатыванию. Оно хранит результаты частичной агрегации во внутренней (или указанной) таблице, чтобы уменьшить задержку, и может отправлять результат обработки в указанную таблицу или отправлять уведомления, используя запрос WATCH.

Создание оконного представления похоже на создание `MATERIALIZED VIEW`. Оконному представлению нужен внутренний движок хранения для хранения промежуточных данных. Внутреннее хранилище может быть указано с использованием предложения `INNER ENGINE`, по умолчанию оконное представление будет использовать `AggregatingMergeTree` в качестве внутреннего движка.

При создании оконного представления без `TO [db].[table]`, необходимо указать `ENGINE` — движок таблицы для хранения данных.

### Временные оконные функции {#time-window-functions}

[Временные оконные функции](../../functions/time-window-functions.md) используются для получения нижней и верхней границы окна записей. Оконное представление должно использоваться с временной оконной функцией.

### ВРЕМЕННЫЕ АТРИБУТЫ {#time-attributes}

Оконное представление поддерживает **время обработки** и **время события**.

**Время обработки** позволяет оконному представлению выдавать результаты на основе времени локальной машины и используется по умолчанию. Это самое простое понятие времени, но оно не обеспечивает детерминированности. Атрибут времени обработки может быть определён путём установки `time_attr` временной оконной функции в столбец таблицы или использованием функции `now()`. Следующий запрос создаёт оконное представление с временем обработки.

```sql
CREATE WINDOW VIEW wv AS SELECT count(number), tumbleStart(w_id) as w_start from date GROUP BY tumble(now(), INTERVAL '5' SECOND) as w_id
```

**Время события** — это время, когда каждое отдельное событие произошло на устройстве, его создавшем. Это время обычно встроено в записи при их создании. Обработка времени события позволяет получать одинаковые результаты даже в случае несинхронных или поздних событий. Оконное представление поддерживает обработку времени события, используя синтаксис `WATERMARK`.

Оконное представление предлагает три стратегии водяных знаков:

* `STRICTLY_ASCENDING`: Выдает водяной знак максимального наблюдаемого на текущий момент времени. Строки, у которых временная метка меньше максимальной временной метки, не считаются поздними.
* `ASCENDING`: Выдает водяной знак максимального наблюдаемого на текущий момент времени минус 1. Строки, у которых временная метка равна и меньше максимальной временной метки, не считаются поздними.
* `BOUNDED`: WATERMARK=INTERVAL. Выдает водяные знаки, которые являются максимальной наблюдаемой временной меткой за вычетом указанной задержки.

Следующие запросы являются примерами создания оконного представления с помощью `WATERMARK`:

```sql
CREATE WINDOW VIEW wv WATERMARK=STRICTLY_ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=INTERVAL '3' SECOND AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
```

По умолчанию окно срабатывает, когда поступает водяной знак, и элементы, которые пришли после водяного знака, отбрасываются. Оконное представление поддерживает обработку поздних событий, настроив `ALLOWED_LATENESS=INTERVAL`. Пример обработки задержек:

```sql
CREATE WINDOW VIEW test.wv TO test.dst WATERMARK=ASCENDING ALLOWED_LATENESS=INTERVAL '2' SECOND AS SELECT count(a) AS count, tumbleEnd(wid) AS w_end FROM test.mt GROUP BY tumble(timestamp, INTERVAL '5' SECOND) AS wid;
```

Обратите внимание, что элементы, сгенерированные поздним срабатыванием, следует рассматривать как обновленные результаты предыдущего вычисления. Вместо срабатывания в конце окон, оконное представление будет срабатывать немедленно, когда прибудет позднее событие. Таким образом, для одного и того же окна будет получено несколько результатов. Пользователи должны учитывать эти дублированные результаты или удалять их.

Вы можете изменить запрос `SELECT`, указанный в оконном представлении, с помощью оператора `ALTER TABLE ... MODIFY QUERY`. Структура данных, полученная в новом запросе `SELECT`, должна быть такой же, как и в исходном запросе `SELECT`, при использовании или без использования предложения `TO [db.]name`. Обратите внимание, что данные в текущем окне будут утеряны, поскольку промежуточное состояние не может быть повторно использовано.

### Мониторинг новых окон {#monitoring-new-windows}

Оконное представление поддерживает запрос [WATCH](../../../sql-reference/statements/watch.md) для мониторинга изменений или использование синтаксиса `TO` для вывода результатов в таблицу.

```sql
WATCH [db.]window_view
[EVENTS]
[LIMIT n]
[FORMAT format]
```

Запрос `WATCH` действует аналогично `LIVE VIEW`. Можно указать `LIMIT`, чтобы задать количество обновлений, которые необходимо получить перед завершением запроса. Опция `EVENTS` может быть использована для получения краткой формы запроса `WATCH`, где вместо результата запроса вы получите просто последние данные водяного знака запроса.

### Настройки {#settings-1}

- `window_view_clean_interval`: Интервал очистки оконного представления в секундах для освобождения устаревших данных. Система сохранит окна, которые не были полностью сработаны в соответствии с системным временем или конфигурацией `WATERMARK`, а остальные данные будут удалены.
- `window_view_heartbeat_interval`: Интервал сердцебиения в секундах, чтобы указать, что запрос наблюдения (watch) активен.
- `wait_for_window_view_fire_signal_timeout`: Таймаут ожидания сигнала срабатывания оконного представления при обработке времени события.

### Пример {#example}

Предположим, нам нужно подсчитать количество кликов по логам в интервале 10 секунд в таблице логов `data`, структура которой:

```sql
CREATE TABLE data ( `id` UInt64, `timestamp` DateTime) ENGINE = Memory;
```

Сначала мы создадим оконное представление с оконным интервалом в 10 секунд:

```sql
CREATE WINDOW VIEW wv as select count(id), tumbleStart(w_id) as window_start from data group by tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Затем используем запрос `WATCH`, чтобы получить результаты.

```sql
WATCH wv
```

Когда логи вставляются в таблицу `data`,

```sql
INSERT INTO data VALUES(1,now())
```

Запрос `WATCH` должен вывести результаты следующим образом:

```text
┌─count(id)─┬────────window_start─┐
│         1 │ 2020-01-14 16:56:40 │
└───────────┴─────────────────────┘
```

В качестве альтернативы мы можем связать вывод с другой таблицей, используя синтаксис `TO`.

```sql
CREATE WINDOW VIEW wv TO dst AS SELECT count(id), tumbleStart(w_id) as window_start FROM data GROUP BY tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Дополнительные примеры можно найти среди тестов состояния ClickHouse (они названы `*window_view*`).

### Использование оконных представлений {#window-view-usage}

Оконные представления полезны в следующих сценариях:

* **Мониторинг**: Агрегация и вычисление метрик журналов по времени и вывод результатов в целевую таблицу. Панель мониторинга может использовать целевую таблицу как источник данных.
* **Анализ**: Автоматическая агрегация и предварительная обработка данных во временном окне. Это может быть полезно при анализе большого количества журналов. Предварительная обработка устраняет повторные вычисления в нескольких запросах и уменьшает задержку запроса.

## Связанный контент {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
- Блог: [Построение решения для наблюдаемости с ClickHouse - Часть 2 - Трассировки](https://clickhouse.com/blog/storing-traces-and-spans-open-telemetry-in-clickhouse)
