---
description: 'Документация для CREATE VIEW'
sidebar_label: 'VIEW'
sidebar_position: 37
slug: /sql-reference/statements/create/view
title: 'CREATE VIEW'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import DeprecatedBadge from '@theme/badges/DeprecatedBadge';
import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';


# CREATE VIEW

Создает новое представление. Представления могут быть [обычными](#normal-view), [материализованными](#materialized-view), [обновляемыми материализованными](#refreshable-materialized-view) и [оконными](/sql-reference/statements/create/view#window-view) (обновляемые материализованные представления и оконные представления являются экспериментальными функциями).

## Обычное представление {#normal-view}

Синтаксис:

```sql
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [(alias1 [, alias2 ...])] [ON CLUSTER cluster_name]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

Обычные представления не хранят никаких данных. Они просто выполняют чтение из другой таблицы при каждом доступе. Другими словами, обычное представление не что иное, как сохраненный запрос. При чтении из представления используется этот сохраненный запрос в качестве подзапроса в [FROM](../../../sql-reference/statements/select/from.md) клаузе.

В качестве примера предположим, что вы создали представление:

```sql
CREATE VIEW view AS SELECT ...
```

и написали запрос:

```sql
SELECT a, b, c FROM view
```

Этот запрос полностью эквивалентен использованию подзапроса:

```sql
SELECT a, b, c FROM (SELECT ...)
```

## Параметризованное представление {#parameterized-view}

Параметризованные представления аналогичны обычным представлениям, но могут быть созданы с параметрами, которые не разрешаются немедленно. Эти представления могут использоваться с табличными функциями, которые указывают имя представления в качестве имени функции, а значения параметров - в качестве ее аргументов.

```sql
CREATE VIEW view AS SELECT * FROM TABLE WHERE Column1={column1:datatype1} and Column2={column2:datatype2} ...
```
Вышеуказанное создает представление для таблицы, которое может использоваться в качестве табличной функции, подставляя параметры, как показано ниже.

```sql
SELECT * FROM view(column1=value1, column2=value2 ...)
```

## Материализованное представление {#materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster_name] [TO[db.]name [(columns)]] [ENGINE = engine] [POPULATE]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

:::tip
Вот пошаговое руководство по использованию [Материализованных представлений](/guides/developer/cascading-materialized-views.md).
:::

Материализованные представления хранят данные, преобразованные соответствующим [SELECT](../../../sql-reference/statements/select/index.md) запросом.

При создании материализованного представления без `TO [db].[table]`, вы должны указать `ENGINE` – движок таблицы для хранения данных.

При создании материализованного представления с `TO [db].[table]`, вы не можете также использовать `POPULATE`.

Материализованное представление реализуется следующим образом: когда данные вставляются в таблицу, указанную в `SELECT`, часть вставленных данных преобразуется этим `SELECT` запросом, и результат вставляется в представление.

:::note
Материализованные представления в ClickHouse используют **имена колонок** вместо порядка колонок при вставке в целевую таблицу. Если некоторые имена колонок отсутствуют в результате запроса `SELECT`, ClickHouse использует значение по умолчанию, даже если колонка не является [Nullable](../../data-types/nullable.md). Безопасной практикой будет добавление псевдонимов для каждой колонки при использовании Материализованных представлений.

Материализованные представления в ClickHouse реализованы больше как триггеры вставки. Если в запросе представления есть какая-либо агрегация, она применяется только к партии только что вставленных данных. Любые изменения существующих данных исходной таблицы (такие как обновление, удаление, удаление партиции и т.д.) не изменяют материализованное представление.

Материализованные представления в ClickHouse не имеют детерминированного поведения в случае ошибок. Это означает, что блоки, которые уже были записаны, будут сохранены в целевой таблице, но все блоки после ошибки не будут.

По умолчанию, если вставка в одно из представлений завершится неудачей, то запрос INSERT также завершится неудачей, и некоторые блоки могут не быть записаны в целевую таблицу. Это можно изменить с помощью настройки `materialized_views_ignore_errors` (вы должны установить ее для запроса `INSERT`), если вы установите `materialized_views_ignore_errors=true`, тогда любые ошибки при вставке в представления будут игнорироваться, и все блоки будут записаны в целевую таблицу.

Также отметим, что `materialized_views_ignore_errors` по умолчанию установлено в `true` для таблиц `system.*_log`.
:::

Если вы укажете `POPULATE`, существующие данные таблицы вставляются в представление при его создании, как если бы вы выполнили `CREATE TABLE ... AS SELECT ...`. В противном случае запрос содержит только данные, вставленные в таблицу после создания представления. Мы **не рекомендуем** использовать `POPULATE`, так как данные, вставленные в таблицу во время создания представления, не будут в него вставлены.

:::note
Учитывая, что `POPULATE` работает как `CREATE TABLE ... AS SELECT ...`, у него есть ограничения:
- Он не поддерживается с Реплицированными базами данных.
- Он не поддерживается в ClickHouse cloud.

Вместо этого можно использовать отдельную `INSERT ... SELECT`.
:::

Запрос `SELECT` может содержать `DISTINCT`, `GROUP BY`, `ORDER BY`, `LIMIT`. Обратите внимание, что соответствующие преобразования выполняются независимо для каждого блока вставленных данных. Например, если установлен `GROUP BY`, данные агрегируются во время вставки, но только в пределах одной партии вставленных данных. Данные не будут агрегироваться дальше. Исключение составляет случай использования `ENGINE`, который самостоятельно выполняет агрегацию данных, такой как `SummingMergeTree`.

Выполнение [ALTER](/sql-reference/statements/alter/view.md) запросов для материализованных представлений имеет ограничения, например, вы не можете обновить запрос `SELECT`, поэтому это может быть неудобно. Если материализованное представление использует конструкцию `TO [db.]name`, вы можете `DETACH` представление, выполнить `ALTER` для целевой таблицы, а затем `ATTACH` ранее открепленное (`DETACH`) представление.

Обратите внимание, что материализованное представление подвержено влиянию настройки [optimize_on_insert](/operations/settings/settings#optimize_on_insert). Данные объединяются перед вставкой в представление.

Представления выглядят так же, как обычные таблицы. Например, они перечислены в результате запроса `SHOW TABLES`.

Чтобы удалить представление, используйте [DROP VIEW](../../../sql-reference/statements/drop.md#drop-view). Хотя `DROP TABLE` также работает для VIEW.

## SQL безопасность {#sql_security}

`DEFINER` и `SQL SECURITY` позволяют указать, какого пользователя ClickHouse использовать при выполнении базового запроса представления. `SQL SECURITY` имеет три законных значения: `DEFINER`, `INVOKER` или `NONE`. Вы можете указать любого существующего пользователя или `CURRENT_USER` в клаузе `DEFINER`.

Следующая таблица объяснит, какие права требуются для какого пользователя для выбора из представления. Обратите внимание, что независимо от варианта SQL безопасности, во всех случаях все равно требуется иметь `GRANT SELECT ON <view>`, чтобы прочитать из него.

| Варианты SQL безопасности | Представление                                                  | Материализованное представление                                                                                                       |
|-------------------------|--------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| `DEFINER alice`        | `alice` должен иметь право `SELECT` на исходную таблицу представления. | `alice` должен иметь право `SELECT` на исходную таблицу представления и право `INSERT` на целевую таблицу представления.                |
| `INVOKER`              | Пользователь должен иметь право `SELECT` на исходную таблицу представления. | `SQL SECURITY INVOKER` не может быть указан для материализованных представлений.                                                       |
| `NONE`                 | -                                                            | -                                                                                                                                        |

:::note
`SQL SECURITY NONE` является устаревшей опцией. Любой пользователь с правами на создание представлений с `SQL SECURITY NONE` сможет выполнить любой произвольный запрос.
Поэтому необходимо иметь `GRANT ALLOW SQL SECURITY NONE TO <user>`, чтобы создать представление с этой опцией.
:::

Если `DEFINER`/`SQL SECURITY` не указаны, используются значения по умолчанию:
- `SQL SECURITY`: `INVOKER` для обычных представлений и `DEFINER` для материализованных представлений ([настраивается через настройки](../../../operations/settings/settings.md#default_normal_view_sql_security))
- `DEFINER`: `CURRENT_USER` ([настраивается через настройки](../../../operations/settings/settings.md#default_view_definer))

Если представление прикреплено без указания `DEFINER`/`SQL SECURITY`, то значением по умолчанию является `SQL SECURITY NONE` для материализованного представления и `SQL SECURITY INVOKER` для обычного представления.

Чтобы изменить SQL безопасность для существующего представления, используйте
```sql
ALTER TABLE MODIFY SQL SECURITY { DEFINER | INVOKER | NONE } [DEFINER = { user | CURRENT_USER }]
```

### Примеры {#examples}
```sql
CREATE VIEW test_view
DEFINER = alice SQL SECURITY DEFINER
AS SELECT ...
```

```sql
CREATE VIEW test_view
SQL SECURITY INVOKER
AS SELECT ...
```

## Обновляемое материализованное представление {#refreshable-materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
REFRESH EVERY|AFTER interval [OFFSET interval]
[RANDOMIZE FOR interval]
[DEPENDS ON [db.]name [, [db.]name [, ...]]]
[SETTINGS name = value [, name = value [, ...]]]
[APPEND]
[TO[db.]name] [(columns)] [ENGINE = engine]
[EMPTY]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```
где `interval` - последовательность простых интервалов:
```sql
number SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR
```

Периодически выполняет соответствующий запрос и хранит его результат в таблице.
 * Если в запросе указано `APPEND`, каждое обновление вставляет строки в таблицу без удаления существующих строк. Вставка не атомарна, как и обычный INSERT SELECT.
 * В противном случае каждое обновление Atomically заменяет предыдущий содержимое таблицы.

Отличия от обычных не обновляемых материализованных представлений:
 * Нет триггера вставки. Т.е. когда новые данные вставляются в таблицу, указанную в SELECT, они *не* автоматически отправляются в обновляемое материализованное представление. Периодическое обновление выполняет весь запрос.
 * Нет ограничений для запроса SELECT. Табличные функции (например, `url()`), представления, UNION, JOIN – все допустимо.

:::note
Настройки в части запроса `REFRESH ... SETTINGS` являются настройками обновления (например, `refresh_retries`), отличными от обычных настроек (например, `max_threads`). Обычные настройки могут быть указаны с помощью `SETTINGS` в конце запроса.
:::

### График обновлений {#refresh-schedule}

Примеры графиков обновлений:
```sql
REFRESH EVERY 1 DAY -- every day, at midnight (UTC)
REFRESH EVERY 1 MONTH -- on 1st day of every month, at midnight
REFRESH EVERY 1 MONTH OFFSET 5 DAY 2 HOUR -- on 6th day of every month, at 2:00 am
REFRESH EVERY 2 WEEK OFFSET 5 DAY 15 HOUR 10 MINUTE -- every other Saturday, at 3:10 pm
REFRESH EVERY 30 MINUTE -- at 00:00, 00:30, 01:00, 01:30, etc
REFRESH AFTER 30 MINUTE -- 30 minutes after the previous refresh completes, no alignment with time of day
-- REFRESH AFTER 1 HOUR OFFSET 1 MINUTE -- syntax error, OFFSET is not allowed with AFTER
REFRESH EVERY 1 WEEK 2 DAYS -- every 9 days, not on any particular day of the week or month;
                            -- specifically, when day number (since 1969-12-29) is divisible by 9
REFRESH EVERY 5 MONTHS -- every 5 months, different months each year (as 12 is not divisible by 5);
                       -- specifically, when month number (since 1970-01) is divisible by 5
```

`RANDOMIZE FOR` случайным образом регулирует время каждого обновления, например:
```sql
REFRESH EVERY 1 DAY OFFSET 2 HOUR RANDOMIZE FOR 1 HOUR -- every day at random time between 01:30 and 02:30
```

Не более одного обновления может выполняться одновременно для данного представления. Например, если представление с `REFRESH EVERY 1 MINUTE` занимает 2 минуты для обновления, оно будет обновляться каждые 2 минуты. Если затем оно становится быстрее и начинает обновляться за 10 секунд, оно вернется к обновлению каждую минуту. (В частности, оно не будет обновляться каждые 10 секунд, чтобы догнать накопившиеся обновления — такого накопления нет.)

Кроме того, обновление начинается сразу после создания материализованного представления, если в запросе `CREATE` не указано `EMPTY`. Если указано `EMPTY`, первое обновление происходит по графику.

### В Реплицированной БД {#in-replicated-db}

Если обновляемое материализованное представление находится в [реплицируемой базе данных](../../../engines/database-engines/replicated.md), реплики координируют свою работу таким образом, что только одна реплика выполняет обновление в каждый запланированный момент времени. Для этого требуется движок таблиц [ReplicatedMergeTree](../../../engines/table-engines/mergetree-family/replication.md), чтобы все реплики видели данные, произведенные обновлением.

В режиме `APPEND` координацию можно отключить с помощью `SETTINGS all_replicas = 1`. Это позволяет репликам выполнять обновления независимо друг от друга. В этом случае ReplicatedMergeTree не требуется.

В не `APPEND` режиме поддерживается только координированное обновление. Для некординированных обновлений используйте атомарную базу данных и запрос `CREATE ... ON CLUSTER`, чтобы создать обновляемые материализованные представления на всех репликах.

Координация осуществляется через Keeper. Путь znode определяется настройкой сервера [default_replica_path](../../../operations/server-configuration-parameters/settings.md#default_replica_path).

### Зависимости {#refresh-dependencies}

`DEPENDS ON` синхронизирует обновления разных таблиц. К примеру, предположим, что существует цепочка из двух обновляемых материализованных представлений:
```sql
CREATE MATERIALIZED VIEW source REFRESH EVERY 1 DAY AS SELECT * FROM url(...)
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY AS SELECT ... FROM source
```
Без `DEPENDS ON` оба представления начнут обновление в полночь, и `destination` обычно будет видеть данные за вчера в `source`. Если мы добавим зависимость:
```sql
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY DEPENDS ON source AS SELECT ... FROM source
```
то обновление `destination` начнется только после завершения обновления `source` в этот день, поэтому `destination` будет основываться на свежих данных.

В качестве альтернативы тот же результат можно достичь с помощью:
```sql
CREATE MATERIALIZED VIEW destination REFRESH AFTER 1 HOUR DEPENDS ON source AS SELECT ... FROM source
```
где `1 HOUR` может быть любой временной период, меньший периода обновления `source`. Зависимая таблица не будет обновляться чаще, чем любое из ее зависимостей. Это допустимый способ настройки цепочки обновляемых представлений, не указывая реальный период обновления более одного раза.

Несколько дополнительных примеров:
 * `REFRESH EVERY 1 DAY OFFSET 10 MINUTE` (`destination`) зависит от `REFRESH EVERY 1 DAY` (`source`)<br/>
   Если обновление `source` занимает более 10 минут, `destination` будет ждать его.
 * `REFRESH EVERY 1 DAY OFFSET 1 HOUR` зависит от `REFRESH EVERY 1 DAY OFFSET 23 HOUR`<br/>
   Похожий на предыдущий, хотя соответствующие обновления происходят в разные календарные дни.
   Обновление `destination` в день X+1 будет ждать обновления `source` в день X (если оно заняло более 2 часов).
 * `REFRESH EVERY 2 HOUR` зависит от `REFRESH EVERY 1 HOUR`<br/>
   Обновление 2 HOUR происходит после обновления 1 HOUR каждый второй час, например, после обновления полуночи,
   а затем после обновления в 2 часа и т.д.
 * `REFRESH EVERY 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH AFTER 2 HOUR`<br/>
   Обновление `destination` выполняется один раз после каждого обновления `source`, т.е. каждые 2 часа. `1 MINUTE` фактически игнорируется.
 * `REFRESH AFTER 1 HOUR` зависит от `REFRESH AFTER 1 HOUR`<br/>
   В данный момент это не рекомендуется.

:::note
`DEPENDS ON` работает только между обновляемыми материализованными представлениями. Перечисление обычной таблицы в списке `DEPENDS ON` предотвратит обновление представления (зависимости можно удалить с помощью `ALTER`, см. ниже).
:::

### Настройки {#settings}

Доступные настройки обновления:
 * `refresh_retries` - Сколько раз повторить попытку, если запрос на обновление завершился исключением. Если все повторы не удачны, пропустите следующее запланированное время обновления. 0 означает без повторов, -1 означает бесконечные повторы. По умолчанию: 0.
 * `refresh_retry_initial_backoff_ms` - Задержка перед первым повтором, если `refresh_retries` не равен нулю. Каждый последующий повтор удваивает задержку, до `refresh_retry_max_backoff_ms`. По умолчанию: 100 мс.
 * `refresh_retry_max_backoff_ms` - Ограничение на экспоненциальный рост задержки между попытками обновления. По умолчанию: 60000 мс (1 минута).

### Изменение параметров обновления {#changing-refresh-parameters}

Чтобы изменить параметры обновления:
```sql
ALTER TABLE [db.]name MODIFY REFRESH EVERY|AFTER ... [RANDOMIZE FOR ...] [DEPENDS ON ...] [SETTINGS ...]
```

:::note
Это заменяет *все* параметры обновления сразу: расписание, зависимости, настройки и режим APPEND. Например, если у таблицы был `DEPENDS ON`, выполнение `MODIFY REFRESH` без `DEPENDS ON` удалит зависимости.
:::

### Другие операции {#other-operations}

Статус всех обновляемых материализованных представлений доступен в таблице [`system.view_refreshes`](../../../operations/system-tables/view_refreshes.md). В частности, в ней содержится информация о ходе обновления (если оно выполняется), времени последнего и следующего обновления, сообщение об исключении, если обновление завершилось неудачей.

Чтобы вручную остановить, запустить, вызвать или отменить обновления, используйте [`SYSTEM STOP|START|REFRESH|WAIT|CANCEL VIEW`](../system.md#refreshable-materialized-views).

Чтобы дождаться завершения обновления, используйте [`SYSTEM WAIT VIEW`](../system.md#refreshable-materialized-views). В частности, полезно для ожидания первоначального обновления после создания представления.

:::note
Факт: запрос на обновление может читать из представления, которое обновляется, видя предварительную версию данных. Это означает, что вы можете реализовать игру Конвея: https://pastila.nl/?00021a4b/d6156ff819c83d490ad2dcec05676865#O0LGWTO7maUQIA4AcGUtlA==
:::

## Оконное представление {#window-view}

<ExperimentalBadge/>
<CloudNotSupportedBadge/>

:::info
Это экспериментальная функция, которая может измениться в несовместимые с предыдущими способами в будущих выпусках. Включите использование оконных представлений и запроса `WATCH`, используя настройку [allow_experimental_window_view](/operations/settings/settings#allow_experimental_window_view). Введите команду `set allow_experimental_window_view = 1`.
:::

```sql
CREATE WINDOW VIEW [IF NOT EXISTS] [db.]table_name [TO [db.]table_name] [INNER ENGINE engine] [ENGINE engine] [WATERMARK strategy] [ALLOWED_LATENESS interval_function] [POPULATE]
AS SELECT ...
GROUP BY time_window_function
[COMMENT 'comment']
```

Оконное представление может агрегировать данные по временным окнам и выводить результаты, когда окно готово к запуску. Оно хранит частичные результаты агрегации во внутренней (или указанной) таблице, чтобы уменьшить задержку, и может отправлять результат обработки в указанную таблицу или отправлять уведомления с помощью запроса `WATCH`.

Создание оконного представления похоже на создание `MATERIALIZED VIEW`. Оконное представление требует внутреннего движка хранения для хранения промежуточных данных. Внутреннее хранилище можно указать с помощью клаузе `INNER ENGINE`, по умолчанию оконное представление будет использовать `AggregatingMergeTree` как внутренний движок.

При создании оконного представления без `TO [db].[table]` вы должны указать `ENGINE` – движок таблицы для хранения данных.

### Функции временного окна {#time-window-functions}

[Функции временного окна](../../functions/time-window-functions.md) используются для получения нижней и верхней границы окна записей. Оконное представление должно использоваться с функцией временного окна.

### ВРЕМЕННЫЕ АТРИБУТЫ {#time-attributes}

Оконное представление поддерживает **время обработки** и **время событий**.

**Время обработки** позволяет оконному представлению производить результаты на основе времени локальной машины и используется по умолчанию. Это наиболее простое поняние времени, но оно не обеспечивает детерминированности. Атрибут времени обработки может быть определен путем установки `time_attr` функции временного окна на столбец таблицы или с помощью функции `now()`. Следующий запрос создает оконное представление с временем обработки.

```sql
CREATE WINDOW VIEW wv AS SELECT count(number), tumbleStart(w_id) as w_start from date GROUP BY tumble(now(), INTERVAL '5' SECOND) as w_id
```

**Время событий** - это время, когда каждое индивидуальное событие произошло на устройстве-источнике. Это время обычно встроено в записи, когда оно создается. Обработка времени событий позволяет получать последовательные результаты, даже в случае событий вне порядка или поздних событий. Оконное представление поддерживает обработку времени событий, используя синтаксис `WATERMARK`.

Оконное представление предоставляет три стратегии водяного знака:

* `STRICTLY_ASCENDING`: Выдает водяной знак максимальной наблюдаемой временной метки на данный момент. Строки, имеющие временную метку меньше максимальной временной метки, не являются поздними.
* `ASCENDING`: Выдает водяной знак максимальной наблюдаемой временной метки на данный момент минус 1. Строки, имеющие временную метку, равную и меньшую максимальной временной метке, не являются поздними.
* `BOUNDED`: WATERMARK=INTERVAL. Выдает водяные знаки, которые представляют собой максимальную наблюдаемую временную метку минус указанную задержку.

Следующие запросы являются примерами создания оконного представления с `WATERMARK`:

```sql
CREATE WINDOW VIEW wv WATERMARK=STRICTLY_ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=INTERVAL '3' SECOND AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
```

По умолчанию окно будет срабатывать, когда поступает водяной знак, и элементы, которые пришли за водяным знаком, будут отброшены. Оконное представление поддерживает обработку поздних событий, устанавливая `ALLOWED_LATENESS=INTERVAL`. Пример обработки задержки:

```sql
CREATE WINDOW VIEW test.wv TO test.dst WATERMARK=ASCENDING ALLOWED_LATENESS=INTERVAL '2' SECOND AS SELECT count(a) AS count, tumbleEnd(wid) AS w_end FROM test.mt GROUP BY tumble(timestamp, INTERVAL '5' SECOND) AS wid;
```

Обратите внимание, что элементы, выданные поздним срабатыванием, должны рассматриваться как обновленные результаты предыдущего вычисления. Вместо срабатывания в конце окон, оконное представление будет срабатывать немедленно, когда поступает позднее событие. Таким образом, это приведет к нескольким выходным данным для одного и того же окна. Пользователи должны учитывать эти дубликаты результатов или выполнять дедупликацию.

Вы можете изменить запрос `SELECT`, который был указан в оконном представлении, с помощью оператора `ALTER TABLE ... MODIFY QUERY`. Структура данных, результирующая из нового запроса `SELECT`, должна быть такой же, как у первоначального запроса `SELECT`, с или без клаузе `TO [db.]name`. Обратите внимание, что данные в текущем окне будут потеряны, поскольку промежуточное состояние не может быть повторно использовано.

### Мониторинг новых окон {#monitoring-new-windows}

Оконное представление поддерживает запрос [WATCH](../../../sql-reference/statements/watch.md) для мониторинга изменений, или используйте синтаксис `TO`, чтобы выводить результаты в таблицу.

```sql
WATCH [db.]window_view
[EVENTS]
[LIMIT n]
[FORMAT format]
```

Запрос `WATCH` действует аналогично запросу `LIVE VIEW`. Можно указать `LIMIT`, чтобы задать количество обновлений, которые следует получить перед завершением запроса. Клаузу `EVENTS` можно использовать, чтобы получить короткую форму запроса `WATCH`, где вместо результата запроса вы получите только наиболее свежий водяной знак запроса.

### Настройки {#settings-1}

- `window_view_clean_interval`: Интервал очистки оконного представления в секундах для освобождения устаревших данных. Система сохранит окна, которые не были полностью активированы согласно системному времени или настройке `WATERMARK`, а другие данные будут удалены.
- `window_view_heartbeat_interval`: Интервал опроса в секундах, указывающий, что запрос на просмотр активен.
- `wait_for_window_view_fire_signal_timeout`: Тайм-аут ожидания сигнала активации оконного представления в обработке времени событий.

### Пример {#example}

Предположим, нам нужно подсчитать количество логов кликов за 10 секунд в таблице логов под названием `data`, и структура таблицы:

```sql
CREATE TABLE data ( `id` UInt64, `timestamp` DateTime) ENGINE = Memory;
```

Сначала мы создаем оконное представление с временным окном в 10 секунд:

```sql
CREATE WINDOW VIEW wv as select count(id), tumbleStart(w_id) as window_start from data group by tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Затем мы используем запрос `WATCH`, чтобы получить результаты.

```sql
WATCH wv
```

Когда логи вставляются в таблицу `data`,

```sql
INSERT INTO data VALUES(1,now())
```

Запрос `WATCH` должен вывести результаты следующим образом:

```text
┌─count(id)─┬────────window_start─┐
│         1 │ 2020-01-14 16:56:40 │
└───────────┴─────────────────────┘
```

В качестве альтернативы, мы можем прикрепить вывод к другой таблице с использованием синтаксиса `TO`.

```sql
CREATE WINDOW VIEW wv TO dst AS SELECT count(id), tumbleStart(w_id) as window_start FROM data GROUP BY tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Дополнительные примеры можно найти среди состояний тестов ClickHouse (они называются `*window_view*` там).

### Использование оконного представления {#window-view-usage}

Оконное представление полезно в следующих сценариях:

* **Мониторинг**: Аггрегирование и подсчет метрик логов по времени, и вывод результатов в целевую таблицу. Дашборд может использовать целевую таблицу в качестве исходной таблицы.
* **Анализ**: Автоматическое агрегирование и предварительная обработка данных в временном окне. Это может быть полезно при анализе большого количества логов. Предварительная обработка устраняет повторные вычисления в нескольких запросах и снижает задержку запросов.

## Связанные материалы {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
- Блог: [Создание решения для мониторинга с ClickHouse - Часть 2 - Трейсы](https://clickhouse.com/blog/storing-traces-and-spans-open-telemetry-in-clickhouse)
