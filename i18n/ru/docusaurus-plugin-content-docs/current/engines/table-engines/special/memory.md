---
description: 'Движок Memory хранит данные в ОЗУ в несжатом виде. Данные
  хранятся в точно таком же виде, в каком они были получены при чтении. Другими словами, чтение
  из этой таблицы совершенно бесплатно.'
sidebar_label: 'Память'
sidebar_position: 110
slug: /engines/table-engines/special/memory
title: 'Движок таблиц Memory'
---


# Движок таблиц Memory

:::note
При использовании движка таблиц Memory в ClickHouse Cloud данные не реплицируются по всем узлам (по замыслу). Чтобы гарантировать, что все запросы маршрутизируются к одному и тому же узлу и что движок таблиц Memory работает как ожидается, вы можете сделать одно из следующего:
- Выполнять все операции в одной сессии
- Использовать клиент, который использует TCP или нативный интерфейс (что включает поддержку «липких» соединений), например, [clickhouse-client](/interfaces/cli)
:::

Движок Memory хранит данные в ОЗУ в несжатом виде. Данные хранятся в точно таком же виде, в каком они были получены при чтении. Другими словами, чтение из этой таблицы совершенно бесплатно. 
Одновременный доступ к данным синхронизирован. Блокировки кратковременны: операции чтения и записи не блокируют друг друга. 
Индексы не поддерживаются. Чтение параллелизовано.

Максимальная производительность (более 10 ГБ/сек) достигается на простых запросах, поскольку нет чтения с диска, распаковки или десериализации данных. (Следует отметить, что в большинстве случаев производительность движка MergeTree почти такая же высокая.) 
При перезапуске сервера данные исчезают из таблицы, и таблица становится пустой. 
Обычно использование этого движка таблиц не оправдано. Тем не менее, его можно использовать для тестов и задач, где максимальная скорость требуется при относительно небольшом количестве строк (до примерно 100 000 000).

Движок Memory используется системой для временных таблиц с внешними данными запроса (см. раздел «Внешние данные для обработки запроса») и для реализации `GLOBAL IN` (см. раздел «Операторы IN»).

Можно задать верхние и нижние пределы для ограничения размера таблицы движка Memory, эффективно позволяя ему работать как кольцевой буфер (см. [Параметры Движка](#engine-parameters)).

## Параметры Движка {#engine-parameters}

- `min_bytes_to_keep` — Минимальный размер в байтах, который следует сохранить, когда размер таблицы в памяти ограничен.
  - Значение по умолчанию: `0`
  - Требуется `max_bytes_to_keep`
- `max_bytes_to_keep` — Максимальный размер в байтах, который следует сохранить в таблице памяти, где самые старые строки удаляются при каждой вставке (т.е. кольцевой буфер). Максимальный размер может превышать указанный предел, если самая старая партия строк для удаления попадает под предел `min_bytes_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `min_rows_to_keep` — Минимальное количество строк, которое следует сохранить, когда размер таблицы в памяти ограничен.
  - Значение по умолчанию: `0`
  - Требуется `max_rows_to_keep`
- `max_rows_to_keep` — Максимальное количество строк, которое следует сохранить в таблице памяти, где самые старые строки удаляются при каждой вставке (т.е. кольцевой буфер). Максимальное количество строк может превышать указанный предел, если самая старая партия строк для удаления попадает под предел `min_rows_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `compress` - Нужно ли сжимать данные в памяти.
  - Значение по умолчанию: `false`

## Использование {#usage}

**Инициализация настроек**
```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Изменение настроек**
```sql
ALTER TABLE memory MODIFY SETTING min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Примечание:** Оба параметра ограничения `bytes` и `rows` могут быть заданы одновременно, однако, будут соблюдены нижние пределы `max` и `min`.

## Примеры {#examples}
```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_bytes_to_keep = 4096, max_bytes_to_keep = 16384;

/* 1. тестирование, что самая старая партия не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 8'192 байт

/* 2. добавление блока, который не удаляется */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 1'024 байт

/* 3. тестирование, что самая старая партия удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 8'192 байт

/* 4. проверка, что очень большой блок перекрывает все */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 65'536 байт

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' and database = currentDatabase();
```

```text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```

также для строк:

```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 4000, max_rows_to_keep = 10000;

/* 1. тестирование, что самая старая партия не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 1'600 строк

/* 2. добавление блока, который не удаляется */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 100 строк

/* 3. тестирование, что самая старая партия удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 1'000 строк

/* 4. проверка, что очень большой блок перекрывает все */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 10'000 строк

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' and database = currentDatabase();
```

```text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```
