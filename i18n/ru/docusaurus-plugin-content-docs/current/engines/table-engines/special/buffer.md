---
description: 'Буферизует данные для записи в ОЗУ, периодически сбрасывая их в другую таблицу. Во время операции чтения данные читаются одновременно из буфера и другой таблицы.'
sidebar_label: 'Буфер'
sidebar_position: 120
slug: /engines/table-engines/special/buffer
title: 'Движок таблицы Буфер'
---


# Движок таблицы Буфер

Буферизует данные для записи в ОЗУ, периодически сбрасывая их в другую таблицу. Во время операции чтения данные читаются одновременно из буфера и другой таблицы.

:::note
Рекомендуемая альтернатива движку таблицы Буфер — включение [асинхронных вставок](/guides/best-practices/asyncinserts.md).
:::

```sql
Buffer(database, table, num_layers, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes [,flush_time [,flush_rows [,flush_bytes]]])
```

### Параметры движка: {#engine-parameters}

#### database {#database}

`database` – Имя базы данных. Вы можете использовать `currentDatabase()` или другое константное выражение, которое возвращает строку.

#### table {#table}

`table` – Таблица для сброса данных.

#### num_layers {#num_layers}

`num_layers` – Уровень параллелизма. Фактически таблица будет представлена как `num_layers` независимых буферов.

#### min_time, max_time, min_rows, max_rows, min_bytes, and max_bytes {#min_time-max_time-min_rows-max_rows-min_bytes-and-max_bytes}

Условия для сброса данных из буфера.

### Опциональные параметры движка: {#optional-engine-parameters}

#### flush_time, flush_rows, and flush_bytes {#flush_time-flush_rows-and-flush_bytes}

Условия для сброса данных из буфера в фоновом режиме (опущенные или равные нулю параметры означают отсутствие параметров `flush*`).

Данные сбрасываются из буфера и записываются в целевую таблицу, если выполнены все условия `min*` или хотя бы одно условие `max*`.

Также, если выполнено хотя бы одно условие `flush*`, в фоновом режиме инициируется сброс. Это отличается от `max*`, поскольку `flush*` позволяет настраивать фоновый сброс отдельно, чтобы избежать увеличения задержки для запросов `INSERT` в таблицы Буфер.

#### min_time, max_time, and flush_time {#min_time-max_time-and-flush_time}

Условие для времени в секундах с момента первого изменения буфера.

#### min_rows, max_rows, and flush_rows {#min_rows-max_rows-and-flush_rows}

Условие для количества строк в буфере.

#### min_bytes, max_bytes, and flush_bytes {#min_bytes-max_bytes-and-flush_bytes}

Условие для количества байтов в буфере.

Во время операции записи данные вставляются в один или несколько случайных буферов (настраиваемых с помощью `num_layers`). Или, если часть данных для вставки достаточно велика (больше чем `max_rows` или `max_bytes`), она записывается напрямую в целевую таблицу, минуя буфер.

Условия для сброса данных рассчитываются отдельно для каждого из буферов `num_layers`. Например, если `num_layers = 16` и `max_bytes = 100000000`, максимальное потребление ОЗУ составит 1.6 ГБ.

Пример:

```sql
CREATE TABLE merge.hits_buffer AS merge.hits ENGINE = Buffer(merge, hits, 1, 10, 100, 10000, 1000000, 10000000, 100000000)
```

Создание таблицы `merge.hits_buffer` со структурой, аналогичной `merge.hits`, и с использованием движка Буфер. При записи в эту таблицу данные буферизуются в ОЗУ и позже записываются в таблицу 'merge.hits'. Создается один буфер, и данные сбрасываются, если выполнено одно из следующих условий:
- Прошло 100 секунд с момента последнего сброса (`max_time`) или
- Записано 1 миллион строк (`max_rows`) или
- Записано 100 МБ данных (`max_bytes`) или
- Прошло 10 секунд (`min_time`) и записано 10,000 строк (`min_rows`) и 10 МБ (`min_bytes`) данных

Например, если была записана всего одна строка, через 100 секунд она будет сброшена, независимо от других условий. Но если было записано много строк, данные будут сброшены раньше.

Когда сервер остановлен, с помощью `DROP TABLE` или `DETACH TABLE`, буферизованные данные также сбрасываются в целевую таблицу.

Вы можете установить пустые строки в одинарных кавычках для имени базы данных и таблицы. Это указывает на отсутствие целевой таблицы. В этом случае, когда достигаются условия сброса данных, буфер просто очищается. Это может быть полезно для поддержания окна данных в памяти.

При чтении из таблицы Буфер данные обрабатываются как из буфера, так и из целевой таблицы (если она есть). Обратите внимание, что таблица Буфер не поддерживает индекс. Другими словами, данные в буфере полностью сканируются, что может быть медленным для больших буферов. (Для данных в подчиненной таблице будет использован поддерживаемый индекс.)

Если набор столбцов в таблице Буфер не совпадает с набором столбцов в подчиненной таблице, вставляется подмножество столбцов, которые существуют в обоих таблицах.

Если типы не совпадают для одного из столбцов в таблице Буфер и подчиненной таблице, в журнал сервера записывается сообщение об ошибке, и буфер очищается. То же самое происходит, если подчиненная таблица не существует, когда буфер сбрасывается.

:::note
Запуск ALTER на таблице Буфер в версиях, выпущенных до 26 октября 2021 года, вызовет ошибку `Block structure mismatch` (см. [#15117](https://github.com/ClickHouse/ClickHouse/issues/15117) и [#30565](https://github.com/ClickHouse/ClickHouse/pull/30565)), поэтому единственным вариантом будет удалить таблицу Буфер, а затем воссоздать ее. Убедитесь, что эта ошибка исправлена в вашей версии, прежде чем пытаться запустить ALTER на таблице Буфер.
:::

Если сервер перезапускается неправильно, данные в буфере будут потеряны.

`FINAL` и `SAMPLE` не работают корректно для таблиц Буфер. Эти условия передаются в целевую таблицу, но не используются для обработки данных в буфере. Если эти функции требуются, мы рекомендуем использовать таблицу Буфер только для записи, а читать из целевой таблицы.

При добавлении данных в таблицу Буфер один из буферов блокируется. Это вызывает задержки, если одновременно выполняется операция чтения из таблицы.

Данные, вставленные в таблицу Буфер, могут оказаться в подчиненной таблице в другом порядке и в разных блоках. Из-за этого использование таблицы Буфер для корректной записи в CollapsingMergeTree затруднено. Чтобы избежать проблем, вы можете установить `num_layers` в 1.

Если целевая таблица реплицируется, некоторые ожидаемые характеристики реплицируемых таблиц теряются при записи в таблицу Буфер. Случайные изменения порядка строк и размеров частей данных приводят к тому, что дедупликация данных перестает работать, что означает, что невозможно выполнить надежную запись «ровно один раз» в реплицируемые таблицы.

Из-за этих недостатков мы можем рекомендовать использовать таблицу Буфер только в редких случаях.

Таблица Буфер используется, когда слишком много INSERT'ов принимается от большого числа серверов за единицу времени, и данные не могут быть буферизированы перед вставкой, что означает, что INSERT'ы не могут выполняться достаточно быстро.

Обратите внимание, что нет смысла вставлять данные по одной строке, даже для таблиц Буфер. Это приведет только к скорости всего в несколько тысяч строк в секунду, в то время как вставка более крупных блоков данных может дать более миллиона строк в секунду.
