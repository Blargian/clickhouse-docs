---
slug: /development/style
sidebar_position: 70
sidebar_label: C++ スタイルガイド
---


# C++ スタイルガイド

## 一般的な推奨事項 {#general-recommendations}

以下は推奨事項であり、必須事項ではありません。
コードを編集する場合、既存のコードのフォーマットに従うのが理にかなっています。
コードスタイルは一貫性が必要です。一貫性はコードを読みやすくし、検索を容易にします。
多くのルールには論理的な理由がない場合もありますが、確立された慣行によって規定されています。

## フォーマット {#formatting}

**1.** フォーマットの大部分は `clang-format` によって自動的に行われます。

**2.** インデントは4スペースです。タブが4スペースを追加するように開発環境を設定してください。

**3.** 開始および終了の波括弧は別の行に置かなければなりません。

``` cpp
inline void readBoolText(bool & x, ReadBuffer & buf)
{
    char tmp = '0';
    readChar(tmp, buf);
    x = tmp != '0';
}
```

**4.** 関数本体全体が単一の `statement` である場合、それは1行に置くことができます。波括弧の周りにはスペースを置いてください（行の末尾のスペースを除く）。

``` cpp
inline size_t mask() const                { return buf_size() - 1; }
inline size_t place(HashValue x) const    { return x & mask(); }
```

**5.** 関数の場合、括弧の周りにスペースを入れないでください。

``` cpp
void reinsert(const Value & x)
```

``` cpp
memcpy(&buf[place_value], &x, sizeof(x));
```

**6.** `if`、`for`、`while` およびその他の式では、開き括弧の前にスペースが挿入されます（関数呼び出しとは対照的に）。

``` cpp
for (size_t i = 0; i < rows; i += storage.index_granularity)
```

**7.** 二項演算子（`+`、`-`、`*`、`/`、`%`、...）および三項演算子 `?:` の周りにはスペースを追加してください。

``` cpp
UInt16 year = (s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0');
UInt8 month = (s[5] - '0') * 10 + (s[6] - '0');
UInt8 day = (s[8] - '0') * 10 + (s[9] - '0');
```

**8.** 改行が入る場合は、演算子を新しい行に置き、その前のインデントを増やしてください。

``` cpp
if (elapsed_ns)
    message << " ("
        << rows_read_on_server * 1000000000 / elapsed_ns << " rows/s., "
        << bytes_read_on_server * 1000.0 / elapsed_ns << " MB/s.) ";
```

**9.** 行内の整列のためにスペースを使用してもかまいません。

``` cpp
dst.ClickLogID         = click.LogID;
dst.ClickEventID       = click.EventID;
dst.ClickGoodEvent     = click.GoodEvent;
```

**10.** 演算子 `.`, `->` の周りにはスペースを使用しないでください。

必要に応じて、演算子は次の行に折り返すことができます。この場合、前のオフセットを増やします。

**11.** 単項演算子（`--`、 `++`、`*`、`&`、...）と引数の間にスペースを置かないでください。

**12.** カンマの後にスペースを置きますが、前には置きません。`for`式内のセミコロンにも同じルールが適用されます。

**13.** `[]` 演算子を区切るためにスペースを使用しないでください。

**14.** `template <...>` 式では、`template` と `<` の間にスペースを入れ、`<` の後または `>` の前にはスペースを入れないでください。

``` cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
{}
```

**15.** クラスおよび構造体では、`public`、`private`、`protected`を`class/struct`と同じレベルに書き、残りのコードをインデントします。

``` cpp
template <typename T>
class MultiVersion
{
public:
    /// 使用時のオブジェクトのバージョン。shared_ptrがバージョンのライフタイムを管理します。
    using Version = std::shared_ptr<const T>;
    ...
}
```

**16.** 同じ `namespace` がファイル全体で使用されている場合、特に重要なことがなければ、`namespace` 内でのオフセットは必要ありません。

**17.** `if`、`for`、`while` などの式のブロックが単一の `statement` からなる場合、波括弧はオプションです。代わりに `statement` を別の行に置いてください。このルールはネストされた `if`、`for`、`while` にも適用されます。

ただし、内部 `statement` に波括弧または `else` が含まれている場合、外部ブロックは波括弧で記述する必要があります。

``` cpp
/// 書き込み完了。
for (auto & stream : streams)
    stream.second->finalize();
```

**18.** 行の末尾にスペースがあってはいけません。

**19.** ソースファイルはUTF-8でエンコードされています。

**20.** 非ASCII文字は文字列リテラルに使用できます。

``` cpp
<< ", " << (timer.elapsed() / chunks_stats.hits) << " μsec/hit.";
```

**21.** 1行に複数の式を書かないでください。

**22.** 関数内のコードのセクションをグループ化し、1つの空行で区切ります。

**23.** 関数、クラスなどを1つまたは2つの空行で区切ります。

**24.** `A const`（値に関連）は型名の前に書かなければなりません。

``` cpp
//正しい
const char * pos
const std::string & s
//間違い
char const * pos
```

**25.** ポインタや参照を宣言する場合、`*` と `&` 記号の周りにはスペースを空ける必要があります。

``` cpp
//正しい
const char * pos
//間違い
const char* pos
const char *pos
```

**26.** テンプレート型を使用する場合、それらには `using` キーワードを使ってエイリアスを付けます（最も単純な場合を除く）。

別の言い方をすれば、テンプレートパラメーターは `using` のみで指定され、コードでは繰り返されることはありません。

`using` は、関数内などでローカルに宣言できます。

``` cpp
//正しい
using FileStreams = std::map<std::string, std::shared_ptr<Stream>>;
FileStreams streams;
//間違い
std::map<std::string, std::shared_ptr<Stream>> streams;
```

**27.** 異なる型の複数の変数を1つのステートメントで宣言しないでください。

``` cpp
//間違い
int x, *y;
```

**28.** Cスタイルのキャストを使用しないでください。

``` cpp
//間違い
std::cerr << (int)c <<; std::endl;
//正しい
std::cerr << static_cast<int>(c) << std::endl;
```

**29.** クラスと構造体では、メンバーと関数をそれぞれの可視性範囲内で別々にグループ化します。

**30.** 小さなクラスや構造体の場合、メソッドの宣言を実装から分ける必要はありません。

これは、任意のクラスまたは構造体の小さなメソッドにも当てはまります。

テンプレートクラスや構造体については、メソッドの宣言と実装を分けずに書いてください（そうしないと同じ翻訳単位に定義する必要があります）。

**31.** 行は140文字で折り返すことができますが、80文字ではありません。

**32.** 必要がなければ、接頭辞インクリメント/デクリメント演算子を常に使用してください。

``` cpp
for (Names::const_iterator it = column_names.begin(); it != column_names.end(); ++it)
```

## コメント {#comments}

**1.** 非自明なコードのすべての部分にコメントを追加するようにしてください。

これは非常に重要です。コメントを書くことで、コードが必要でないことに気づいたり、設計が間違っていることに気づいたりすることがあります。

``` cpp
/** 使用可能なメモリの一部を表します。
  * たとえば、internal_bufferが1MBであり、ファイルから読み取るためにバッファに10バイトしか読み込まれなかった場合、
  * working_bufferのサイズはわずか10バイトになります
  * （working_buffer.end()は、読み取れる10バイトの直後の位置を指します）。
  */
```

**2.** コメントは必要に応じて詳細に記述できます。

**3.** コメントはそれが説明するコードの前に置いてください。まれに、コメントはコードの後、同じ行に配置できます。

``` cpp
/** クエリを解析して実行します。
*/
void executeQuery(
    ReadBuffer & istr, /// クエリを読み取る場所（およびデータを挿入する場合）
    WriteBuffer & ostr, /// 結果を書く場所
    Context & context, /// DB、テーブル、データ型、エンジン、関数、集約関数...
    BlockInputStreamPtr & query_plan, /// ここにはクエリがどのように実行されたかの説明が書かれます
    QueryProcessingStage::Enum stage = QueryProcessingStage::Complete /// SELECTクエリを処理するまでのステージ
    )
```

**4.** コメントは英語で書かなければなりません。

**5.** ライブラリを書く場合、メインヘッダーファイルにそれを説明する詳細なコメントを含めてください。

**6.** 追加情報を提供しないコメントを追加しないでください。特に、このような空のコメントは残さないでください：

``` cpp
/*
* 手続き名：
* 元の手続き名：
* 著者：
* 作成日：
* 修正日：
* 修正の著者：
* 元のファイル名：
* 目的：
* 意図：
* 指名：
* 使用されるクラス：
* 定数：
* ローカル変数：
* パラメータ：
* 作成日：
* 目的：
*/
```

この例は、http://home.tamk.fi/~jaalto/course/coding-style/doc/unmaintainable-code/から引用されています。

**7.** 各ファイルの先頭にゴミコメント（著者、作成日など）を書かないでください。

**8.** 単一行コメントは三つのスラッシュで始まります：`///`、複数行コメントは `/**`で始まります。これらのコメントは「ドキュメント」と見なされます。

注：これらのコメントからドキュメントを生成するためにDoxygenを使用することができます。しかし、Doxygenは一般的に使用されていません。なぜなら、IDE内でコードをナビゲートする方が便利だからです。

**9.** 複数行コメントは、開始および終了時に空行を持ってはいけません（複数行コメントの終了行を除く）。

**10.** コードのコメントアウトには、基本的なコメントを使用し、「文書化するコメント」を使用しないでください。

**11.** コミットする前に、コメントアウトされたコードの部分を削除してください。

**12.** コメントやコード内で不適切な言葉を使用しないでください。

**13.** 大文字を使用しないでください。過度の句読点を使用しないでください。

``` cpp
/// WHAT THE FAIL???
```

**14.** デリミタを作成するためにコメントを使用しないでください。

``` cpp
///******************************************************
```

**15.** コメントで議論を開始する必要はありません。

``` cpp
/// どうしてこんなことをしたの？
```

**16.** ブロックの終わりにそれが何であったかを説明するコメントを書く必要はありません。

``` cpp
/// for
```

## 名前 {#names}

**1.** 変数とクラスメンバーの名前には小文字のアルファベットとアンダースコアを使用してください。

``` cpp
size_t max_block_size;
```

**2.** 関数（メソッド）の名前には、小文字で始まるキャメルケースを使用します。

``` cpp
std::string getName() const override { return "Memory"; }
```

**3.** クラス（構造体）の名前には、大文字で始まるキャメルケースを使用します。インターフェイスにはI以外のプレフィックスは使用しません。

``` cpp
class StorageMemory : public IStorage
```

**4.** `using` はクラスと同じ方法で名付けられます。

**5.** テンプレート型引数の名前：単純な場合には `T`、`T`、`U`、`T1`、`T2`を使用します。

より複雑な場合は、クラス名のルールに従うか、`T` プレフィックスを追加します。

``` cpp
template <typename TKey, typename TValue>
struct AggregatedStatElement
```

**6.** テンプレート定数引数の名前：変数名のルールに従うか、単純な場合には `N` を使用します。

``` cpp
template <bool without_www>
struct ExtractDomain
```

**7.** 抽象クラス（インターフェイス）には `I` プレフィックスを追加できます。

``` cpp
class IProcessor
```

**8.** 変数をローカルに使用する場合は、短い名前を使用できます。

他のすべてのケースでは、意味を説明する名前を使用してください。

``` cpp
bool info_successfully_loaded = false;
```

**9.** `define` とグローバル定数の名前は、アンダースコアを含むすべて大文字の形式を使用します。

``` cpp
#define MAX_SRC_TABLE_NAMES_TO_STORE 1000
```

**10.** ファイル名は、その内容と同じスタイルを使用する必要があります。

ファイルが1つのクラスを含む場合、ファイル名はクラスと同じにします（キャメルケース）。

ファイルが1つの関数を含む場合、ファイル名は関数と同じにします（キャメルケース）。

**11.** 名前に略語が含まれる場合：

- 変数名の場合、略語は小文字で使います `mysql_connection`（`mySQL_connection`ではなく）。
- クラスや関数の名前の場合、略語内の大文字を保持します `MySQLConnection`（`MySqlConnection`ではなく）。

**12.** クラスメンバーを初期化するためだけに使われるコンストラクタ引数は、クラスメンバーと同じ名前を付けるが、最後にアンダースコアを追加する必要があります。

``` cpp
FileQueueProcessor(
    const std::string & path_,
    const std::string & prefix_,
    std::shared_ptr<FileHandler> handler_)
    : path(path_),
    prefix(prefix_),
    handler(handler_),
    log(&Logger::get("FileQueueProcessor"))
{
}
```

アンダースコアのサフィックスは、引数がコンストラクタ本体で使用されない場合は省略できます。

**13.** ローカル変数とクラスメンバーの名前に違いはありません（プレフィックスは必要ありません）。

``` cpp
timer (m_timerではなく)
```

**14.** `enum` の定数は、大文字から始まるキャメルケースを使用します。すべて大文字でもかまいません。`enum` が非ローカルの場合、`enum class` を使用します。

``` cpp
enum class CompressionMethod
{
    QuickLZ = 0,
    LZ4     = 1,
};
```

**15.** すべての名前は英語である必要があります。ヘブライ語の単語の音写は許可されていません。

    not T_PAAMAYIM_NEKUDOTAYIM

**16.** 略語は、一般的に知られている場合（Wikipediaや検索エンジンで簡単に意味が見つかる場合）は許可されます。

    `AST`, `SQL`.

    `NVDH`（ランダムな文字ではない）

不完全な単語は、短縮版が一般的に使用されている場合に許可されます。

フルネームを隣にコメントとして含める場合は、略語を使用することもできます。

**17.** C++ソースコードのファイル名は `.cpp` 拡張子を持たなければなりません。ヘッダーファイルは `.h` 拡張子を持たなければなりません。

## コードの書き方 {#how-to-write-code}

**1.** メモリ管理。

手動メモリ解放（`delete`）はライブラリコードでのみ使用できます。

ライブラリコードでは、`delete` 演算子はデストラクタ内でのみ使用できます。

アプリケーションコードでは、メモリはそれを所有するオブジェクトによって解放されなければなりません。

例：

- 最も簡単な方法は、オブジェクトをスタック上に置くか、別のクラスのメンバーにすることです。
- 小さなオブジェクトが多数ある場合は、コンテナを使用します。
- ヒープに存在する少数のオブジェクトが自動的に解放される場合は、`shared_ptr/unique_ptr` を使用します。

**2.** リソース管理。

`RAII` を使用し、上記を参照してください。

**3.** エラーハンドリング。

例外を使用します。ほとんどのケースでは、例外をスローするだけで、キャッチする必要はありません（`RAII` のため）。

オフラインデータ処理アプリケーションでは、例外をキャッチしないことが許可される場合があります。

ユーザーリクエストを処理するサーバーでは、接続ハンドラの上位レベルで例外をキャッチするだけで十分です。

スレッド関数では、すべての例外をキャッチして保持し、`join` 後にメインスレッドで再スローする必要があります。

``` cpp
/// 計算がまだ行われていない場合、最初のブロックを同期的に計算します。
if (!started)
{
    calculate();
    started = true;
}
else /// 計算がすでに進行中の場合、結果を待ちます。
    pool.wait();

if (exception)
    exception->rethrow();
```

処理を行わずに例外を隠さないでください。すべての例外を盲目的にログに記録することも避けてください。

``` cpp
//正しくない
catch (...) {}
```

特定の例外を無視する必要がある場合は、特定のものに対してのみ行い、残りは再スローしてください。

``` cpp
catch (const DB::Exception & e)
{
    if (e.code() == ErrorCodes::UNKNOWN_AGGREGATE_FUNCTION)
        return nullptr;
    else
        throw;
}
```

応答コードまたは `errno` を使用する関数を使用する場合、常に結果を確認し、エラーの場合は例外をスローしてください。

``` cpp
if (0 != close(fd))
    throw ErrnoException(ErrorCodes::CANNOT_CLOSE_FILE, "Cannot close file {}", file_name);
```

コード内の不変条件をチェックするために assert を使用できます。

**4.** 例外の型。

アプリケーションコードでは複雑な例外階層を使用する必要はありません。例外のテキストはシステム管理者にとって理解できるものである必要があります。

**5.** デストラクタから例外をスローする。

これは推奨されませんが、許可されています。

以下のオプションを使用します：

- 例外を引き起こす可能性のあるすべての作業を事前に行う関数（`done()` や `finalize()`）を作成します。その関数が呼ばれた場合、後のデストラクタで例外が発生してはなりません。
- ネットワーク経由でメッセージを送信するなど、複雑すぎるタスクは、クラスのユーザーが破棄前に呼び出す必要のある別のメソッドに入れることができます。
- デストラクタで例外が発生した場合、隠すよりはログに記録する方が良いです（ロガーが利用できる場合）。
- シンプルなアプリケーションでは、例外を処理するために `std::terminate` に依存することが許可されます（C++11における `noexcept` のデフォルトのケース）。

**6.** 無名コードブロック。

特定の変数をローカルにするために、単一の関数内に別のコードブロックを作成できるため、そのブロックを出るときにデストラクタが呼び出されます。

``` cpp
Block block = data.in->read();

{
    std::lock_guard<std::mutex> lock(mutex);
    data.ready = true;
    data.block = block;
}

ready_any.set();
```

**7.** マルチスレッド。

オフラインデータ処理プログラムでは：

- 単一のCPUコアで可能な限り最高のパフォーマンスを得ようとします。それから必要に応じてコードを並列化できます。

サーバーアプリケーションでは：

- リクエストを処理するためにスレッドプールを使用します。この時点で、ユーザースペースのコンテキストスイッチを必要とするタスクは発生していません。

フォークは並列化に使用されません。

**8.** スレッドの同期。

異なるスレッドが異なるメモリセルを使用する（さらに良いのは異なるキャッシュラインを使用する）ことができ、スレッドの同期を使わずに済むことが多いです（`joinAll` を除く）。

同期が必要な場合は、多くのケースでミューテックスを使用することが十分です。

他の場合は、システム同期プリミティブを使用します。ビジーウェイトは使用しないでください。

アトミック操作は、最も単純なケースでのみ使用する必要があります。

自分の専門分野が主要なものでない限り、ロックフリーのデータ構造を実装しようとしないでください。

**9.** ポインタと参照。

ほとんどのケースでは、参照を優先してください。

**10.** `const`。

定数参照、定数ポインタ、`const_iterator`、および `const` メソッドを使用します。

`const` をデフォルトとして考え、必要な場合にのみ非 `const` を使用してください。

値で変数を渡す場合、`const` を使用しても通常は意味がありません。

**11.** unsigned。

必要に応じて `unsigned` を使用します。

**12.** 数値型。

`UInt8`、`UInt16`、`UInt32`、`UInt64`、`Int8`、`Int16`、`Int32`、`Int64`、`size_t`、`ssize_t`、および `ptrdiff_t` の型を使用します。

次の数値にこれらの型を使用しないでください：`signed/unsigned long`、`long long`、`short`、`signed/unsigned char`、`char`。

**13.** 引数を渡す。

複雑な値は、移動する予定の場合、値で渡し、`std::move` を使用してください。ループ内で値を更新したい場合は、参照で渡します。

ヒープ内で作成されたオブジェクトの所有権を取得する関数には、引数の型を `shared_ptr` または `unique_ptr` にします。

**14.** 戻り値。

ほとんどのケースでは、`return` を使用してください。`return std::move(res)` と書かないでください。

関数がヒープ上のオブジェクトを割り当ててそれを返す場合、`shared_ptr` または `unique_ptr` を使用します。

稀なケース（ループ内での値の更新）では、引数を通じて値を返す必要があるかもしれません。この場合、引数は参照であるべきです。

``` cpp
using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;

/** 名前から集約関数を作成できるようにします。
  */
class AggregateFunctionFactory
{
public:
    AggregateFunctionFactory();
    AggregateFunctionPtr get(const String & name, const DataTypes & argument_types) const;
```

**15.** `namespace`。

アプリケーションコードのために別の `namespace` を使用する必要はありません。

小さなライブラリにもこれを必要としません。

中程度から大規模なライブラリでは、すべてを `namespace` に入れます。

ライブラリの `.h` ファイルでは、アプリケーションコードには必要のない実装の詳細を隠すために `namespace detail` を使用できます。

`.cpp` ファイルでは、シンボルを隠すために `static` または無名の `namespace` を使用できます。

また、enumが外部の `namespace` に入るのを防ぐために `namespace` を使用することができます（ただし、`enum class` の使用を推奨します）。

**16.** 後処理の初期化。

初期化に引数が必要な場合、通常はデフォルトコンストラクタを書くべきではありません。

後で初期化を遅らせる必要がある場合、無効なオブジェクトを作成するデフォルトコンストラクタを追加できます。あるいは、少数のオブジェクトの場合、`shared_ptr/unique_ptr` を使用可以。

``` cpp
Loader(DB::Connection * connection_, const std::string & query, size_t max_block_size_);

/// 後処理で初期化
Loader() {}
```

**17.** 仮想関数。

クラスが多態的使用を意図していない場合、関数を仮想にする必要はありません。これにはデストラクタも含まれます。

**18.** エンコーディング。

どこでもUTF-8を使用します。`std::string` と `char *` を使用してください。`std::wstring` や `wchar_t` は使用しないでください。

**19.** ロギング。

コード内の例を参照してください。

コミット前に、すべての意味のないデバッグロギングや他の種類のデバッグ出力を削除してください。

ループ内のロギングは避けるべきです、トレースレベルでさえ。

ログは、どのログレベルでも読みやすくなければなりません。

ロギングは主にアプリケーションコードでのみ使用されるべきです。

ログメッセージは英語で書かれなければなりません。

ログは理想的にはシステム管理者にとって理解できるものでなければなりません。

ログに不適切な言葉を使用しないでください。

ログ内ではUTF-8エンコーディングを使用します。まれに非ASCII文字をログに使用できます。

**20.** 入出力。

アプリケーションパフォーマンスに重要な内部サイクルでは `iostreams` を使用しないでください（`stringstream` は決して使用しないでください）。

代わりに `DB/IO` ライブラリを使用してください。

**21.** 日付と時間。

`DateLUT` ライブラリを参照してください。

**22.** include。

インクルードガードの代わりに `#pragma once` を常に使用してください。

**23.** using。

`using namespace` は使用しません。特定のもので `using` を使用できますが、それはクラスや関数内でローカルにしてください。

**24.** 必要がない限り、関数のために `trailing return type` を使用しないでください。

``` cpp
auto f() -> void
```

**25.** 変数の宣言と初期化。

``` cpp
//正しい方法
std::string s = "Hello";
std::string s{"Hello"};

//間違った方法
auto s = std::string{"Hello"};
```

**26.** 仮想関数の場合、基本クラスでは `virtual` を記述しますが、子孫クラスでは `virtual` の代わりに `override` を記述します。

## C++の未使用機能 {#unused-features-of-c}

**1.** 仮想継承は使用されません。

**2.** 現代C++において便利な構文糖を含む構文。

```cpp
// 伝統的な方法は構文糖なし
template <typename G, typename = std::enable_if_t<std::is_same<G, F>::value, void>> // SFINAE via std::enable_if, usage of ::value
std::pair<int, int> func(const E<G> & e) // 明示的に指定された戻り値の型
{
    if (elements.count(e)) // .count() のメンバーシップテスト
    {
        // ...
    }

    elements.erase(
        std::remove_if(
            elements.begin(), elements.end(),
            [&](const auto x){
                return x == 1;
            }),
        elements.end()); // remove-erase慣用句

    return std::make_pair(1, 2); // make_pair()経由でペアを作成
}

// 構文糖あり（C++14/17/20）
template <typename G>
requires std::same_v<G, F> // SFINAE via C++20コンセプト、C++14テンプレートエイリアスの使用
auto func(const E<G> & e) // auto戻り値の型（C++14）
{
    if (elements.contains(e)) // C++20 .contains メンバーシップテスト
    {
        // ...
    }

    elements.erase_if(
        elements,
        [&](const auto x){
            return x == 1;
        }); // C++20 std::erase_if

    return {1, 2}; // または std::pair(1, 2) を返す; 初期化リストまたは値初期化（C++17）でペアを作成
}
```

## プラットフォーム {#platform}

**1.** 特定のプラットフォーム向けにコードを書きます。

しかし、他の条件が同じであれば、クロスプラットフォームまたはポータブルなコードが好まれます。

**2.** 言語：C++20（利用可能な [C++20 機能](https://en.cppreference.com/w/cpp/compiler_support#C.2B.2B20_features) のリストを見てください）。

**3.** コンパイラ：`clang`。執筆時点（2022年7月）では、コードは clang バージョン >= 12 でコンパイルされています（`gcc` でもコンパイルできますが、テストされておらず、商用使用には適していません）。

標準ライブラリが使用されています（`libc++`）。

**4.** OS：Linux Ubuntu、Precise より古くないです。

**5.** コードは x86_64 CPU アーキテクチャ向けに書かれています。

このCPU命令セットは、私たちのサーバーの間の最小サポートされているセットです。現在は SSE 4.2 です。

**6.** `-Wall -Wextra -Werror -Weverything` コンパイルフラグを使用しますが、いくつかの例外があります。

**7.** 難しくて静的に接続するのが難しいライブラリを除き、すべてのライブラリを静的リンクで使用します（`ldd` コマンドの出力を参照）。

**8.** リリース設定でコードを開発およびデバッグします。

## ツール {#tools}

**1.** KDevelopは優れたIDEです。

**2.** デバッグには `gdb`、`valgrind` （`memcheck`）、`strace`、`-fsanitize=...`、または `tcmalloc_minimal_debug` を使用します。

**3.** プロファイリングには `Linux Perf`、`valgrind` （`callgrind`）、または `strace -cf`を使用します。

**4.** ソースコードはGitで管理されています。

**5.** アセンブリは `CMake` を使用します。

**6.** プログラムは `deb` パッケージを使用してリリースされます。

**7.** master へのコミットはビルドを壊してはいけません。

ただし、選択されたリビジョンのみが作業可能と見なされます。

**8.** コードが部分的に準備できている場合でも、できるだけ頻繁にコミットを行います。

この目的のためにブランチを使用してください。

`master` ブランチ内のコードがまだビルド可能でない場合は、`push` 前にビルドから除外してください。数日以内にそれを完成させるか、削除する必要があります。

**9.** 非自明な変更の場合は、ブランチを使用し、それをサーバーに公開してください。

**10.** 未使用のコードはリポジトリから削除されます。

## ライブラリ {#libraries}

**1.** C++20標準ライブラリが使用され（実験的拡張は許可されます）、`boost` および `Poco` フレームワークも使用されます。

**2.** OSパッケージのライブラリを使用することは許可されていません。また、事前にインストールされたライブラリを使用することも許可されていません。すべてのライブラリは、`contrib` ディレクトリ内にソースコードの形で配置され、ClickHouseと共にビルドされるべきです。詳細は [新しいサードパーティライブラリの追加に関するガイドライン](/development/contrib#adding-and-maintaining-third-party-libraries) を参照してください。

**3.** 使用中のライブラリを常に優先します。

## 一般的な推奨事項 {#general-recommendations-1}

**1.** 最小限のコードを書いてください。

**2.** 最も簡単な解決策を試してください。

**3.** コードを書く前に、その動作と内部ループの機能を理解してください。

**4.** 最も単純な場合には、クラスや構造体の代わりに `using` を使用してください。

**5.** 可能であれば、コピーコンストラクタ、代入演算子、デストラクタ（1つ以上の仮想関数を持つクラスの場合を除く）、ムーブコンストラクタまたはムーブ代入演算子を書かないでください。言い換えれば、コンパイラが生成する関数は正常に動作する必要があります。`default` を使用できます。

**6.** コードの簡素化が奨励されています。可能な限りコードのサイズを減らしてください。

## 追加の推奨事項 {#additional-recommendations}

**1.** `stddef.h` からの型に `std::` を明示的に指定することは推奨されません。言い換えれば、`std::size_t` よりも `size_t` と書くことをお勧めします。これは短いためです。

`std::` を追加することは許可されています。

**2.** 標準Cライブラリからの関数に明示的に `std::` を指定することは推奨されません。言い換えれば、`std::memcpy` の代わりに `memcpy` と書いてください。

理由は、`memmem` のような類似の非標準関数が存在するからです。これらの関数は時々利用されます。これらの関数は `namespace std` には存在しません。

常に `std::memcpy` と書くと、`memmem` は `std::` がない場合が奇妙に見えます。

それでも、希望する場合は `std::` を使用できます。

**3.** 標準C++ライブラリから同じ関数が利用可能な場合にCの関数を使用することは許可されています。

例えば、大きなメモリチャンクをコピーする際には `std::copy` の代わりに `memcpy` を使用してください。

**4.** 複数行の関数引数。

次のいずれかのラッピングスタイルが許可されています：

``` cpp
function(
  T1 x1,
  T2 x2)
```

``` cpp
function(
  size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

``` cpp
function(size_t left, size_t right,
  const & RangesInDataParts ranges,
  size_t limit)
```

``` cpp
function(size_t left, size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```

``` cpp
function(
      size_t left,
      size_t right,
      const & RangesInDataParts ranges,
      size_t limit)
```
