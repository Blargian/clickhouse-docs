---
slug: /development/tests
sidebar_position: 40
sidebar_label: テスト
---


# テスト

## 機能テスト {#functional-tests}

機能テストは最もシンプルで便利に使用できます。  
ClickHouseのほとんどの機能は機能テストでテストすることができ、これはテスト可能なClickHouseコードの変更ごとに必須です。

各機能テストは、実行中のClickHouseサーバーに1つまたは複数のクエリを送信し、結果をリファレンスと比較します。

テストは `queries` ディレクトリにあります。  
サブディレクトリは2つあります：`stateless` と `stateful`。  
- Statelessテストは、事前にロードされたテストデータなしでクエリを実行します - それらはしばしばテスト自体内で小さな合成データセットをその場で作成します。  
- Statefulテストは、ClickHouseからの事前にロードされたテストデータを必要とし、一般公開されています。

各テストは2種類のいずれかになります：`.sql` と `.sh`。  
- `.sql` テストは、`clickhouse-client` にパイプされるシンプルなSQLスクリプトです。  
- `.sh` テストは自分自身で実行されるスクリプトです。

SQLテストは一般的に`.sh`テストよりも好まれます。  
純粋なSQLから検証できない機能、たとえば、入力データを `clickhouse-client` にパイプする必要がある場合や `clickhouse-local` をテストする必要がある場合には`.sh`テストを使用すべきです。

:::note
`DateTime` と `DateTime64` のデータ型をテストする際によくある誤りは、サーバーが特定のタイムゾーン（例："UTC"）を使用していると仮定することです。これは正しくなく、CIテストランではタイムゾーンが意図的にランダム化されています。テスト値に対してタイムゾーンを明示的に指定することが最も簡単な回避策です。例：`toDateTime64(val, 3, 'Europe/Amsterdam')`。
:::

### ローカルでのテスト実行 {#running-a-test-locally}

ClickHouseサーバーをローカルで起動し、デフォルトポート（9000）で待ち受けます。  
例えばテスト `01428_hash_set_nan_key` を実行するには、リポジトリフォルダーに移動し、次のコマンドを実行します：

```sh
PATH=<path to clickhouse-client>:$PATH tests/clickhouse-test 01428_hash_set_nan_key
```

テスト結果（`stderr` と `stdout`）は、テスト自体の隣にあるファイル `01428_hash_set_nan_key.[stderr|stdout]` に書き込まれます（`queries/0_stateless/foo.sql`の場合、出力は `queries/0_stateless/foo.stdout` にあります）。

すべてのオプションについては `tests/clickhouse-test --help` を参照してください。  
すべてのテストを実行することも、テスト名のフィルタを提供することでテストのサブセットを実行することもできます：`./clickhouse-test substring`。  
テストを並列で実行したり、ランダム順で実行したりするオプションもあります。

### 新しいテストの追加 {#adding-a-new-test}

新しいテストを追加するには、最初に `queries/0_stateless` ディレクトリに `.sql` または `.sh` ファイルを作成します。  
次に、`clickhouse-client < 12345_test.sql > 12345_test.reference` または `./12345_test.sh > ./12345_test.reference` を使用して対応する `.reference` ファイルを生成します。

テストは、事前に自動で作成されるデータベース `test` 内のテーブルを作成、削除、選択するなどする必要があります。  
一時テーブルの使用は問題ありません。

CIと同じ環境をローカルでセットアップするには、テスト構成をインストールします（これによりZookeeperのモック実装が使用され、いくつかの設定が調整されます）。

```sh
cd <repository>/tests/config
sudo ./install.sh
```

:::note
テストは以下を満たすべきです：
- 最小限：最小限の必要なテーブル、カラム、複雑さのみを作成すること、  
- 高速：数秒（より良いことに、サブ秒）以上かからないこと、  
- 正確で決定的であること：テスト対象の機能が動作していない場合にのみ失敗しないこと、  
- 隔離状態/ステートレスであること：環境とタイミングに依存しないこと  
- 網羅的であること：ゼロ、NULL、空集合、例外などのコーナーケースをカバーすること（ネガティブテストには、`-- { serverError xyz }` と `-- { clientError xyz }` 構文を使用）、  
- テストの終了時にテーブルをクリーンアップすること（残存物がある場合）、  
- 他のテストで同じことをテストしないこと（つまり、最初にgrepする）。
:::

### テスト実行の制限 {#restricting-test-runs}

テストには、CI内でテストが実行されるコンテキストを指定するか無制限の _タグ_ が0個以上付けることができます。

`.sql` テストの場合、タグは最初の行にSQLコメントとして配置されます：

```sql
-- Tags: no-fasttest, no-replicated-database
-- no-fasttest: <provide_a_reason_for_the_tag_here>
-- no-replicated-database: <provide_a_reason_here>

SELECT 1
```

`.sh` テストの場合、タグは2行目のコメントとして書かれます：

```bash
#!/usr/bin/env bash

# Tags: no-fasttest, no-replicated-database

# - no-fasttest: <provide_a_reason_for_the_tag_here>

# - no-replicated-database: <provide_a_reason_here>
```

使用可能なタグのリスト：

| タグ名 | 何をするか | 使用例 |
|---|---|---|
| `disabled` | テストは実行されない | |
| `long` | テストの実行時間が1から10分に延長される | |
| `deadlock` | テストは長時間ループ内で実行される | |
| `race` | `deadlock` と同じ。`deadlock`を優先 | |
| `shard` | サーバーが `127.0.0.*` をリッスンする必要があります | |
| `distributed` | `shard` と同じ。`shard`を優先 | |
| `global` | `shard` と同じ。`shard`を優先 | |
| `zookeeper` | テストはZookeeperまたはClickHouse Keeperを実行する必要があります | テストは `ReplicatedMergeTree` を使用します |
| `replica` | `zookeeper` と同じ。`zookeeper`を優先 | |
| `no-fasttest` | [Fast test](continuous-integration.md#fast-test)の下でテストは実行されない | テストはFast testで無効な `MySQL` テーブルエンジンを使用 |
| `no-[asan, tsan, msan, ubsan]` | [サニタイザー](#sanitizers)でのビルドではテストが無効になります | テストはQEMUで実行されており、これはサニタイザーでは動作しません |
| `no-replicated-database` | | |
| `no-ordinary-database` | | |
| `no-parallel` | このテストと並行して他のテストを実行しないようにします | テストは `system` テーブルから読み取るため、不変条件が破られる可能性があります |
| `no-parallel-replicas` | | |
| `no-debug` | | |
| `no-stress` | | |
| `no-polymorphic-parts` | | |
| `no-random-settings` | | |
| `no-random-merge-tree-settings` | | |
| `no-backward-compatibility-check` | | |
| `no-cpu-x86_64` | | |
| `no-cpu-aarch64` | | |
| `no-cpu-ppc64le` | | |
| `no-s3-storage` | | |

上記の設定とは別に、特定のClickHouse機能の使用を定義するために `system.build_options` から `USE_*` フラグを使用できます。  
たとえば、テストがMySQLテーブルを使用している場合、`use-mysql` タグを追加する必要があります。

### ランダム設定の範囲を指定する {#specifying-limits-for-random-settings}

テストは、テスト実行中にランダム化できる設定の最小および最大許可値を指定できます。

`.sh` テストの場合、制限はタグの横の行またはタグが指定されていない場合の2行目にコメントとして書かれます：

```bash
#!/usr/bin/env bash

# Tags: no-fasttest

# Random settings limits: max_block_size=(1000, 10000); index_granularity=(100, None)
```

`.sql` テストの場合、タグはタグの横の行または最初の行にSQLコメントとして配置されます：

```sql
-- Tags: no-fasttest
-- Random settings limits: max_block_size=(1000, 10000); index_granularity=(100, None)
SELECT 1
```

1つの制限のみを指定する必要がある場合は、もう1つに `None` を使用できます。

### テスト名の選択 {#choosing-the-test-name}

テスト名は5桁のプレフィックスで始まり、その後に説明的な名前が続きます。例： `00422_hash_function_constexpr.sql`。  
プレフィックスを選択するには、ディレクトリ内に既に存在する最大のプレフィックスを見つけ、それを1つ増やします。

```sh
ls tests/queries/0_stateless/[0-9]*.reference | tail -n 1
```

その間に、同じ数字のプレフィックスを持つ他のテストが追加されることがありますが、これは問題なく、後に変更する必要はありません。

### 発生しなければならないエラーのチェック {#checking-for-an-error-that-must-occur}

場合によっては、不正なクエリに対してサーバーエラーが発生することをテストしたいことがあります。  
SQLテストでは、この特別なアノテーションをサポートしています。次の形式で記述します：

```sql
select x; -- { serverError 49 }
```

このテストは、サーバーが未知のカラム `x` に関してエラーコード49を返すことを保証します。  
エラーが発生しない場合、またはエラーが異なる場合、テストは失敗します。  
クライアント側でエラーが発生することを保証したい場合は、 `clientError` アノテーションを代わりに使用します。

エラーメッセージの特定の表現をチェックしないでください。将来的に変更される可能性があり、テストが不必要に壊れる原因となります。  
エラーコードのみを確認してください。  
既存のエラーコードがニーズに対して不正確な場合は、新しいエラーコードを追加することを検討してください。

### 分散クエリのテスト {#testing-a-distributed-query}

機能テストで分散クエリを使用したい場合、`remote` テーブル関数を用いて `127.0.0.{1..2}` アドレスを使用してサーバー自身にクエリを実行したり、サーバー構成ファイルにある事前定義されたテストクラスター `test_shard_localhost` を使用したりできます。  
テスト名に `shard` または `distributed` の単語を追加することを忘れないでください。そうすれば、CIで適切な構成で実行されます。サーバーが分散クエリをサポートするように構成されています。

### 一時ファイルの操作 {#working-with-temporary-files}

シェルテストでその場で作成するファイルが必要な場合があります。  
CIの一部のチェックはテストを並列で実行するため、スクリプト内で一意の名前なしで一時ファイルを作成または削除すると、FlakyなどのCIチェックが失敗する可能性があります。  
これを回避するために、環境変数 `$CLICKHOUSE_TEST_UNIQUE_NAME` を使用して、一時ファイルに現在実行中のテストに固有の名前を付ける必要があります。  
そうすれば、セットアップ中に作成したファイルまたはクリーンアップ中に削除したファイルが、そのテストだけが使用しているファイルであることが確実です。他の並行して実行されているテストのファイルではありません。

## 既知のバグ {#known-bugs}

機能テストで容易に再現できる既知のバグがある場合、事前に準備された機能テストを `tests/queries/bugs` ディレクトリに配置します。  
これらのテストは、バグが修正されると `tests/queries/0_stateless` に移動されます。

## 統合テスト {#integration-tests}

統合テストは、クラスタ構成でのClickHouseをテストし、MySQL、Postgres、MongoDBなど他のサーバーとのClickHouseの相互作用をテストすることを可能にします。  
これらはネットワークの分断、パケットのドロップなどをエミュレートするのに便利です。  
これらのテストはDockerの下で実行され、さまざまなソフトウェアを持つ複数のコンテナを作成します。

これらのテストを実行する方法については `tests/integration/README.md` を参照してください。

ClickHouseとサードパーティのドライバーの統合テストは行っていないことに注意してください。  
また、現在JDBCおよびODBCドライバーとの統合テストは存在しません。

## 単体テスト {#unit-tests}

単体テストは、ClickHouse全体ではなく、単一の孤立したライブラリやクラスをテストしたい場合に便利です。  
テストのビルドを `ENABLE_TESTS` CMakeオプションで有効または無効にできます。  
単体テスト（およびその他のテストプログラム）は、コード全体の `tests` サブディレクトリにあります。  
単体テストを実行するには、`ninja test` と入力します。  
一部のテストは `gtest` を使用しますが、一部はテスト失敗時に非ゼロの終了コードを返すだけのプログラムです。

機能テストで既にカバーされている場合、単体テストは必ずしも必要ありません（機能テストは通常使用が簡単です）。

個々のgtestチェックを、実行可能ファイルを直接呼び出すことで実行できます。以下に例を示します：

```bash
$ ./src/unit_tests_dbms --gtest_filter=LocalAddress*
```

## パフォーマンステスト {#performance-tests}

パフォーマンステストは、合成クエリに対するClickHouseのあるisolated部分の性能を測定および比較することを可能にします。  
パフォーマンステストは `tests/performance/` にあります。  
各テストは、テストケースの説明を持つ`.xml`ファイルで表現されます。  
テストは `docker/test/performance-comparison` ツールで実行されます。実行方法についてはreadmeファイルを参照してください。

各テストは、ループ内で1つまたは複数のクエリ（おそらくパラメータの組み合わせを含む）を実行します。

特定のシナリオでClickHouseのパフォーマンスを改善したい場合、かつ改善が簡単なクエリで観察可能な場合、パフォーマンステストを書くことが強く推奨されます。  
また、SQL関数を追加または変更する際には、比較的孤立していてあまり難解でない場合にはパフォーマンステストを記述することをお勧めします。  
テスト中に `perf top` や他の `perf` ツールを使用するのが常に理にかなっています。

## テストツールとスクリプト {#test-tools-and-scripts}

`tests` ディレクトリの一部のプログラムは、準備されたテストではなく、テストツールです。  
たとえば、`Lexer` には、stdinのトークン化を行い、結果をstdoutに色付けして書き込むツール `src/Parsers/tests/lexer` があります。  
この種のツールをコード例として使用したり、探索や手動テストに役立てたりできます。

## 雑多なテスト {#miscellaneous-tests}

機械学習モデルに対するテストが `tests/external_models` にあります。  
これらのテストは更新されておらず、統合テストに移す必要があります。

定数挿入のための別のテストがあります。  
このテストは、別のサーバー上でClickHouseクラスターを実行し、さまざまな障害ケース：ネットワーク分断、パケットドロップ（ClickHouseノード間、ClickHouseとZooKeeper間、ClickHouseサーバーとクライアント間など）、`kill -9`、`kill -STOP`、および`kill -CONT`をエミュレートします。  
その後、すべての確認済み挿入が書き込まれ、すべての拒否された挿入が書き込まれていないことをチェックします。

クォータムテストは、ClickHouseがオープンソース化される前に別のチームによって書かれました。  
このチームはもはやClickHouseに関与していません。  
テストは偶然にもJavaで記述されました。  
これらの理由から、クォータムテストは書き換えられ、統合テストに移動される必要があります。

## 手動テスト {#manual-testing}

新しい機能を開発する際には、手動でテストすることも合理的です。  
次のステップで行うことができます：

ClickHouseをビルドします。  
ターミナルからClickHouseを実行します：`programs/clickhouse-server` ディレクトリに移動し、`./clickhouse-server`で実行します。  
デフォルトで、現在のディレクトリから設定ファイル（`config.xml`、`users.xml`、および`config.d` と `users.d` ディレクトリ内のファイル）を使用します。  
ClickHouseサーバーに接続するには、`programs/clickhouse-client/clickhouse-client`を実行します。

すべてのclickhouseツール（サーバー、クライアントなど）は、`clickhouse`という名前の単一バイナリへのシンボリックリンクであることに注意してください。  
このバイナリは `programs/clickhouse` で見つけることができます。  
すべてのツールも `clickhouse tool` または `clickhouse-tool` として呼び出すことができます。

あるいは、ClickHouseパッケージをインストールすることもできます。  
ClickHouseリポジトリからの安定版リリースまたは、ClickHouseソースルートで`sud ./release`を使って自分でビルドしたパッケージです。  
その後、`sudo clickhouse start`（またはサーバーを停止するための `stop`）でサーバーを起動します。  
ログは `/etc/clickhouse-server/clickhouse-server.log` にあります。

ClickHouseがすでにシステムにインストールされているとき、新しい`clickhouse`バイナリをビルドして、既存のバイナリを置き換えることができます：

``` bash
$ sudo clickhouse stop
$ sudo cp ./clickhouse /usr/bin/
$ sudo clickhouse start
```

また、システムのClickHouseサーバーを停止し、同じ設定でログをターミナルに出力する自分のサーバーを実行することもできます：

``` bash
$ sudo clickhouse stop
$ sudo -u clickhouse /usr/bin/clickhouse server --config-file /etc/clickhouse-server/config.xml
```

gdbの例：

``` bash
$ sudo -u clickhouse gdb --args /usr/bin/clickhouse server --config-file /etc/clickhouse-server/config.xml
```

システムのClickHouseサーバーがすでに実行中で、それを停止したくない場合は、`config.xml`内のポート番号を変更するか、`config.d`ディレクトリ内のファイルでそれらを上書きし、適切なデータパスを提供して実行してください。

`clickhouse` バイナリはほぼ依存関係がなく、幅広いLinuxディストリビューションで動作します。  
サーバー上での変更を迅速にテストするには、新しくビルドされた `clickhouse` バイナリをサーバーに単に `scp` し、上記の例のように実行できます。

## ビルドテスト {#build-tests}

ビルドテストは、さまざまな代替構成や一部の外国システムでビルドが壊れていないことを確認します。  
これらのテストも自動化されています。

例：
- Darwin x86_64（macOS）へのクロスコンパイル  
- FreeBSD x86_64へのクロスコンパイル  
- Linux AArch64へのクロスコンパイル  
- システムパッケージからのライブラリを使用してUbuntuでビルド（推奨されない）  
- ライブラリの共有リンクでビルド（推奨されない）  

たとえば、システムパッケージでのビルドは悪い慣行です。  
なぜなら、システムにどのパッケージの正確なバージョンが存在するかを保証できないからです。  
しかし、これはDebianのメンテナの必要があります。  
この理由から、少なくともこのビルドのバリエーションをサポートしなければなりません。  
別の例：共有リンクは一般的な問題の原因ですが、熱心な愛好者にも必要です。

すべてのビルドのバリエーションでテストを実行できませんが、少なくともさまざまなビルドのバリエーションが壊れていないことを確認したいと思っています。  
この目的のためにビルドテストを使用します。

また、コンパイルに時間がかかりすぎる翻訳単位や、RAMを必要以上に多く消費するものがないかをテストします。

また、あまりにも大きなスタックフレームがないかもテストします。

## プロトコル互換性のテスト {#testing-for-protocol-compatibility}

ClickHouseのネットワークプロトコルを拡張する際、古いclickhouse-clientが新しいclickhouse-serverと、また新しいclickhouse-clientが古いclickhouse-serverと動作することを手動でテストします（対応するパッケージからバイナリを実行するだけで）。

いくつかのケースは統合テストで自動的にテストされます：
- 古いバージョンのClickHouseによって書き込まれたデータが新しいバージョンによって正常に読み取れること  
- クラスター内で異なるClickHouseバージョンで分散クエリが機能するかどうか

## コンパイラーからのヘルプ {#help-from-the-compiler}

主なClickHouseコード（`dbms` ディレクトリ内にある）は、`-Wall -Wextra -Werror`でビルドされ、いくつかの追加の警告が有効化されています。  
これらのオプションはサードパーティのライブラリには有効ではありません。

Clangにはさらに便利な警告があります - `-Weverything`で探して、デフォルトビルドの何かを選択できます。

本番ビルドでは、Clangが使用されますが、gccビルドもテストします。  
開発には、Clangが通常より便利です。  
デバッグモードで独自のマシンでビルドできます（ラップトップのバッテリーを節約するため）、しかし、コンパイラーは`-O3`を使用することでより良い制御フローと手続き間分析により、より多くの警告を生成できることに注意してください。  
Clangでデバッグモードでビルドする場合、実行時により多くのエラーをキャッチできる`libc++`のデバッグバージョンが使用されます。

## サニタイザー {#sanitizers}

:::note
ローカルで実行する場合、プロセス（ClickHouseサーバーまたはクライアント）が起動時にクラッシュする場合、アドレス空間レイアウトのランダム化を無効にする必要があります：`sudo sysctl kernel.randomize_va_space=0`  
:::

### アドレスサニタイザー {#address-sanitizer}

機能テスト、統合テスト、ストレステスト、単体テストは、コミットごとにASanの下で実行されます。

### スレッドサニタイザー {#thread-sanitizer}

機能テスト、統合テスト、ストレステスト、単体テストは、コミットごとにTSanの下で実行されます。

### メモリサニタイザー {#memory-sanitizer}

機能テスト、統合テスト、ストレステスト、単体テストは、コミットごとにMSanの下で実行されます。

### 未定義の振る舞いサニタイザー {#undefined-behaviour-sanitizer}

機能テスト、統合テスト、ストレステスト、単体テストは、コミットごとにUBSanの下で実行されます。  
サードパーティライブラリの一部のコードはUBのためにサニタイズされています。

### Valgrind（メモリチェック） {#valgrind-memcheck}

以前、私たちは一晩中Valgrindで機能テストを実行していましたが、もう行っていません。  
それには何時間もかかります。  
現在、`re2`ライブラリに既知の偽陽性が1つあります。詳しくは[この記事](https://research.swtch.com/sparse)を参照してください。

## ファジング {#fuzzing}

ClickHouseファジングは、 [libFuzzer](https://llvm.org/docs/LibFuzzer.html) とランダムSQLクエリを使用して実装されています。  
すべてのファジングテストはサニタイザー（アドレスと未定義）と共に実施されるべきです。

LibFuzzerはライブラリコードの孤立したファジングテストに使用されます。  
ファジングテストはテストコードの一部として実装され、"_fuzzer"名前の接尾辞を持っています。  
ファジングテストの例は `src/Parsers/fuzzers/lexer_fuzzer.cpp` に見つけることができます。  
LibFuzzerに特有の設定、辞書、コーパスは `tests/fuzz` に保存されています。  
ユーザー入力を処理するすべての機能に対してファジングテストを書くことを推奨します。

ファジングテストはデフォルトでは構築されません。  
ファジングを構築するには、両方の `-DENABLE_FUZZING=1` と `-DENABLE_TESTS=1` オプションを設定する必要があります。  
ファジングテストを構築する際は、Jemallocを無効にすることをお勧めします。  
ClickHouseファジングをGoogle OSS-Fuzzに統合するために使用される構成は `docker/fuzz` にあります。

また、ランダムSQLクエリを生成し、その実行中にサーバーが死なないことを確認するためにシンプルなファジングテストを使用しています。  
これは `00746_sql_fuzzy.pl` にあります。  
このテストは継続的に（夜中になど）実行されるべきです。

さらに、巨大なコーナーケースを見つけることができる高度なASTベースのクエリファジングテストを使用しています。  
これは、クエリAST内でランダムな順列や置換を行います。  
前のテストからASTノードを記憶しておき、その後のテスト内でランダムな順序で処理を行う際にそれらをファジングに使用します。  
このファジングツールについて詳しくは[このブログ記事](https://clickhouse.com/blog/fuzzing-click-house)を参照してください。

## ストレスタイム {#stress-test}

ストレスタイムは別のファジングのケースです。  
すべての機能テストを並行してランダムに実行します。一つのサーバーで。  
テストの結果はチェックされません。

確認されることは：
- サーバーがクラッシュしないこと、デバッグやサニタイザのトラップがトリガーされないこと；  
- デッドロックがないこと；  
- データベース構造が一貫していること；  
- テスト後にサーバーが正常に停止し、例外なく再起動できること。

5つのバリエーションがあります（Debug、ASan、TSan、MSan、UBSan）。

## スレッドファジング {#thread-fuzzer}

スレッドファジング（スレッドサニタイザーとは混同しないでください）は、スレッドの実行順序をランダム化できる別のファジングの一種です。  
それにより、さらに特別なケースが見つかるのを助けます。

## セキュリティ監査 {#security-audit}

私たちのセキュリティチームは、セキュリティの観点からClickHouseの機能に関する基本的なレビューを行いました。

## 静的解析ツール {#static-analyzers}

コミットごとに`clang-tidy`を実行しています。  
`clang-static-analyzer`のチェックも有効です。  
`clang-tidy`はスタイルチェックの一部にも使用されています。

`clang-tidy`、`Coverity`、`cppcheck`、`PVS-Studio`、`tscancode`、`CodeQL`を評価しました。  
使用法の指示は `tests/instructions/` ディレクトリにあります。

`CLion`をIDEとして使用している場合、いくつかの`clang-tidy`チェックをそのまま利用できます。

スクリプトの静的分析には`shellcheck`も使用しています。

## ハードニング {#hardening}

デバッグビルドでは、ユーザーレベルの割り当てをASLRするカスタムアロケーターを使用しています。

また、割り当て後に読み取り専用であることが予想されるメモリ領域も手動で保護します。

デバッグビルドでは、古くて不安全でスレッドセーフでない関数が呼び出されないようにするため、libcのカスタマイズも関与しています。

デバッグアサーションは広範囲にわたって使用されています。

デバッグビルドでは、「論理エラー」コードの例外がスローされると、プログラムは早期に終了します。  
これにより、リリースビルドでは例外が使用できるようになりますが、デバッグビルドではアサーションになります。

デバッグビルドではjemallocのデバッグバージョンが使用されています。  
デバッグビルドではlibc++のデバッグバージョンが使用されています。

## ランタイム整合性チェック {#runtime-integrity-checks}

ディスクに保存されているデータはチェックサムが付けられます。  
MergeTreeテーブル内のデータは、3つの方法で同時にチェックサムが付けられます*（圧縮データブロック、非圧縮データブロック、ブロック全体の合計チェックサム）。  
クライアントとサーバーの間、またはサーバー間でネットワークを通して転送されるデータもチェックサムが付けられます。  
レプリケーションはレプリカのビット同一データを保証します。

これは、ハードウェアの故障（ストレージメディア上のビットロット、サーバーのRAM上のビットフリップ、ネットワークコントローラのRAM上のビットフリップ、ネットワークスイッチのRAM上のビットフリップ、クライアントのRAM上のビットフリップ、ワイヤ上のビットフリップ）から保護することが必要です。  
ビットフリップは一般的であり、ECC RAMやTCPチェックサムの存在下でも発生する可能性が高いことに注意してください（1日にペタバイトのデータを処理する何千ものサーバーを実行する場合）。  
[ビデオを参照してください（ロシア語）](https://www.youtube.com/watch?v=ooBAQIe0KlQ)。

ClickHouseは、運用エンジニアが故障したハードウェアを見つけるのに役立つ診断を提供します。

\* そして、遅くはありません。

## コードスタイル {#code-style}

コードスタイルのルールは[こちら](style.md)に記載されています。

一般的なスタイル違反をチェックするには、`utils/check-style`スクリプトを使用できます。

コードの適切なスタイルを強制するには、`clang-format`を使用できます。  
ファイル `.clang-format` はソースルートにあります。  
これにより、実際のコードスタイルにほぼ対応します。  
しかし、既存のファイルに `clang-format` を適用することは推奨されません。なぜなら形式が悪化するためです。  
代わりに、`clang` リポジトリ内で見つけられる `clang-format-diff` ツールを使用できます。

また、コードを再フォーマットするために `uncrustify` ツールを試してみることもできます。  
設定はソースのルートにある `uncrustify.cfg` にあります。  
`clang-format` よりもテストが少ないです。

`CLion` には独自のコードフォーマッターがあり、私たちのコードスタイルに合わせて調整する必要があります。

また、コード内の誤字を見つけるために `codespell` を使用します。  
これは自動化されています。

## テストカバレッジ {#test-coverage}

機能テストのテストカバレッジと、ClickHouseサーバーのみに対して追跡します。  
これは日々実施されます。

## テストのためのテスト {#tests-for-tests}

フレークテストのための自動チェックがあります。  
すべての新しいテストを100回（機能テストの場合）または10回（統合テストの場合）実行します。  
少なくとも1回でもテストが失敗した場合、それはフレークと見なされます。

## テスト自動化 {#test-automation}

私たちは、 [GitHub Actions](https://github.com/features/actions) を用いてテストを実行しています。

ビルドジョブとテストは、コミットごとにサンドボックスで実行されます。  
結果として得られたパッケージとテスト結果はGitHubに公開され、直接リンクからダウンロードできます。  
アーティファクトは数ヶ月保存されます。  
GitHubでプルリクエストを送信すると、「テスト可能」としてタグ付けされ、CIシステムがClickHouseパッケージ（リリース、デバッグ、アドレスサニタイザー付きなど）をビルドします。  

