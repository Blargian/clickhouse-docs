---
'slug': '/faq/use-cases/key-value'
'title': 'ClickHouseをキー値ストレージとして使用できますか？'
'toc_hidden': true
'toc_priority': 101
'description': 'ClickHouseをキー値ストレージとして使用できるかどうかについてのよくある質問に答えます。'
---




# ClickHouseをキー・バリュー・ストレージとして使用できますか？ {#can-i-use-clickhouse-as-a-key-value-storage}

短い答えは**「いいえ」**です。キー・バリューのワークロードは、ClickHouseを使用しないべきケースのリストの中でもトップの位置にあります。結局のところ、ClickHouseは[OLAP](../../faq/general/olap.md)システムであり、優れたキー・バリュー・ストレージシステムは他にも多く存在します。

しかし、キー・バリューのようなクエリにClickHouseを使用することが理にかなう状況もあるかもしれません。通常、これは主に分析的な性質のワークロードがあり、ClickHouseに適している低予算の製品の一部であり、しかしながらリクエストスループットがそれほど高くなく、厳しいレイテンシーの要件がないキー・バリューのパターンを必要とする二次プロセスがあります。もし予算が無限であったなら、その二次ワークロードのために別のキー・バリュー・データベースを設置していたでしょうが、実際には、もう一つのストレージシステム（監視、バックアップなど）を維持するための追加コストがあるため、それを避けたい場合があります。

推奨に反してClickHouseに対してキー・バリューのようなクエリを実行することを決めた場合、以下のヒントがあります：

- ClickHouseにおけるポイントクエリが高価である主要な理由は、その主な[MergeTreeテーブルエンジンファミリー](../..//engines/table-engines/mergetree-family/mergetree.md)のスパース主インデックスです。このインデックスは、特定のデータ行を指し示すことができず、代わりに各N番目の行を指し示し、システムは隣接するN番目の行から目的の行にスキャンしなければならず、その過程で過剰なデータを読み込む必要があります。キー・バリューのシナリオでは、`index_granularity`設定を使用してNの値を減らすことが有用かもしれません。
- ClickHouseは各カラムを別々のファイルセットに保持するため、完全な1行を構成するためには各ファイルを通過する必要があります。カラムの数は、カラムの数に応じて線形に増加するため、キー・バリューのシナリオでは、多くのカラムの使用を避け、すべてのペイロードをJSON、Protobuf、またはそれが意味のあるものである何らかのシリアライズ形式でエンコードされた単一の`String`カラムに置くことが価値があるかもしれません。
- 正常な`MergeTree`テーブルの代わりに[Join](../../engines/table-engines/special/join.md)テーブルエンジンを使用し、データを取得するために[joinGet](../../sql-reference/functions/other-functions.md#joinget)関数を使用する代替アプローチもあります。これにより、クエリのパフォーマンスが向上する可能性がありますが、一部の使いやすさや信頼性の問題があるかもしれません。こちらが[使用例](https://github.com/ClickHouse/ClickHouse/blob/master/tests/queries/0_stateless/00800_versatile_storage_join.sql#L49-L51)です。
