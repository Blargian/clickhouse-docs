---
'description': 'Array Functions 的文档'
'sidebar_label': 'Arrays'
'sidebar_position': 10
'slug': '/sql-reference/functions/array-functions'
'title': '数组函数'
---


# 数组函数

<!-- 
以下标签内的内容将在文档框架构建时替换为 
从 system.functions 生成的文档。请勿修改或删除这些标签。
参见： https://github.com/ClickHouse/clickhouse-docs/blob/main/contribute/autogenerated-documentation-from-source.md
-->

<!--AUTOGENERATED_START-->
## array {#array}

引入于：v1.1

**语法**

```sql
array(x1 [, x2, ..., xN])
```

**参数**

- `x1` — 任意类型 T 的常量值。如果仅提供此参数，数组的类型将为 T。
- `[, x2, ..., xN]` — 与 `x1` 共享共同超类型的额外 N 个常量值。

**返回值**

返回 'Array(T)' 类型结果，其中 'T' 是传入参数中最小的共同类型。

**示例**

**有效用法**

```sql title=Query
SELECT array(toInt32(1), toUInt16(2), toInt8(3)) AS a, toTypeName(a)
```

```response title=Response
┌─a───────┬─toTypeName(a)─┐
│ [1,2,3] │ Array(Int32)  │
└─────────┴───────────────┘
```

**无效用法**

```sql title=Query
SELECT array(toInt32(5), toDateTime('1998-06-16'), toInt8(5)) AS a, toTypeName(a)
```

```response title=Response
Received exception from server (version 25.4.3):
Code: 386. DB::Exception: Received from localhost:9000. DB::Exception:
There is no supertype for types Int32, DateTime, Int8 ...
```
## arrayAUCPR {#arrayAUCPR}

引入于：v20.4

**语法**

```sql
arrayAUCPR(scores, labels[, partial_offsets])
```

**参数**

- `cores` — 模型提供的评分预测。 [Array](/sql-reference/data-types/array) 的 [整数](../data-types/int-uint.md) 或 [浮点数](../data-types/float.md)。
- `labels` — 样本的标签，通常为正样本的 1 和负样本的 0。 [Array](/sql-reference/data-types/array) 的 [整数](../data-types/int-uint.md) 或 [枚举](../data-types/enum.md)。
- `partial_offsets` — 
- 可选。用于计算 PR 曲线下部分区域的 [`Array(T)`](/sql-reference/data-types/array) ，包含三个非负整数，而不是整个 AUC。此选项对 PR AUC 的分布式计算很有用。数组必须包含以下元素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]。 [Array](/sql-reference/data-types/array) 的非负 [整数](../data-types/int-uint.md)。可选。
    - `higher_partitions_tp`: 在高分分区中正标签的数量。
    - `higher_partitions_fp`: 在高分分区中负标签的数量。
    - `total_positives`: 整个数据集中正样本的总数。

::::note
当使用 `arr_partial_offsets` 时，`arr_scores` 与 `arr_labels` 应仅为整个数据集的一个分区，包含一个分数区间。
数据集应被划分为连续的分区，每个分区包含分数落在特定范围内的数据子集。
例如：
- 一个分区可以包含所有在范围 [0, 0.5) 的分数。
- 另一个分区可以包含范围 [0.5, 1.0] 的分数。
::::


**返回值**

返回精确-召回 (PR) 曲线下的区域。 [Float64](../data-types/float.md)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```
## arrayAll {#arrayAll}

引入于：v1.1

**语法**

```sql
arrayAll(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

如果 lambda 函数对所有元素返回 true，则返回 `1`，否则返回 `0`。 [`UInt8`](/sql-reference/data-types/int-uint)。

**示例**

**所有元素匹配**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 2, 3])
```

```response title=Response
1
```

**不是所有元素匹配**

```sql title=Query
SELECT arrayAll(x, y -> x=y, [1, 2, 3], [1, 1, 1])
```

```response title=Response
0
```
## arrayAvg {#arrayAvg}

引入于：v21.1

**语法**

```sql
arrayAvg([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中元素的平均值，或者如果提供，则返回 lambda 结果的平均值。 [`Float64`](/sql-reference/data-types/float)。

**示例**

**基本示例**

```sql title=Query
SELECT arrayAvg([1, 2, 3, 4]);
```

```response title=Response
2.5
```

**使用 lambda 函数**

```sql title=Query
SELECT arrayAvg(x, y -> x*y, [2, 3], [2, 3]) AS res;
```

```response title=Response
6.5
```
## arrayCompact {#arrayCompact}

引入于：v20.1

**语法**

```sql
arrayCompact(arr)
```

**参数**

- `arr` — 要去重的数组。 [`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回不包含重复值的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

```response title=Response
[1,nan,2,3]
```
## arrayDistinct {#arrayDistinct}

引入于：v1.1

**语法**

```sql
arrayDistinct(arr)
```

**参数**

- `arr` — 需要提取不同元素的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回包含不同元素的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

```response title=Response
[1,2,3]
```
## arrayElement {#arrayElement}

引入于：v1.1

**语法**

```sql
arrayElement(arr, n)
```

**参数**

- `arr` — 要搜索的数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `n` — 要获取的元素位置。 [`(U)Int*`](/sql-reference/data-types/int-uint)。

**返回值**

返回由提供的数组参数组成的单个组合数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayElement(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**负索引**

```sql title=Query
SELECT arrayElement(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**使用 [n] 的表示法**

```sql title=Query
SELECT arr[2] FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**索引超出数组边界**

```sql title=Query
SELECT arrayElement(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
0
```
## arrayElementOrNull {#arrayElementOrNull}

引入于：v1.1

**语法**

```sql
arrayElementOrNull(arrays)
```

**参数**

- `arrays` — 任意数量的 [`Array`](/sql-reference/data-types/array) 类型参数。

**返回值**

返回由提供的数组参数组成的单个组合数组。

**示例**

**用法示例**

```sql title=Query
SELECT arrayElementOrNull(arr, 2) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
2
```

**负索引**

```sql title=Query
SELECT arrayElementOrNull(arr, -1) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
3
```

**索引超出数组边界**

```sql title=Query
SELECT arrayElementOrNull(arr, 4) FROM (SELECT [1, 2, 3] AS arr)
```

```response title=Response
NULL
```
## arrayEnumerate {#arrayEnumerate}

引入于：v1.1

**语法**

```sql
arrayEnumerate(arr)
```

**参数**

- `arr` — 要枚举的数组。 [`Array`](/sql-reference/data-types/array)。

**返回值**

返回数组 `[1, 2, 3, ..., length(arr)]`。 Array(UInt32)

**示例**

**与 ARRAY JOIN 的基本示例**

```sql title=Query
CREATE TABLE test
(
    `id` UInt8,
    `tag` Array(String),
    `version` Array(String)
)
ENGINE = MergeTree
ORDER BY id;

INSERT INTO test VALUES (1, ['release-stable', 'dev', 'security'], ['2.4.0', '2.6.0-alpha', '2.4.0-sec1']);

SELECT
    id,
    tag,
    version,
    seq
FROM test
ARRAY JOIN
    tag,
    version,
    arrayEnumerate(tag) AS seq
```

```response title=Response
┌─id─┬─tag────────────┬─version─────┬─seq─┐
│  1 │ release-stable │ 2.4.0       │   1 │
│  1 │ dev            │ 2.6.0-alpha │   2 │
│  1 │ security       │ 2.4.0-sec1  │   3 │
└────┴────────────────┴─────────────┴─────┘
```
## arrayEnumerateUniqRanked {#arrayEnumerateUniqRanked}

引入于：v20.1

**语法**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**参数**

- `clear_depth` — 分别对指定级别的元素进行枚举。正整数 (Integer)，小于或等于 `max_arr_depth`。
- `arr` — 要枚举的 N 维数组。 [Array](/sql-reference/data-types/array)。
- `max_array_depth` — 最大有效深度。正整数 (Integer)，小于或等于 `arr` 的深度。

**返回值**

返回与 `arr` 大小相同的 N 维数组，每个元素显示该元素相对于同一值的其他元素的位置。

**示例**

**示例 1**

```sql title=Query
With `clear_depth=1` and `max_array_depth=1`, the result of `arrayEnumerateUniqRanked` is identical to that which [`arrayEnumerateUniq`](#arrayenumerateuniq) would give for the same array.

```sql
SELECT arrayEnumerateUniqRanked(1, [1,2,1], 1);
```
```

```response title=Response
[1,1,2]
```

**示例 2**

```sql title=Query
With `clear_depth=1` and `max_array_depth=1`, the result of `arrayEnumerateUniqRanked` is identical to that which [`arrayEnumerateUniq`](#arrayenumerateuniq) would give for the same array.

```sql
SELECT arrayEnumerateUniqRanked(1, [[1,2,3],[2,2,1],[3]], 2);", "[[1,1,1],[2,3,2],[2]]
```
```

```response title=Response
[1,1,2]
```

**示例 3**

```sql title=Query
In this example, `arrayEnumerateUniqRanked` is used to obtain an array indicating, for each element of the multidimensional array, what its position is among elements of the same value. For the first row of the passed array,`[1,2,3]`, the corresponding result is `[1,1,1]`, indicating that this is the first time `1`,`2` and `3` are encountered. For the second row of the provided array,`[2,2,1]`, the corresponding result is `[2,3,3]`, indicating that `2` is encountered for a second and third time, and `1` is encountered for the second time. Likewise, for the third row of the provided array `[3]` the corresponding result is `[2]` indicating that `3` is encountered for the second time.

```sql
SELECT arrayEnumerateUniqRanked(1, [[1,2,3],[2,2,1],[3]], 2);
```
```

```response title=Response
[[1,1,1],[2,3,2],[2]]
```

**示例 4**

```sql title=Query
Changing `clear_depth=2`, results in elements being enumerated separately for each row.

```sql
SELECT arrayEnumerateUniqRanked(2, [[1,2,3],[2,2,1],[3]], 2);
```
```

```response title=Response
[[1,1,1],[1,2,1],[1]]
```
## arrayExists {#arrayExists}

引入于：v1.1

**语法**

```sql
arrayExists(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

如果 lambda 函数对至少一个元素返回 true，则返回 `1`，否则返回 `0`。 [`UInt8`](/sql-reference/data-types/int-uint)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayExists(x, y -> x=y, [1, 2, 3], [0, 0, 0])
```

```response title=Response
0
```
## arrayFill {#arrayFill}

引入于：v20.1

**语法**

```sql
arrayFill(func(x [, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x [, y1, ..., yN])` — lambda 函数 `func(x [, y1, y2, ... yN]) → F(x [, y1, y2, ... yN])`，操作源数组 (`x`) 和条件数组 (`y`) 元素。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**单个数组的示例**

```sql title=Query
SELECT arrayFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1,1,2,2]
```

**两个数组的示例**

```sql title=Query
SELECT arrayFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res
```

```response title=Response
[5,5,6,6]
```
## arrayFilter {#arrayFilter}

引入于：v1.1

**语法**

```sql
arrayFilter(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])]
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组的子集。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**示例 1**

```sql title=Query
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```response title=Response
['abc World']
```

**示例 2**

```sql title=Query
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```response title=Response
[2]
```
## arrayFirst {#arrayFirst}

引入于：v1.1

**语法**

```sql
arrayFirst(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中第一个使 `λ` 为 true 的元素，否则返回 T 的默认值。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**没有匹配**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayFirstIndex {#arrayFirstIndex}

引入于：v1.1

**语法**

```sql
arrayFirstIndex(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中第一个使 `func` 为 true 的元素的索引，否则返回 `0`。 [`UInt32`](/sql-reference/data-types/int-uint)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
2
```

**没有匹配**

```sql title=Query
SELECT arrayFirstIndex(x, y -> x=y, ['a', 'b', 'c'], ['d', 'e', 'f'])
```

```response title=Response
0
```
## arrayFirstOrNull {#arrayFirstOrNull}

引入于：v1.1

**语法**

```sql
arrayFirstOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中第一个使 `func` 为 true 的元素，否则返回 `NULL`。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, ['a', 'b', 'c'], ['c', 'b', 'a'])
```

```response title=Response
b
```

**没有匹配**

```sql title=Query
SELECT arrayFirstOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayFlatten {#arrayFlatten}

引入于：v20.1

**语法**

```sql
arrayFlatten(arr)
```

**参数**

- `arr` — 多维数组。 [`Array(T)`](/sql-reference/data-types/array)(`Array`)

**返回值**

返回从多维数组平铺出的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFlatten([[[1]], [[2], [3]]]);
```

```response title=Response
[1,2,3]
```
## arrayFold {#arrayFold}

引入于：v23.10

**语法**

```sql
arrayFold(λ(acc, x1 [, x2, x3, ... xN]), arr1 [, arr2, arr3, ... arrN], acc)
```

**参数**

- `λ(x, x1 [, x2, x3, ... xN])` — lambda 函数 `λ(acc, x1 [, x2, x3, ... xN]) → F(acc, x1 [, x2, x3, ... xN])`，其中 `F` 是应用于 `acc` 和来自 `x` 的数组值的操作，`acc` 的结果可以被重用。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `arr1 [, arr2, arr3, ... arrN]` — N 个要操作的数组。 [`Array(T)`](/sql-reference/data-types/array)
- `acc` — 与 Lambda 函数返回类型相同的累加器值。

**返回值**

返回最终的 `acc` 值。

**示例**

**用法示例**

```sql title=Query
SELECT arrayFold(acc,x -> acc + x*2, [1, 2, 3, 4], 3::Int64) AS res;
```

```response title=Response
23
```

**斐波那契数列**

```sql title=Query
SELECT arrayFold(acc, x -> (acc.2, acc.2 + acc.1),range(number),(1::Int64, 0::Int64)).1 AS fibonacci FROM numbers(1,10);
```

```response title=Response
┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**使用多个数组的示例**

```sql title=Query
SELECT arrayFold(
(acc, x, y) -> acc + (x * y),
[1, 2, 3, 4],
[10, 20, 30, 40],
0::Int64
) AS res;
```

```response title=Response
300
```
## arrayIntersect {#arrayIntersect}

引入于：v1.1

**语法**

```sql
arrayIntersect(arr, arr1, ..., arrN)
```

**参数**

- `arrN` — 用于创建新数组的 N 个数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个包含所有 N 个数组中存在的不重复元素的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT
arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

```response title=Response
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arrayJaccardIndex {#arrayJaccardIndex}

引入于：v23.7

**语法**

```sql
arrayJaccardIndex(arr_x, arr_y)
```

**参数**

- `arr_x` — 第一个数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `arr_y` — 第二个数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回 `arr_x` 和 `arr_y` 的 Jaccard 指数。[Float64](/sql-reference/data-types/float)

**示例**

**用法示例**

```sql title=Query
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

```response title=Response
0.3333333333333333
```
## arrayJoin {#arrayJoin}

引入于：v1.1

**语法**

```sql
arrayJoin(arr)
```

**参数**

- `arr` — 要展开的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回从 `arr` 展开的行集合。

**示例**

**基本用法**

```sql title=Query
SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src
```

```response title=Response
┌─dst─┬─\'Hello\'─┬─src─────┐
│   1 │ Hello     │ [1,2,3] │
│   2 │ Hello     │ [1,2,3] │
│   3 │ Hello     │ [1,2,3] │
└─────┴───────────┴─────────┘
```

**arrayJoin 影响查询的所有部分**

```sql title=Query
The `arrayJoin` function affects all sections of the query, including the `WHERE` section. Notice the result 2, even though the subquery returned 1 row.

```sql
SELECT sum(1) AS impressions
FROM
(
    SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities
)
WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin'];
```
```

```response title=Response
┌─impressions─┐
│           2 │
└─────────────┘
```

**使用多个 arrayJoin 函数**

```sql title=Query
A query can use multiple `arrayJoin` functions. In this case, the transformation is performed multiple times and the rows are multiplied.

```sql
SELECT
    sum(1) AS impressions,
    arrayJoin(cities) AS city,
    arrayJoin(browsers) AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           2 │ Istanbul │ Chrome  │
│           1 │ Istanbul │ Firefox │
│           2 │ Berlin   │ Chrome  │
│           1 │ Berlin   │ Firefox │
│           2 │ Bobruisk │ Chrome  │
│           1 │ Bobruisk │ Firefox │
└─────────────┴──────────┴─────────┘
```

**由于优化导致的意外结果**

```sql title=Query
Using multiple `arrayJoin` with the same expression may not produce the expected result due to optimizations.
For these cases, consider modifying the repeated array expression with extra operations that do not affect join result.
e.g. `arrayJoin(arraySort(arr))`, `arrayJoin(arrayConcat(arr, []))`

```sql
SELECT
    arrayJoin(dice) as first_throw,
    /* arrayJoin(dice) as second_throw */ -- is technically correct, but will annihilate result set
    arrayJoin(arrayConcat(dice, [])) as second_throw -- intentionally changed expression to force re-evaluation
FROM (
    SELECT [1, 2, 3, 4, 5, 6] as dice
);
```
```

```response title=Response
┌─first_throw─┬─second_throw─┐
│           1 │            1 │
│           1 │            2 │
│           1 │            3 │
│           1 │            4 │
│           1 │            5 │
│           1 │            6 │
│           2 │            1 │
│           2 │            2 │
│           2 │            3 │
│           2 │            4 │
│           2 │            5 │
│           2 │            6 │
│           3 │            1 │
│           3 │            2 │
│           3 │            3 │
│           3 │            4 │
│           3 │            5 │
│           3 │            6 │
│           4 │            1 │
│           4 │            2 │
│           4 │            3 │
│           4 │            4 │
│           4 │            5 │
│           4 │            6 │
│           5 │            1 │
│           5 │            2 │
│           5 │            3 │
│           5 │            4 │
│           5 │            5 │
│           5 │            6 │
│           6 │            1 │
│           6 │            2 │
│           6 │            3 │
│           6 │            4 │
│           6 │            5 │
│           6 │            6 │
└─────────────┴──────────────┘
```

**使用 ARRAY JOIN 语法**

```sql title=Query
Note the [`ARRAY JOIN`](../statements/select/array-join.md) syntax in the `SELECT` query below, which provides broader possibilities.
`ARRAY JOIN` allows you to convert multiple arrays with the same number of elements at a time.

```sql
SELECT
    sum(1) AS impressions,
    city,
    browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
ARRAY JOIN
    cities AS city,
    browsers AS browser
GROUP BY
    2,
    3
```
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```

**使用元组**

```sql title=Query
You can also use [Tuple](../data-types/tuple.md):

```sql
SELECT
    sum(1) AS impressions,
    (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city,
    t.2 AS browser
FROM
(
    SELECT
        ['Istanbul', 'Berlin', 'Bobruisk'] AS cities,
        ['Firefox', 'Chrome', 'Chrome'] AS browsers
)
GROUP BY
    2,
    3
```
```

```response title=Response
┌─impressions─┬─city─────┬─browser─┐
│           1 │ Istanbul │ Firefox │
│           1 │ Berlin   │ Chrome  │
│           1 │ Bobruisk │ Chrome  │
└─────────────┴──────────┴─────────┘
```
## arrayLast {#arrayLast}

引入于：v1.1

**语法**

```sql
arrayLast(func(x[, y1, ..., yN]), source[, cond1, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1, ... , condN]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中最后一个使 `func` 为 true 的元素，否则返回 T 的默认值。

**示例**

**用法示例**

```sql title=Query
SELECT arrayLast(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**没有匹配**

```sql title=Query
SELECT arrayFirst(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
0 UInt8
```
## arrayLastOrNull {#arrayLastOrNull}

引入于：v1.1

**语法**

```sql
arrayLastOrNull(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x [, y1, ..., yN])` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中最后一个使 `λ` 不为 true 的元素，否则返回 `NULL`。

**示例**

**用法示例**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, ['a', 'b', 'c'], ['a', 'b', 'c'])
```

```response title=Response
c
```

**没有匹配**

```sql title=Query
SELECT arrayLastOrNull(x, y -> x=y, [0, 1, 2], [3, 3, 3]) AS res, toTypeName(res)
```

```response title=Response
NULL Nullable(UInt8)
```
## arrayLevenshteinDistance {#arrayLevenshteinDistance}

引入于：v25.4

**语法**

```sql
arrayLevenshteinDistance(from, to)
```

**参数**

- `from` — 第一个数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `to` — 第二个数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

第一个数组与第二个数组之间的 Levenshtein 距离。 [`Float64`](/sql-reference/data-types/float)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

```response title=Response
1
```
## arrayLevenshteinDistanceWeighted {#arrayLevenshteinDistanceWeighted}

引入于：v25.4

**语法**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**参数**

- `from` — 第一个数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `to` — 第二个数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `from_weights` — 第一个数组的权重。 [`Array(Float32)`](/sql-reference/data-types/array)。
- `to_weights` — 第二个数组的权重。 [`Array(Float32)`](/sql-reference/data-types/array)。

**返回值**

具有自定义权重的 Levenshtein 距离，第一个数组和第二个数组的每个元素。 [`Float64`](/sql-reference/data-types/float)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

```response title=Response
14
```
## arrayMap {#arrayMap}

引入于：v1.1

**语法**

```sql
arrayMap(func, arr)
```

**参数**

- `func` — 操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `arr` — 要处理的 N 个数组。 [Array(T)](/sql-reference/data-types/array)。

**返回值**

返回 lambda 结果组成的数组。 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```response title=Response
[3,4,5]
```

**从不同数组创建元素的元组**

```sql title=Query
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```response title=Response
[(1,4),(2,5),(3,6)]
```
## arrayMax {#arrayMax}

引入于：v21.1

**语法**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中的最大元素，或者如果提供则返回 lambda 结果的最小元素。

**示例**

**基本示例**

```sql title=Query
SELECT arrayMax([5, 3, 2, 7]);
```

```response title=Response
7
```

**与 lambda 函数的用法**

```sql title=Query
SELECT arrayMax(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
12
```
## arrayMin {#arrayMin}

引入于：v21.1

**语法**

```sql
arrayMin([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中的最小元素，或者如果提供则返回 lambda 结果的最小元素。

**示例**

**基本示例**

```sql title=Query
SELECT arrayMin([5, 3, 2, 7]);
```

```response title=Response
2
```

**与 lambda 函数的用法**

```sql title=Query
SELECT arrayMin(x, y -> x/y, [4, 8, 12, 16], [1, 2, 1, 2]);
```

```response title=Response
4
```
## arrayNormalizedGini {#arrayNormalizedGini}

引入于：v25.1

**语法**

```sql
arrayNormalizedGini(predicted, label)
```

**参数**

- `predicted` — 预测值。 [`Array(T)`](/sql-reference/data-types/array)。
- `label` — 实际值。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回一个元组，包含预测值的 Gini 系数，归一化值的 Gini 系数，和归一化 Gini 系数（= 前两个 Gini 系数的比率）。 [Tuple(Float64, Float64, Float64)](/sql-reference/data-types/tuple)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7],[6, 1, 0, 2]);
```

```response title=Response
(0.18055555555555558,0.2638888888888889,0.6842105263157896)
```
## arrayPartialReverseSort {#arrayPartialReverseSort}

引入于：v23.2

**语法**

```sql
arrayPartialReverseSort([f,] arr [, arr1, ... ,arrN], limit)
```

**参数**

- `f(arr[, arr1, ... ,arrN])` — 应用于数组 `x` 元素的 lambda 函数。
- `arr` — 要排序的数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `arr1, ... ,arrN` — 当 `f` 接受多个参数时的 N 个额外数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `limit` — 排序将进行的索引值。 [`(U)Int*`](/sql-reference/data-types/int-uint)`]

**返回值**

返回与原始数组大小相同的数组，其中 `[1..limit]` 范围内的元素按降序排序。剩余元素 `(limit..N]` 的顺序不确定。

**示例**

**simple_int**

```sql title=Query
SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])
```

```response title=Response
[9,5,1,3]
```

**simple_string**

```sql title=Query
SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['lasso','gladly','expenses','embolism']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[9,5]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[1,3,5,9]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[0,1,2]
```
## arrayPartialShuffle {#arrayPartialShuffle}

引入于：v23.2

**语法**

```sql
arrayPartialShuffle(arr [, limit[, seed]])
```

**参数**

- `arr` — 要打乱的数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `seed` — 可选。用于随机数生成的种子。如果未提供，则使用随机值。 [`(U)Int*`](../data-types/int-uint.md)。
- `limit` — 可选。在范围 `[1..N]` 内限制元素交换的数量。 [`(U)Int*`](../data-types/int-uint.md)。

**返回值**

部分打乱后的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**no_limit1**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 0)
```

```response title=Response
[2,4,3,1]
```

**no_limit2**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4])
```

```response title=Response
[4,1,3,2]
```

**random_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2)
```

```response title=Response
[3,4,1,2]
```

**explicit_seed**

```sql title=Query
SELECT arrayPartialShuffle([1, 2, 3, 4], 2, 41)
```

```response title=Response
[3,2,1,4]
```

**materialize**

```sql title=Query
SELECT arrayPartialShuffle(materialize([1, 2, 3, 4]), 2, 42), arrayPartialShuffle([1, 2, 3], 2, 42) FROM numbers(10)
```

```response title=Response
┌─arrayPartial⋯4]), 2, 42)─┬─arrayPartial⋯ 3], 2, 42)─┐
│ [3,2,1,4]                │ [3,2,1]                  │
│ [3,2,1,4]                │ [3,2,1]                  │
│ [4,3,2,1]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,4,1,2]                │ [3,2,1]                  │
│ [1,2,3,4]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [1,4,3,2]                │ [3,2,1]                  │
│ [3,1,2,4]                │ [3,2,1]                  │
│ [1,3,2,4]                │ [3,2,1]                  │
└──────────────────────────┴──────────────────────────┘
```
## arrayPartialSort {#arrayPartialSort}

引入于：v23.2

**语法**

```sql
arrayPartialSort([f,] arr [, arr1, ... ,arrN], limit)
```

**参数**

- `f(arr[, arr1, ... ,arrN])` — 应用于数组 `x` 元素的 lambda 函数。
- `arr` — 要排序的数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `arr1, ... ,arrN` — 当 `f` 接受多个参数时的 N 个额外数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `limit` — 排序将进行的索引值。 [`(U)Int*`](/sql-reference/data-types/int-uint)`]

**返回值**

返回与原始数组大小相同的数组，其中 `[1..limit]` 范围内的元素按升序排序。剩余元素 `(limit..N]` 的顺序不确定。

**示例**

**simple_int**

```sql title=Query
SELECT arrayPartialSort(2, [5, 9, 1, 3])
```

```response title=Response
[1,3,5,9]
```

**simple_string**

```sql title=Query
SELECT arrayPartialSort(2, ['expenses','lasso','embolism','gladly'])
```

```response title=Response
['embolism','expenses','gladly','lasso']
```

**retain_sorted**

```sql title=Query
SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)
```

```response title=Response
[1,3]
```

**lambda_simple**

```sql title=Query
SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])
```

```response title=Response
[9,5,1,3]
```

**lambda_complex**

```sql title=Query
SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res
```

```response title=Response
[2,1,0]
```
## arrayPopBack {#arrayPopBack}

引入于：v1.1

**语法**

```sql
arrayPopBack(arr)
```

**参数**

- `arr` — 要移除最后一个元素的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回与 `arr` 相同但最后一个元素被移除的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```response title=Response
[1,2]
```
## arrayPopFront {#arrayPopFront}

引入于：v1.1

**语法**

```sql
arrayPopFront(arr)
```

**参数**

- `arr` — 要移除第一个元素的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回与 `arr` 相同但第一个元素被移除的数组。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```response title=Response
[2,3]
```
## arrayProduct {#arrayProduct}

引入于：v21.1

**语法**

```sql
arrayProduct([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。操作源数组 (`x`) 和条件数组 (`y`) 元素的 lambda 函数。 [Lambda 函数](/sql-reference/functions/overview#arrow-operator-and-lambda)。
- `source_arr` — 要处理的源数组 [`Array(T)`](/sql-reference/data-types/array)。
- `[, cond1_arr, ... , condN_arr]` — 可选。提供额外参数给 lambda 函数的 N 个条件数组。 [`Array(T)`](/sql-reference/data-types/array)。

**返回值**

返回源数组中元素的乘积，或者如果提供则返回 lambda 结果的乘积。 [`Float64`](/sql-reference/data-types/float)。

**示例**

**基本示例**

```sql title=Query
SELECT arrayProduct([1, 2, 3, 4]);
```

```response title=Response
24
```

**与 lambda 函数的用法**

```sql title=Query
SELECT arrayProduct(x, y -> x+y, [2, 2], [2, 2]) AS res;
```

```response title=Response
16
```
## arrayPushBack {#arrayPushBack}

引入于：v1.1

**语法**

```sql
arrayPushBack(arr, x)
```

**参数**

- `arr` — 要在其末尾添加值 `x` 的数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `x` — 
- 要添加到数组末尾的单个值。 [`Array(T)`](/sql-reference/data-types/array)。

:::note
- 仅数字可以添加到数字数组中，且仅字符串可以添加到字符串数组中。
- 在添加数字时，ClickHouse 会自动将 `x` 的类型设置为数组的数据类型。
- 可以为 `NULL`。该函数将 `NULL` 元素添加到数组，并且数组元素的类型将转换为 `Nullable`。

有关 ClickHouse 中数据类型的更多信息，请参见 [数据类型](/sql-reference/data-types)。
:::
    

**返回值**

返回与 `arr` 相同的数组，但在数组末尾附加了一个值 `x`。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayPushBack(['a'], 'b') AS res;
```

```response title=Response
['a','b']
```
## arrayPushFront {#arrayPushFront}

引入于：v1.1

**语法**

```sql
arrayPushFront(arr, x)
```

**参数**

- `arr` — 要在其前面添加值 `x` 的数组。 [`Array(T)`](/sql-reference/data-types/array)。
- `x` — 
- 要添加到数组开头的单个值。 [`Array(T)`](/sql-reference/data-types/array)。

:::note
- 仅数字可以添加到数字数组中，且仅字符串可以添加到字符串数组中。
- 在添加数字时，ClickHouse 会自动将 `x` 的类型设置为数组的数据类型。
- 可以为 `NULL`。该函数将 `NULL` 元素添加到数组，并且数组元素的类型将转换为 `Nullable`。

有关 ClickHouse 中数据类型的更多信息，请参见 [数据类型](/sql-reference/data-types)。
:::
    

**返回值**

返回与 `arr` 相同的数组，但在数组开头附加了一个值 `x`。 [`Array(T)`](/sql-reference/data-types/array)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayPushFront(['b'], 'a') AS res;
```

```response title=Response
['a','b']
```
## arrayROCAUC {#arrayROCAUC}

引入于：v20.4

**语法**

```sql
arrayROCAUC(scores, labels[, scale[, partial_offsets]])
```

**参数**

- `scores` — 模型提供的评分预测。 [`Array(T)`](/sql-reference/data-types/array) 的 [整数](../data-types/int-uint.md) 或 [浮点数](../data-types/float.md)。
- `labels` — 样本的标签，通常为正样本的 1 和负样本的 0。 [Array](/sql-reference/data-types/array) 的 [整数](../data-types/int-uint.md) 或 [枚举](../data-types/enum.md)。
- `scale` — 决定是否返回归一化区域。如果为 false，则返回 TP（真阳性） x FP（假阳性）曲线下的区域。默认值： true。 [Bool](../data-types/boolean.md)。可选。
- `partial_offsets` — 
- 用于计算 ROC 曲线下部分区域的四个非负整数数组（相当于 ROC 空间的垂直带），而不是整个 AUC。此选项对 ROC AUC 的分布式计算很有用。数组必须包含以下元素 [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]。 [Array](/sql-reference/data-types/array) 的非负 [整数](../data-types/int-uint.md)。可选。
    - `higher_partitions_tp`: 在高分分区中正标签的数量。
    - `higher_partitions_fp`: 在高分分区中负标签的数量。
    - `total_positives`: 整个数据集中正样本的总数。
    - `total_negatives`: 整个数据集中负样本的总数。

::::note
当使用 `arr_partial_offsets` 时，`arr_scores` 与 `arr_labels` 应仅为整个数据集的一个分区，包含一个分数区间。
数据集应被划分为连续的分区，每个分区包含分数落在特定范围内的数据子集。
例如：
- 一个分区可以包含所有在范围 [0, 0.5) 的分数。
- 另一个分区可以包含范围 [0.5, 1.0] 的分数。
::::


**返回值**

返回受试者工作特征 (ROC) 曲线下的区域。 [Float64](../data-types/float.md)。

**示例**

**用法示例**

```sql title=Query
SELECT arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

```response title=Response
0.75
```
## arrayRandomSample {#arrayRandomSample}

引入时间：v23.10

**语法**

```sql
arrayRandomSample(arr, samples)
```

**参数**

- `arr` — 输入数组或多维数组，以从中抽样元素。 ([`Array(T)`](/sql-reference/data-types/array)).
- `samples` — 随机样本中包含的元素数量 ([`(U)Int*`](../data-types/int-uint.md)).

**返回值**

返回一个包含输入数组中元素的随机样本的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

```response title=Response
['cherry','apple']
```

**使用多维数组**

```sql title=Query
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

```response title=Response
[[3,4],[5,6]]
```
## arrayReduce {#arrayReduce}

引入时间：v1.1

**语法**

```sql
arrayReduce(agg_f, arr1 [, arr2, ... , arrN)]
```

**参数**

- `agg_f` — 需要为一个常量的聚合函数的名称 [String](/sql-reference/data-types/string).
- `arr1 [, arr2, ... , arrN)]` — N 个数组，对应于 `agg_f` 的参数。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回聚合函数的结果。

**示例**

**用法示例**

```sql title=Query
SELECT arrayReduce('max', [1, 2, 3]);
```

```response title=Response
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

**使用多个参数的聚合函数示例**

```sql title=Query
If an aggregate function takes multiple arguments, then this function must be applied to multiple arrays of the same size.

```sql
SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```
```

```response title=Response
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

**使用参数化聚合函数的示例**

```sql title=Query
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

```response title=Response
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```
## arrayReduceInRanges {#arrayReduceInRanges}

引入时间：v20.4

**语法**

```sql
arrayReduceInRanges(agg_f, ranges, arr1 [, arr2, ... ,arrN)]
```

**参数**

- `agg_f` — 要使用的聚合函数的名称。 [String](/sql-reference/data-types/string)
- `ranges` — 聚合的范围。一个包含元组的数组 `(i, r)`，包含从 `i` 开始的索引和聚合的范围 `r`，[`Array(T)`](/sql-reference/data-types/array)([`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple))
- `arr1 [, arr2, ... ,arrN)]` — 作为聚合函数参数的 N 个数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个包含在指定范围内的聚合函数结果的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

```response title=Response
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```
## arrayResize {#arrayResize}

引入时间：v1.1

**语法**

```sql
arrayResize(arr, size[, extender])
```

**参数**

- `arr` — 要调整大小的数组。 [Array(T)](/sql-reference/data-types/array)
- `size` — 
- 新数组的长度。
如果 `size` 小于原始数组的大小，则数组将从右侧截断。
如果 `size` 大于数组的初始大小，则数组将向右扩展，并使用 `extender` 值或数组项的数据类型的默认值。

- `extender` — 用于扩展数组的值。可以是 `NULL`。

**返回值**

长度为 `size` 的数组。 [Array(T)](/sql-reference/data-types/array).

**示例**

**示例 1**

```sql title=Query
SELECT arrayResize([1], 3);
```

```response title=Response
[1,0,0]
```

**示例 2**

```sql title=Query
SELECT arrayResize([1], 3, NULL);
```

```response title=Response
[1,NULL,NULL]
```
## arrayReverse {#arrayReverse}

引入时间：v1.1

**语法**

```sql
arrayReverse(arr)
```

**参数**

- `arr` — 要反转的数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回与原数组大小相同的数组，元素顺序已反转。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayReverse([1, 2, 3])
```

```response title=Response
[3,2,1]
```
## arrayReverseFill {#arrayReverseFill}

引入时间：v20.1

**语法**

```sql
arrayReverseFill(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 一个在源数组的元素 (`x`) 和条件数组 (`y`) 上进行操作的 lambda 函数。 [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — 要处理的源数组 [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — 可选。 N 个条件数组，为 lambda 函数提供额外的参数。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个数组，其元素由 lambda 的结果替换了源数组的元素。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**使用单个数组的示例**

```sql title=Query
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 2, null]) AS res
```

```response title=Response
[1,2,2,NULL]
```

**使用两个数组的示例**

```sql title=Query
SELECT arrayReverseFill(x, y, z -> x > y AND x < z, [5, 3, 6, 2], [4, 7, 1, 3], [10, 2, 8, 5]) AS res;
```

```response title=Response
[5,6,6,2]
```
## arrayReverseSort {#arrayReverseSort}

引入时间：v1.1

**语法**

```sql
arrayReverseSort([f,] arr [, arr1, ... ,arrN)
```

**参数**

- `f(y1[, y2 ... yN])` — 要应用于数组 `x` 元素的 lambda 函数。
- `arr` — 要排序的数组。 [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — 可选。当 `f` 接受多个参数时，N 个额外数组。

**返回值**

如果未提供 lambda 函数，则返回按降序排列的数组 `x`，否则返回根据提供的 lambda 函数逻辑排序后再反转的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**示例 1**

```sql title=Query
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```response title=Response
[5,3,4]
```

**示例 2**

```sql title=Query
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```response title=Response
[4,3,5]
```
## arrayReverseSplit {#arrayReverseSplit}

引入时间：v20.1

**语法**

```sql
arrayReverseSplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 一个在源数组的元素 (`x`) 和条件数组 (`y`) 上进行操作的 lambda 函数。 [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — 可选。 N 个条件数组，为 lambda 函数提供额外的参数。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个数组的数组。 [`Array(Array(T))`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1], [2, 3, 4], [5]]
```
## arrayRotateLeft {#arrayRotateLeft}

引入时间：v23.8

**语法**

```sql
arrayRotateLeft(arr, n)
```

**参数**

- `arr` — 要旋转元素的数组。[`Array(T)`](/sql-reference/data-types/array).
- `n` — 旋转的元素数量。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**返回值**

一个向左旋转指定数量元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```

**n 的负值**

```sql title=Query
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```
## arrayRotateRight {#arrayRotateRight}

引入时间：v23.8

**语法**

```sql
arrayRotateRight(arr, n)
```

**参数**

- `arr` — 要旋转元素的数组。[`Array(T)`](/sql-reference/data-types/array).
- `n` — 旋转的元素数量。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).

**返回值**

一个向右旋转指定数量元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[5,6,1,2,3,4]
```

**n 的负值**

```sql title=Query
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,1,2]
```
## arrayShiftLeft {#arrayShiftLeft}

引入时间：v23.8

**语法**

```sql
arrayShiftLeft(arr, n[, default])
```

**参数**

- `arr` — 要移动元素的数组。[`Array(T)`](/sql-reference/data-types/array).
- `n` — 要移动的元素数量。[`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).
- `default` — 可选。新元素的默认值。

**返回值**

一个向左移动指定数量元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**n 的负值**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**使用默认值**

```sql title=Query
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[3,4,5,6,42,42]
```
## arrayShiftRight {#arrayShiftRight}

引入时间：v23.8

**语法**

```sql
arrayShiftRight(arr, n[, default])
```

**参数**

- `arr` — 要移动元素的数组。 [`Array(T)`](/sql-reference/data-types/array).
- `n` — 要移动的元素数量。 [`(U)Int8/16/32/64`](/sql-reference/data-types/int-uint).
- `default` — 可选。新元素的默认值。

**返回值**

一个向右移动指定数量元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arrayShiftRight([1,2,3,4,5,6], 2) as res;
```

```response title=Response
[0,0,1,2,3,4]
```

**n 的负值**

```sql title=Query
SELECT arrayShiftRight([1,2,3,4,5,6], -2) as res;
```

```response title=Response
[3,4,5,6,0,0]
```

**使用默认值**

```sql title=Query
SELECT arrayShiftRight([1,2,3,4,5,6], 2, 42) as res;
```

```response title=Response
[42,42,1,2,3,4]
```
## arrayShingles {#arrayShingles}

引入时间：v24.1

**语法**

```sql
arrayShingles(arr, l)
```

**参数**

- `arr` — 要生成 shingles 的数组。 [`Array(T)`](/sql-reference/data-types/array).
- `l` — 每个 shingle 的长度。 [`(U)Int*`](/sql-reference/data-types/int-uint)

**返回值**

生成的 shingles 数组。 [`Array(T)`](/sql-reference/data-types/array)

**示例**

**用法示例**

```sql title=Query
SELECT arrayShingles([1,2,3,4], 3) as res;
```

```response title=Response
[[1,2,3],[2,3,4]]
```
## arrayShuffle {#arrayShuffle}

引入时间：v23.2

**语法**

```sql
arrayShuffle(arr [, seed])
```

**参数**

- `arr` — 要打乱的数组。 [`Array(T)`](/sql-reference/data-types/array).
- `seed (可选)` — 可选。与随机数生成一起使用的种子。如果未提供，则使用随机种子。 [`(U)Int*`](../data-types/int-uint.md).

**返回值**

打乱元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**没有种子的示例（不稳定的结果）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4]);
```

```response title=Response
[1,4,2,3]
```

**没有种子的示例（稳定的结果）**

```sql title=Query
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

```response title=Response
[3,2,1,4]
```
## arraySimilarity {#arraySimilarity}

引入时间：v25.4

**语法**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**参数**

- `from` — 第一个数组
- `to` — 第二个数组
- `from_weights` — 第一个数组的权重
- `to_weights` — 第二个数组的权重

**返回值**

返回两个数组之间的相似度，值在 `0` 和 `1` 之间，基于加权的 Levenshtein 距离。 [`Float64`](/sql-reference/data-types/float).

**示例**

**用法示例**

```sql title=Query
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5]);
```

```response title=Response
0.2222222222222222
```
## arraySlice {#arraySlice}

引入时间：v1.1

**语法**

```sql
arraySlice(arr, offset [, length])
```

**参数**

- `arr` — 要切片的数组。 [`Array(T)`](/sql-reference/data-types/array).
- `offset` — 从数组边缘的缩进。正值表示左侧的偏移，而负值表示右侧的偏移。数组项的编号从 `1` 开始。 [`(U)Int*`](/sql-reference/data-types/int-uint).
- `length` — 所需切片的长度。如果指定负值，函数返回开放切片 `[offset, array_length - length]`。如果省略值，函数返回切片 `[offset, the_end_of_array]`。 [`(U)Int*`](/sql-reference/data-types/int-uint).

**返回值**

返回指定 `offset` 的 `length` 元素的数组切片。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```response title=Response
[2,NULL,4]
```
## arraySort {#arraySort}

引入时间：v1.1

**语法**

```sql
arraySort([f,] arr [, arr1, ... ,arrN])
```

**参数**

- `f(y1[, y2 ... yN])` — 要应用于数组 `x` 元素的 lambda 函数。
- `arr` — 要排序的数组。 [`Array(T)`](/sql-reference/data-types/array)
- `arr1, ..., yN` — 可选。当 `f` 接受多个参数时，N 个额外数组。

**返回值**

如果未提供 lambda 函数，则返回按升序排列的数组 `arr`，否则返回根据提供的 lambda 函数逻辑排序的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**示例 1**

```sql title=Query
SELECT arraySort([1, 3, 3, 0]);
```

```response title=Response
[0,1,3,3]
```

**示例 2**

```sql title=Query
SELECT arraySort(['hello', 'world', '!']);
```

```response title=Response
['!','hello','world']
```

**示例 3**

```sql title=Query
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```response title=Response
[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]
```
## arraySplit {#arraySplit}

引入时间：v20.1

**语法**

```sql
arraySplit(func(x[, y1, ..., yN]), source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 一个在源数组的元素 (`x`) 和条件数组 (`y`) 上进行操作的 lambda 函数。[Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — 要拆分的源数组 [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — 可选。N 个条件数组，为 lambda 函数提供额外的参数。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个数组的数组。 [`Array(Array(T))`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```response title=Response
[[1, 2, 3], [4, 5]]
```
## arraySum {#arraySum}

引入时间：v21.1

**语法**

```sql
arrayMax([func(x[, y1, ..., yN])], source_arr[, cond1_arr, ... , condN_arr])
```

**参数**

- `func(x[, y1, ..., yN])` — 可选。一个在源数组的元素 (`x`) 和条件数组 (`y`) 上进行操作的 lambda 函数。 [Lambda function](/sql-reference/functions/overview#arrow-operator-and-lambda).
- `source_arr` — 要处理的源数组。 [`Array(T)`](/sql-reference/data-types/array).
- `[, cond1_arr, ... , condN_arr]` — 可选。 N 个条件数组，为 lambda 函数提供额外的参数。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回源数组中元素的总和，或返回提供的 lambda 结果的元素总和。

**示例**

**基本示例**

```sql title=Query
SELECT arraySum([1, 2, 3, 4]);
```

```response title=Response
10
```

**与 lambda 函数配合使用的示例**

```sql title=Query
SELECT arraySum(x, y -> x+y, [1, 1, 1, 1], [1, 1, 1, 1]);
```

```response title=Response
8
```
## arraySymmetricDifference {#arraySymmetricDifference}

引入时间：v25.4

**语法**

```sql
arraySymmetricDifference(arr1, arr2, ... , arrN)
```

**参数**

- `arrN` — 从 N 个数组中生成的新数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个不在所有源数组中的不同元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT
arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference;
```

```response title=Response
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```
## arrayUnion {#arrayUnion}

引入时间：v24.10

**语法**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**参数**

- `arrN` — 从 N 个数组生成的新数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个包含源数组中不同元素的数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT
arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

```response title=Response
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```
## arrayUniq {#arrayUniq}

引入时间：v1.1

**语法**

```sql
arrayUniq(arr1[, arr2, ..., arrN])
```

**参数**

- `arr1` — 用于计算独特元素数量的数组。 [`Array(T)`](/sql-reference/data-types/array).
- `[, arr2, ..., arrN] (可选)` — 可选。附加数组，用于计算多个数组中对应位置元素的独特元组数量。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

对于单个参数，返回独特元素数量。对于多个参数，返回由多个数组中对应位置的元素构成的独特元组数量。
[`UInt32`](/sql-reference/data-types/int-uint).

**示例**

**单个参数**

```sql title=Query
SELECT arrayUniq([1, 1, 2, 2])
```

```response title=Response
2
```

**多个参数**

```sql title=Query
SELECT arrayUniq([1, 2, 3, 1], [4, 5, 6, 4])
```

```response title=Response
3
```
## arrayWithConstant {#arrayWithConstant}

引入时间：v20.1

**语法**

```sql
arrayWithConstant(N, x)
```

**参数**

- `length` — 数组中的元素数量。 [`(U)Int*`](/sql-reference/data-types/int-uint).
- `x` — 数组中 `N` 个元素的值，可以是任何类型。

**返回值**

返回具有 `N` 个值为 `x` 的数组。

**示例**

**用法示例**

```sql title=Query
SELECT arrayWithConstant(3, 1)
```

```response title=Response
[1,1,1]
```
## arrayZip {#arrayZip}

引入时间：v20.1

**语法**

```sql
arrayZip(arr1, arr2, ... , arrN)
```

**参数**

- `arr1, arr2, ... , arrN` — N 个要组合成一个数组的数组。 [`Array(T)`](/sql-reference/data-types/array)

**返回值**

返回一个元素来自源数组的元组组合的数组。元组中的数据类型与输入数组的类型相同，并按照数组传递的顺序排列。 [`Array(T)`](/sql-reference/data-types/array)([`Tuple`](/sql-reference/data-types/tuple)).

**示例**

**用法示例**

```sql title=Query
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

```response title=Response
[('a', 5), ('b', 2), ('c', 1)]
```
## arrayZipUnaligned {#arrayZipUnaligned}

引入时间：v20.1

**语法**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**参数**

- `arr1, arr2, ..., arrN` — N 个要组合成一个数组的数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

返回一个元素来自源数组的元组组合的数组。元组中的数据类型与输入数组的类型相同，并按数组传递的顺序排列。 [`Array(T)`](/sql-reference/data-types/array)([`Tuple(T1, T2, ...)`](/sql-reference/data-types/tuple)).

**示例**

**用法示例**

```sql title=Query
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

```response title=Response
[('a', 1),(NULL, 2),(NULL, 3)]
```
## countEqual {#countEqual}

引入时间：v1.1

**语法**

```sql
countEqual(arr, x)
```

**参数**

- `arr` — 要搜索的数组。 [`Array(T)`](/sql-reference/data-types/array).
- `x` — 要计数的数组中的值。可以是任何类型。

**返回值**

返回数组中等于 `x` 的元素数量。 [UInt64](/sql-reference/data-types/int-uint).

**示例**

**用法示例**

```sql title=Query
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```response title=Response
2
```
## empty {#empty}

引入时间：v1.1

**语法**

```sql
empty(arr)
```

**参数**

- `arr` — 输入数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

对于空数组返回 `1`，对于非空数组返回 `0`。 [`UInt8`](../data-types/int-uint.md).

**示例**

**用法示例**

```sql title=Query
SELECT empty([]);
```

```response title=Response
1
```
## emptyArrayDate {#emptyArrayDate}

引入时间：v1.1

**语法**

```sql
emptyArrayDate()
```

**参数**

- `` — 

**返回值**

一个空的日期数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayDate
```

```response title=Response
[]
```
## emptyArrayDateTime {#emptyArrayDateTime}

引入时间：v1.1

**语法**

```sql
emptyArrayDateTime()
```

**参数**

- `` — 

**返回值**

一个空的日期时间数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayDateTime
```

```response title=Response
[]
```
## emptyArrayFloat32 {#emptyArrayFloat32}

引入时间：v1.1

**语法**

```sql
emptyArrayFloat32()
```

**参数**

- `` — 

**返回值**

一个空的 Float32 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayFloat32
```

```response title=Response
[]
```
## emptyArrayFloat64 {#emptyArrayFloat64}

引入时间：v1.1

**语法**

```sql
emptyArrayFloat64()
```

**参数**

- `` — 

**返回值**

一个空的 Float64 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayFloat64
```

```response title=Response
[]
```
## emptyArrayInt16 {#emptyArrayInt16}

引入时间：v1.1

**语法**

```sql
emptyArrayInt16()
```

**参数**

- `` — 

**返回值**

一个空的 Int16 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayInt16
```

```response title=Response
[]
```
## emptyArrayInt32 {#emptyArrayInt32}

引入时间：v1.1

**语法**

```sql
emptyArrayInt32()
```

**参数**

- `` — 

**返回值**

一个空的 Int32 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayInt32
```

```response title=Response
[]
```
## emptyArrayInt64 {#emptyArrayInt64}

引入时间：v1.1

**语法**

```sql
emptyArrayInt64()
```

**参数**

- `` — 

**返回值**

一个空的 Int64 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayInt64
```

```response title=Response
[]
```
## emptyArrayInt8 {#emptyArrayInt8}

引入时间：v1.1

**语法**

```sql
emptyArrayInt8()
```

**参数**

- `` — 

**返回值**

一个空的 Int8 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayInt8
```

```response title=Response
[]
```
## emptyArrayString {#emptyArrayString}

引入时间：v1.1

**语法**

```sql
emptyArrayString()
```

**参数**

- `` — 

**返回值**

一个空的字符串数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayString
```

```response title=Response
[]
```
## emptyArrayToSingle {#emptyArrayToSingle}

引入时间：v1.1

**语法**

```sql
emptyArrayToSingle(arr)
```

**参数**

- `arr` — 一个空数组。 [`Array(T)`](/sql-reference/data-types/array)

**返回值**

一个具有数组默认类型单一值的数组。

**示例**

**基本示例**

```sql title=Query
CREATE TABLE test (
  a Array(Int32),
  b Array(String),
  c Array(DateTime)
)
ENGINE = MergeTree
ORDER BY tuple();

INSERT INTO test VALUES ([], [], []);

SELECT emptyArrayToSingle(a), emptyArrayToSingle(b), emptyArrayToSingle(c) FROM test;
```

```response title=Response
┌─emptyArrayToSingle(a)─┬─emptyArrayToSingle(b)─┬─emptyArrayToSingle(c)───┐
│ [0]                   │ ['']                  │ ['1970-01-01 01:00:00'] │
└───────────────────────┴───────────────────────┴─────────────────────────┘
```
## emptyArrayUInt16 {#emptyArrayUInt16}

引入时间：v1.1

**语法**

```sql
emptyArrayUInt16()
```

**参数**

- `` — 

**返回值**

一个空的 UInt16 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt16
```

```response title=Response
[]
```
## emptyArrayUInt32 {#emptyArrayUInt32}

引入时间：v1.1

**语法**

```sql
emptyArrayUInt32()
```

**参数**

- `` — 

**返回值**

一个空的 UInt32 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt32
```

```response title=Response
[]
```
## emptyArrayUInt64 {#emptyArrayUInt64}

引入时间：v1.1

**语法**

```sql
emptyArrayUInt64()
```

**参数**

- `` — 

**返回值**

一个空的 UInt64 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt64
```

```response title=Response
[]
```
## emptyArrayUInt8 {#emptyArrayUInt8}

引入时间：v1.1

**语法**

```sql
emptyArrayUInt8()
```

**参数**

- `` — 

**返回值**

一个空的 UInt8 数组。 [`Array(T)`](/sql-reference/data-types/array).

**示例**

**用法示例**

```sql title=Query
SELECT emptyArrayUInt8
```

```response title=Response
[]
```
## hasAll {#hasAll}

引入时间：v1.1

**语法**

```sql
hasAll(set, subset)
```

**参数**

- `set` — 具有元素集的任何类型数组。 [`Array`](/sql-reference/data-types/array).
- `subset` — 具有与 `set` 共享公共父类型的元素的任何类型数组，包含应测试为 `set` 的子集的元素。 [`Array`](/sql-reference/data-types/array).

**返回值**

- `1`，如果 `set` 包含来自 `subset` 的所有元素。
- `0`，否则。

如果 set 和 subset 元素没有共享共同的父类型，则引发 `NO_COMMON_TYPE` 异常。

**示例**

**空数组**

```sql title=Query
SELECT hasAll([], [])
```

```response title=Response
1
```

**包含 NULL 值的数组**

```sql title=Query
SELECT hasAll([1, Null], [Null])
```

```response title=Response
1
```

**包含不同类型值的数组**

```sql title=Query
SELECT hasAll([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
1
```

**包含字符串值的数组**

```sql title=Query
SELECT hasAll(['a', 'b'], ['a'])
```

```response title=Response
1
```

**没有公共类型的数组**

```sql title=Query
SELECT hasAll([1], ['a'])
```

```response title=Response
Raises a NO_COMMON_TYPE exception
```

**数组的数组**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])
```

```response title=Response
0
```
## hasAny {#hasAny}

引入时间：v1.1

**语法**

```sql
hasAny(arr_x, arr_y)
```

**参数**

- `arr_x` — 具有元素集的任何类型数组。 [`Array(T)`](/sql-reference/data-types/array).
- `arr_y` — 与数组 `arr_x` 共享公共父类型的任何类型数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

- `1`，如果 `arr_x` 和 `arr_y` 至少有一个相似的元素。
- `0`，否则。

如果两个数组的任何元素没有共享共同的父类型，则引发 `NO_COMMON_TYPE` 异常。

**示例**

**一个数组为空**

```sql title=Query
SELECT hasAny([1], [])
```

```response title=Response
1
```

**包含 NULL 值的数组**

```sql title=Query
SELECT hasAny([Null], [Null, 1])
```

```response title=Response
1
```

**包含不同类型值的数组**

```sql title=Query
SELECT hasAny([-128, 1., 512], [1])
```

```response title=Response
1
```

**没有公共类型的数组**

```sql title=Query
SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```

**数组的数组**

```sql title=Query
SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])
```

```response title=Response
1
```
## hasSubstr {#hasSubstr}

引入时间：v20.6

**语法**

```sql
hasSubstr(arr1, arr2)
```

**参数**

- `arr1` — 具有元素集的任何类型数组。 [`Array(T)`](/sql-reference/data-types/array).
- `arr2` — 具有元素集的任何类型数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

如果数组 `arr1` 包含数组 `arr2`，则返回 `1`。否则，返回 `0`。

**示例**

**两个数组都是空的**

```sql title=Query
SELECT hasSubstr([], [])
```

```response title=Response
1
```

**包含 NULL 值的数组**

```sql title=Query
SELECT hasSubstr([1, Null], [Null])
```

```response title=Response
1
```

**包含不同类型值的数组**

```sql title=Query
SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])
```

```response title=Response
0
```

**包含字符串的数组**

```sql title=Query
SELECT hasSubstr(['a', 'b'], ['a'])
```

```response title=Response
1
```

**有效顺序的数组**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])
```

```response title=Response
1
```

**无效顺序的数组**

```sql title=Query
SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])
```

```response title=Response
0
```

**数组的数组**

```sql title=Query
SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])
```

```response title=Response
1
```

**没有公共类型的数组**

```sql title=Query
SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])
```

```response title=Response
Raises a `NO_COMMON_TYPE` exception
```
## indexOf {#indexOf}

引入时间：v1.1

**语法**

```sql
indexOf(arr, x)
```

**参数**

- `arr` — 要搜索 `x` 的数组。 [`Array`](/sql-reference/data-types/array).
- `x` — 在 `arr` 中寻找的第一个匹配元素的值。 UInt64.

**返回值**

如果存在，则返回 `arr` 中首个 `x` 的索引（从一开始编号）。否则，返回 `0`。

**示例**

**基本示例**

```sql title=Query
SELECT indexOf([5, 4, 1, 3], 3)
```

```response title=Response
4
```

**带有空值的数组**

```sql title=Query
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```response title=Response
3
```
## indexOfAssumeSorted {#indexOfAssumeSorted}

引入时间：v24.12

**语法**

```sql
indexOfAssumeSorted(arr, x)
```

**参数**

- `arr` — 要搜索的排序数组。 [`Array(T)`](/sql-reference/data-types/array).
- `x` — 在排序 `arr` 中寻找的第一个匹配元素的值。UInt64

**返回值**

如果存在，则返回 `arr` 中首个 `x` 的索引（从一开始编号）。否则，返回 `0`。

**示例**

**基本示例**

```sql title=Query
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```response title=Response
5
```
## length {#length}

引入时间：v1.1

**语法**

```sql
length(x)
```

**参数**

- `x` — 用于计算字节数量（对于字符串/固定字符串）或元素数量（对于数组）的字符串、固定字符串或数组。

**返回值**

返回字符串/固定字符串 `x` 中的字节数/数组 `x` 中的元素数量。

**示例**

**string1**

```sql title=Query
SELECT length('Hello, world!')
```

```response title=Response
13
```

**arr1**

```sql title=Query
SELECT length(['Hello', 'world'])
```

```response title=Response
2
```

**constexpr**

```sql title=Query
WITH 'hello' || toString(number) AS str
SELECT str,
isConstant(length(str)) AS str_length_is_constant,
isConstant(length(str::FixedString(6))) AS fixed_str_length_is_constant
FROM numbers(3)
```

```response title=Response
┌─str────┬─str_length_is_constant─┬─fixed_str_length_is_constant─┐
│ hello0 │                      0 │                            1 │
│ hello1 │                      0 │                            1 │
│ hello2 │                      0 │                            1 │
└────────┴────────────────────────┴──────────────────────────────┘
```

**unicode**

```sql title=Query
SELECT 'ёлка' AS str1, length(str1), lengthUTF8(str1), normalizeUTF8NFKD(str1) AS str2, length(str2), lengthUTF8(str2)
```

```response title=Response
┌─str1─┬─length(str1)─┬─lengthUTF8(str1)─┬─str2─┬─length(str2)─┬─lengthUTF8(str2)─┐
│ ёлка │            8 │                4 │ ёлка │           10 │                5 │
└──────┴──────────────┴──────────────────┴──────┴──────────────┴──────────────────┘
```

**ascii_vs_utf8**

```sql title=Query
SELECT 'ábc' AS str, length(str), lengthUTF8(str)
```

```response title=Response
┌─str─┬─length(str)──┬─lengthUTF8(str)─┐
│ ábc │            4 │               3 │
└─────┴──────────────┴─────────────────┘
```
## notEmpty {#notEmpty}

引入时间：v1.1

**语法**

```sql
notEmpty(arr)
```

**参数**

- `arr` — 输入数组。 [`Array(T)`](/sql-reference/data-types/array).

**返回值**

对于非空数组返回 `1`，对于空数组返回 `0`。 [`UInt8`](../data-types/int-uint.md).

**示例**

**用法示例**

```sql title=Query
SELECT notEmpty([1,2]);
```

```response title=Response
1
```
## range {#range}

引入时间：v1.1

**语法**

```sql
range([start, ] end [, step])
```

**参数**

- `start` — 可选。数组的第一个元素。如果使用了 `step`，这是必需的。默认值： `0`。
- `end` — 必需。在此之前构造数组的数字。
- `step` — 可选。决定数组中每个元素之间的增量步长。默认值： `1`。

**返回值**

数组中的数字从 `start` 到 `end - 1`，步长为 `step`。

**示例**

**用法示例**

```sql title=Query
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

```response title=Response
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```
