---
description: 'Движок памяти хранит данные в ОЗУ в не сжатом виде. Данные
  хранятся в точно таком же виде, в каком они получены при чтении. Другими словами, чтение
  из этой таблицы абсолютно бесплатно.'
sidebar_label: 'Память'
sidebar_position: 110
slug: /engines/table-engines/special/memory
title: 'Движок таблицы памяти'
---


# Движок таблицы памяти

:::note
При использовании движка таблицы памяти в ClickHouse Cloud данные не реплицируются на всех узлах (по умолчанию). Чтобы гарантировать, что все запросы направляются на один и тот же узел и что движок таблицы памяти работает как ожидается, вы можете сделать одно из следующих действий:
- Выполнять все операции в одной сессии
- Использовать клиент, который использует TCP или нативный интерфейс (что позволяет поддерживать закрепленные соединения), такой как [clickhouse-client](/interfaces/cli)
:::

Движок памяти хранит данные в ОЗУ в не сжатом виде. Данные хранятся в точно таком же виде, в каком они получены при чтении. Другими словами, чтение из этой таблицы абсолютно бесплатно.
Синхронизированный доступ к данным. Блокировки короткие: операции чтения и записи не блокируют друг друга.
Индексы не поддерживаются. Чтение параллелится.

Максимальная производительность (более 10 ГБ/с) достигается на простых запросах, потому что нет чтения с диска, распаковки или десериализации данных. (Следует отметить, что во многих случаях продуктивность движка MergeTree почти так же высока.)
При перезапуске сервера данные исчезают из таблицы, и таблица становится пустой.
Обычно использование этого движка таблицы не оправдано. Однако его можно использовать для тестов, а также для задач, где требуется максимальная скорость при относительно небольшом количестве строк (до примерно 100,000,000).

Движок памяти используется системой для временных таблиц с внешними данными запросов (см. раздел "Внешние данные для обработки запроса") и для реализации `GLOBAL IN` (см. раздел "Операторы IN").

Можно указать верхние и нижние пределы, чтобы ограничить размер таблицы движка памяти, что эффективно позволяет ему действовать как кольцевой буфер (см. [Параметры движка](#engine-parameters)).

## Параметры движка {#engine-parameters}

- `min_bytes_to_keep` — Минимальное количество байтов для хранения при ограничении размера таблицы памяти.
  - Значение по умолчанию: `0`
  - Требуется `max_bytes_to_keep`
- `max_bytes_to_keep` — Максимальное количество байтов для хранения в таблице памяти, где самые старые строки удаляются при каждом вставлении (т.е. кольцевой буфер). Максимальное число байтов может превышать указанный предел, если самая старая партия строк для удаления попадает под предел `min_bytes_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `min_rows_to_keep` — Минимальное количество строк для хранения при ограничении размера таблицы памяти.
  - Значение по умолчанию: `0`
  - Требуется `max_rows_to_keep`
- `max_rows_to_keep` — Максимальное количество строк для хранения в таблице памяти, где самые старые строки удаляются при каждом вставлении (т.е. кольцевой буфер). Максимальное количество строк может превышать указанный предел, если самая старая партия строк для удаления попадает под предел `min_rows_to_keep` при добавлении большого блока.
  - Значение по умолчанию: `0`
- `compress` - Нужно ли сжимать данные в памяти.
  - Значение по умолчанию: `false`

## Использование {#usage}

**Инициализация настроек**
```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Изменение настроек**
```sql
ALTER TABLE memory MODIFY SETTING min_rows_to_keep = 100, max_rows_to_keep = 1000;
```

**Примечание:** Оба параметра ограничения `bytes` и `rows` могут быть установлены одновременно, однако будут соблюдены нижние пределы `max` и `min`.

## Примеры {#examples}
```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_bytes_to_keep = 4096, max_bytes_to_keep = 16384;

/* 1. тестирование, что самая старая партия не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 8'192 байт

/* 2. добавление блока, который не будет удален */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 1'024 байт

/* 3. тестирование, что самая старая партия удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 8'192 байт

/* 4. проверка, что очень крупный блок переписывает все */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 65'536 байт

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' and database = currentDatabase();
```

```text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```

Также для строк:

```sql
CREATE TABLE memory (i UInt32) ENGINE = Memory SETTINGS min_rows_to_keep = 4000, max_rows_to_keep = 10000;

/* 1. тестирование, что самая старая партия не удаляется из-за минимального порога - 3000 строк */
INSERT INTO memory SELECT * FROM numbers(0, 1600); -- 1'600 строк

/* 2. добавление блока, который не будет удален */
INSERT INTO memory SELECT * FROM numbers(1000, 100); -- 100 строк

/* 3. тестирование, что самая старая партия удаляется - 9216 байт - 1100 */
INSERT INTO memory SELECT * FROM numbers(9000, 1000); -- 1'000 строк

/* 4. проверка, что очень крупный блок переписывает все */
INSERT INTO memory SELECT * FROM numbers(9000, 10000); -- 10'000 строк

SELECT total_bytes, total_rows FROM system.tables WHERE name = 'memory' and database = currentDatabase();
```

```text
┌─total_bytes─┬─total_rows─┐
│       65536 │      10000 │
└─────────────┴────────────┘
```
