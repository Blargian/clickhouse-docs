description: 'Документация по функциям массива'
sidebar_label: 'Массивы'
sidebar_position: 10
slug: /sql-reference/functions/array-functions
title: 'Функции массива'
```

# Функции массива
## empty {#empty}

Проверяет, является ли входной массив пустым.

**Синтаксис**

```sql
empty([x])
```

Массив считается пустым, если он не содержит элементов.

:::note
Можно оптимизировать, включив настройку [`optimize_functions_to_subcolumns`](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подколонку [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всей колонки массива. Запрос `SELECT empty(arr) FROM TABLE;` превращается в `SELECT arr.size0 = 0 FROM TABLE;`.
:::

Функция также работает для [строк](string-functions.md#empty) или [UUID](uuid-functions.md#empty).

**Аргументы**

- `[x]` — Входной массив. [Array](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для пустого массива или `0` для непустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT empty([]);
```

Результат:

```text
┌─empty(array())─┐
│              1 │
└────────────────┘
```
## notEmpty {#notempty}

Проверяет, является ли входной массив непустым.

**Синтаксис**

```sql
notEmpty([x])
```

Массив считается непустым, если он содержит хотя бы один элемент.

:::note
Можно оптимизировать, включив настройку [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подколонку [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всей колонки массива. Запрос `SELECT notEmpty(arr) FROM table` превращается в `SELECT arr.size0 != 0 FROM TABLE`.
:::

Функция также работает для [строк](string-functions.md#notempty) или [UUID](uuid-functions.md#notempty).

**Аргументы**

- `[x]` — Входной массив. [Array](/sql-reference/data-types/array).

**Возвращаемое значение**

- Возвращает `1` для непустого массива или `0` для пустого массива. [UInt8](../data-types/int-uint.md).

**Пример**

Запрос:

```sql
SELECT notEmpty([1,2]);
```

Результат:

```text
┌─notEmpty([1, 2])─┐
│                1 │
└──────────────────┘
```
## length {#length}

Возвращает количество элементов в массиве.
Тип результата — UInt64.
Функция также работает для строк.

Можно оптимизировать, включив настройку [optimize_functions_to_subcolumns](/operations/settings/settings#optimize_functions_to_subcolumns). При `optimize_functions_to_subcolumns = 1` функция читает только подколонку [size0](/sql-reference/data-types/array#array-size) вместо чтения и обработки всей колонки массива. Запрос `SELECT length(arr) FROM table` превращается в `SELECT arr.size0 FROM TABLE`.

Псевдоним: `OCTET_LENGTH`
## emptyArrayUInt8 {#emptyarrayuint8}

Возвращает пустой массив UInt8.

**Синтаксис**

```sql
emptyArrayUInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt8();
```

Результат:

```response
[]
```
## emptyArrayUInt16 {#emptyarrayuint16}

Возвращает пустой массив UInt16.

**Синтаксис**

```sql
emptyArrayUInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt16();
```

Результат:

```response
[]
```
## emptyArrayUInt32 {#emptyarrayuint32}

Возвращает пустой массив UInt32.

**Синтаксис**

```sql
emptyArrayUInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt32();
```

Результат:

```response
[]
```
## emptyArrayUInt64 {#emptyarrayuint64}

Возвращает пустой массив UInt64.

**Синтаксис**

```sql
emptyArrayUInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayUInt64();
```

Результат:

```response
[]
```
## emptyArrayInt8 {#emptyarrayint8}

Возвращает пустой массив Int8.

**Синтаксис**

```sql
emptyArrayInt8()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt8();
```

Результат:

```response
[]
```
## emptyArrayInt16 {#emptyarrayint16}

Возвращает пустой массив Int16.

**Синтаксис**

```sql
emptyArrayInt16()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt16();
```

Результат:

```response
[]
```
## emptyArrayInt32 {#emptyarrayint32}

Возвращает пустой массив Int32.

**Синтаксис**

```sql
emptyArrayInt32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt32();
```

Результат:

```response
[]
```
## emptyArrayInt64 {#emptyarrayint64}

Возвращает пустой массив Int64.

**Синтаксис**

```sql
emptyArrayInt64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayInt64();
```

Результат:

```response
[]
```
## emptyArrayFloat32 {#emptyarrayfloat32}

Возвращает пустой массив Float32.

**Синтаксис**

```sql
emptyArrayFloat32()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat32();
```

Результат:

```response
[]
```
## emptyArrayFloat64 {#emptyarrayfloat64}

Возвращает пустой массив Float64.

**Синтаксис**

```sql
emptyArrayFloat64()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayFloat64();
```

Результат:

```response
[]
```
## emptyArrayDate {#emptyarraydate}

Возвращает пустой массив Date.

**Синтаксис**

```sql
emptyArrayDate()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDate();
```
## emptyArrayDateTime {#emptyarraydatetime}

Возвращает пустой массив DateTime.

**Синтаксис**

```sql
[]
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayDateTime();
```

Результат:

```response
[]
```
## emptyArrayString {#emptyarraystring}

Возвращает пустой массив String.

**Синтаксис**

```sql
emptyArrayString()
```

**Аргументы**

Нет.

**Возвращаемое значение**

Пустой массив.

**Примеры**

Запрос:

```sql
SELECT emptyArrayString();
```

Результат:

```response
[]
```
## emptyArrayToSingle {#emptyarraytosingle}

Принимает пустой массив и возвращает массив с одним элементом, равным значению по умолчанию.
## range(end), range(\[start, \] end \[, step\]) {#rangeend-rangestart--end--step}

Возвращает массив чисел от `start` до `end - 1` с шагом `step`. Поддерживаемые типы: [UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64](../data-types/int-uint.md).

**Синтаксис**

```sql
range([start, ] end [, step])
```

**Аргументы**

- `start` — Первый элемент массива. Необязательный, обязательный, если используется `step`. Значение по умолчанию: 0.
- `end` — Число, перед которым создается массив. Обязательный.
- `step` — Определяет инкрементальный шаг между каждым элементом в массиве. Необязательный. Значение по умолчанию: 1.

**Возвращаемое значение**

- Массив чисел от `start` до `end - 1` с шагом `step`.

**Детали реализации**

- Все аргументы `start`, `end`, `step` должны быть ниже следующих типов: `UInt8`, `UInt16`, `UInt32`, `UInt64`,`Int8`, `Int16`, `Int32`, `Int64`, а также элементы возвращаемого массива, тип которого является супертипом всех аргументов.
- Исключение выбрасывается, если результаты запроса содержат массивы с общей длиной более числа элементов, указанного настраиваемым значением [function_range_max_elements_in_block](../../operations/settings/settings.md#function_range_max_elements_in_block).
- Возвращает Null, если любой аргумент имеет тип Nullable(Nothing). Исключение выбрасывается, если любой аргумент имеет значение Null (тип Nullable(T)).

**Примеры**

Запрос:

```sql
SELECT range(5), range(1, 5), range(1, 5, 2), range(-1, 5, 2);
```

Результат:

```txt
┌─range(5)────┬─range(1, 5)─┬─range(1, 5, 2)─┬─range(-1, 5, 2)─┐
│ [0,1,2,3,4] │ [1,2,3,4]   │ [1,3]          │ [-1,1,3]        │
└─────────────┴─────────────┴────────────────┴─────────────────┘
```
## array(x1, ...), оператор \[x1, ...\] {#arrayx1--operator-x1-}

Создает массив из аргументов функции.
Аргументы должны быть константами и иметь типы, которые имеют наименьший общий тип. Должен быть передан хотя бы один аргумент, иначе неясно, какой тип массива создать. То есть, вы не можете использовать эту функцию для создания пустого массива (для этого используйте функцию 'emptyArray*', описанную выше).
Возвращает результат типа 'Array(T)', где 'T' является наименьшим общим типом из переданных аргументов.
## arrayWithConstant(length, elem) {#arraywithconstantlength-elem}

Создает массив длиной `length`, заполненный постоянным значением `elem`.
## arrayConcat {#arrayconcat}

Объединяет массивы, переданные в качестве аргументов.

```sql
arrayConcat(arrays)
```

**Аргументы**

- `arrays` – Произвольное количество аргументов типа [Array](/sql-reference/data-types/array).

**Пример**

```sql
SELECT arrayConcat([1, 2], [3, 4], [5, 6]) AS res
```

```text
┌─res───────────┐
│ [1,2,3,4,5,6] │
└───────────────┘
```
## arrayElement(arr, n), оператор arr\[n\] {#arrayelementarr-n-operator-arrn}

Получает элемент с индексом `n` из массива `arr`. `n` должен быть любым целым типом.
Индексы в массиве начинаются с одного.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент с конца. Например, `arr[-1]` — это последний элемент в массиве.

Если индекс выходит за пределы массива, возвращается некоторое значение по умолчанию (0 для чисел, пустая строка для строк и т.д.), за исключением случая с неконстантным массивом и константным индексом 0 (в этом случае произойдет ошибка `Индексы массива начинаются с 1`).
## has(arr, elem) {#hasarr-elem}

Проверяет, содержит ли массив 'arr' элемент 'elem'.
Возвращает 0, если элемент отсутствует в массиве, или 1, если он есть.

`NULL` обрабатывается как значение.

```sql
SELECT has([1, 2, NULL], NULL)
```

```text
┌─has([1, 2, NULL], NULL)─┐
│                       1 │
└─────────────────────────┘
```
## arrayElementOrNull(arr, n) {#arrayelementornullarr-n}

Получает элемент с индексом `n` из массива `arr`. `n` должен быть любым целым типом.
Индексы в массиве начинают с одного.

Поддерживаются отрицательные индексы. В этом случае выбирается соответствующий элемент с конца. Например, `arr[-1]` — это последний элемент в массиве.

Если индекс выходит за пределы массива, возвращает `NULL` вместо значения по умолчанию.
### Примеры {#examples}

```sql
SELECT arrayElementOrNull([1, 2, 3], 2), arrayElementOrNull([1, 2, 3], 4)
```

```text
 ┌─arrayElementOrNull([1, 2, 3], 2)─┬─arrayElementOrNull([1, 2, 3], 4)─┐
 │                                2 │                             ᴺᵁᴸᴸ │
 └──────────────────────────────────┴──────────────────────────────────┘
```
## hasAll {#hasall}

Проверяет, является ли один массив подмножеством другого.

```sql
hasAll(set, subset)
```

**Аргументы**

- `set` – Массив любого типа с набором элементов.
- `subset` – Массив любого типа, который делит общий супертоп с `set` и содержит элементы, которые должны быть проверены как подмножество `set`.

**Возвращаемые значения**

- `1`, если `set` содержит все элементы из `subset`.
- `0`, в противном случае.

Выбрасывается исключение `NO_COMMON_TYPE`, если элементы множества и подмножества не делят общий супертоп.

**Особые свойства**

- Пустой массив является подмножеством любого массива.
- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAll([], [])` возвращает 1.

`SELECT hasAll([1, Null], [Null])` возвращает 1.

`SELECT hasAll([1.0, 2, 3, 4], [1, 3])` возвращает 1.

`SELECT hasAll(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasAll([1], ['a'])` выбрасывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [3, 5]])` возвращает 0.
## hasAny {#hasany}

Проверяет, имеют ли два массива пересечение по некоторым элементам.

```sql
hasAny(array1, array2)
```

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа, который делит общий супертоп с `array1`.

**Возвращаемые значения**

- `1`, если `array1` и `array2` имеют хотя бы один общий элемент.
- `0`, в противном случае.

Выбрасывается исключение `NO_COMMON_TYPE`, если элементы array1 и array2 не делят общий супертоп.

**Особые свойства**

- `Null` обрабатывается как значение.
- Порядок значений в обоих массивах не имеет значения.

**Примеры**

`SELECT hasAny([1], [])` возвращает `0`.

`SELECT hasAny([Null], [Null, 1])` возвращает `1`.

`SELECT hasAny([-128, 1., 512], [1])` возвращает `1`.

`SELECT hasAny([[1, 2], [3, 4]], ['a', 'c'])` выбрасывает исключение `NO_COMMON_TYPE`.

`SELECT hasAll([[1, 2], [3, 4]], [[1, 2], [1, 2]])` возвращает `1`.
## hasSubstr {#hassubstr}

Проверяет, появляются ли все элементы массива array2 в array1 в том же самом порядке. Таким образом, функция вернет 1, если и только если `array1 = prefix + array2 + suffix`.

```sql
hasSubstr(array1, array2)
```

Иными словами, функции проверят, содержатся ли все элементы `array2` в `array1` так же, как и функция `hasAll`. Кроме того, будет проверено, что элементы наблюдаются в том же порядке в обоих `array1` и `array2`.

Например:

- `hasSubstr([1,2,3,4], [2,3])` возвращает 1. Однако, `hasSubstr([1,2,3,4], [3,2])` возвращает `0`.
- `hasSubstr([1,2,3,4], [1,2,3])` возвращает 1. Однако, `hasSubstr([1,2,3,4], [1,2,4])` возвращает `0`.

**Аргументы**

- `array1` – Массив любого типа с набором элементов.
- `array2` – Массив любого типа с набором элементов.

**Возвращаемые значения**

- `1`, если `array1` содержит `array2`.
- `0`, в противном случае.

Выбрасывается исключение `NO_COMMON_TYPE`, если элементы array1 и array2 не делят общий супертоп.

**Особые свойства**

- Функция возвращает `1`, если `array2` пуст.
- `Null` обрабатывается как значение. Иными словами `hasSubstr([1, 2, NULL, 3, 4], [2,3])` возвращает `0`. Однако, `hasSubstr([1, 2, NULL, 3, 4], [2,NULL,3])` возвращает `1`
- Порядок значений в обоих массивах имеет значение.

**Примеры**

`SELECT hasSubstr([], [])` возвращает 1.

`SELECT hasSubstr([1, Null], [Null])` возвращает 1.

`SELECT hasSubstr([1.0, 2, 3, 4], [1, 3])` возвращает 0.

`SELECT hasSubstr(['a', 'b'], ['a'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'b'])` возвращает 1.

`SELECT hasSubstr(['a', 'b' , 'c'], ['a', 'c'])` возвращает 0.

`SELECT hasSubstr([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]])` возвращает 1.
`SELECT hasSubstr([1, 2, NULL, 3, 4], ['a'])` выбрасывает исключение `NO_COMMON_TYPE`.
## indexOf(arr, x) {#indexofarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он присутствует в массиве.
Если массив не содержит искомое значение, функция возвращает 0.

Пример:

```sql
SELECT indexOf([1, 3, NULL, NULL], NULL)
```

```text
┌─indexOf([1, 3, NULL, NULL], NULL)─┐
│                                 3 │
└───────────────────────────────────┘
```

Элементы, установленные на `NULL`, обрабатываются как обычные значения.
## indexOfAssumeSorted(arr, x) {#indexofassumesortedarr-x}

Возвращает индекс первого элемента со значением 'x' (начиная с 1), если он присутствует в массиве.
Если массив не содержит искомое значение, функция возвращает 0.
Предполагает, что массив отсортирован в порядке возрастания (т.е. функция использует бинарный поиск).
Если массив не отсортирован, результаты будут неопределенными.
Если внутренний массив является типом Nullable, будет вызвана функция 'indexOf'.

Пример:

```sql
SELECT indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)
```

```text
┌─indexOfAssumeSorted([1, 3, 3, 3, 4, 4, 5], 4)─┐
│                                             5 │
└───────────────────────────────────────────────┘
```
## arrayCount(\[func,\] arr1, ...) {#arraycountfunc-arr1-}

Возвращает количество элементов, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то другое, кроме 0. Если `func` не указан, он возвращает количество ненулевых элементов в массиве.

Обратите внимание, что `arrayCount` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать лямбда-функцию в качестве первого аргумента.
## arrayDotProduct {#arraydotproduct}

Возвращает скалярное произведение двух массивов.

**Синтаксис**

```sql
arrayDotProduct(vector1, vector2)
```

Псевдоним: `scalarProduct`, `dotProduct`

**Параметры**

- `vector1`: Первый вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.
- `vector2`: Второй вектор. [Array](/sql-reference/data-types/array) или [Tuple](../data-types/tuple.md) числовых значений.

:::note
Размеры двух векторов должны быть равны. Массивы и кортежи также могут содержать смешанные типы элементов.
:::

**Возвращаемое значение**

- Скалярное произведение двух векторов. [Numeric](/native-protocol/columns#numeric-types).

:::note
Тип возвращаемого значения определяется типом аргументов. Если массивы или кортежи содержат смешанные типы элементов, то тип результата является супертопом.
:::

**Примеры**

Запрос:

```sql
SELECT arrayDotProduct([1, 2, 3], [4, 5, 6]) AS res, toTypeName(res);
```

Результат:

```response
32    UInt16
```

Запрос:

```sql
SELECT dotProduct((1::UInt16, 2::UInt8, 3::Float32),(4::Int16, 5::Float32, 6::UInt8)) AS res, toTypeName(res);
```

Результат:

```response
32    Float64
```
## countEqual(arr, x) {#countequalarr-x}

Возвращает количество элементов в массиве, равных x. Эквивалентно arrayCount (elem -> elem = x, arr).

Элементы `NULL` обрабатываются как отдельные значения.

Пример:

```sql
SELECT countEqual([1, 2, NULL, NULL], NULL)
```

```text
┌─countEqual([1, 2, NULL, NULL], NULL)─┐
│                                    2 │
└──────────────────────────────────────┘
```
## arrayEnumerate(arr) {#arrayenumeratearr}

Возвращает массив \[1, 2, 3, ..., length (arr) \]

Эта функция обычно используется с `ARRAY JOIN`. Она позволяет считать что-то только один раз для каждого массива после применения `ARRAY JOIN`. Пример:

```sql
SELECT
    count() AS Reaches,
    countIf(num = 1) AS Hits
FROM test.hits
ARRAY JOIN
    GoalsReached,
    arrayEnumerate(GoalsReached) AS num
WHERE CounterID = 160656
LIMIT 10
```

```text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

В этом примере, Reaches — это количество конверсий (строк, полученных после применения ARRAY JOIN), а Hits — это количество просмотров страниц (строк до ARRAY JOIN). В этом случае вы также можете получить тот же результат более простым способом:

```sql
SELECT
    sum(length(GoalsReached)) AS Reaches,
    count() AS Hits
FROM test.hits
WHERE (CounterID = 160656) AND notEmpty(GoalsReached)
```

```text
┌─Reaches─┬──Hits─┐
│   95606 │ 31406 │
└─────────┴───────┘
```

Эту функцию также можно использовать в функциях высшего порядка. Например, вы можете использовать ее, чтобы получить индексы массива для элементов, которые соответствуют условию.
## arrayEnumerateUniq {#arrayenumerateuniq}

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента, какое место он занимает среди элементов с тем же значением.
Например: arrayEnumerateUniq(\[10, 20, 10, 30\]) = \[1, 1, 2, 1\].

Эта функция полезна при использовании ARRAY JOIN и агрегации элементов массива.
Пример:

```sql
SELECT
    Goals.ID AS GoalID,
    sum(Sign) AS Reaches,
    sumIf(Sign, num = 1) AS Visits
FROM test.visits
ARRAY JOIN
    Goals,
    arrayEnumerateUniq(Goals.ID) AS num
WHERE CounterID = 160656
GROUP BY GoalID
ORDER BY Reaches DESC
LIMIT 10
```

```text
┌──GoalID─┬─Reaches─┬─Visits─┐
│   53225 │    3214 │   1097 │
│ 2825062 │    3188 │   1097 │
│   56600 │    2803 │    488 │
│ 1989037 │    2401 │    365 │
│ 2830064 │    2396 │    910 │
│ 1113562 │    2372 │    373 │
│ 3270895 │    2262 │    812 │
│ 1084657 │    2262 │    345 │
│   56599 │    2260 │    799 │
│ 3271094 │    2256 │    812 │
└─────────┴─────────┴────────┘
```

В этом примере, каждый идентификатор цели включает расчет числа конверсий (каждый элемент в вложенной структуре данных Goals является целью, которая была достигнута, которая называется конверсией) и число сессий. Без ARRAY JOIN, мы бы посчитали количество сессий как sum(Sign). Но в этом конкретном случае строки были умножены вложенной структурой Goals, поэтому, чтобы посчитать каждую сессию один раз после этого, мы применяем условие к значению функции arrayEnumerateUniq(Goals.ID).

Функция arrayEnumerateUniq может принимать несколько массивов одного размера в качестве аргументов. В этом случае уникальность учитывается для кортежей элементов в одних и тех же позициях во всех массивах.

```sql
SELECT arrayEnumerateUniq([1, 1, 1, 2, 2, 2], [1, 1, 2, 1, 1, 2]) AS res
```

```text
┌─res───────────┐
│ [1,2,1,1,2,1] │
└───────────────┘
```

Это необходимо при использовании ARRAY JOIN с вложенной структурой данных и последующей агрегацией по нескольким элементам в этой структуре.
## arrayEnumerateUniqRanked {#arrayenumerateuniqranked}

Возвращает массив того же размера, что и исходный массив, указывая для каждого элемента, какое место он занимает среди элементов с тем же значением. Позволяет нумеровать многомерный массив с возможностью указания глубины, на которую нужно заглянуть внутрь массива.

**Синтаксис**

```sql
arrayEnumerateUniqRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Нумеровать элементы на указанном уровне отдельно. Положительное [Целое число](../data-types/int-uint.md), меньшее или равное `max_arr_depth`.
- `arr`: N-мерный массив для нумерации. [Array](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [Целое число](../data-types/int-uint.md), меньшее или равное глубине `arr`.

**Пример**

При `clear_depth=1` и `max_array_depth=1`, результат `arrayEnumerateUniqRanked` будет идентичен тому, который даст [`arrayEnumerateUniq`](#arrayenumerateuniq) для того же массива.

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(1, [1,2,1], 1);
```

Результат:

```text
[1,1,2]
```

В этом примере используется `arrayEnumerateUniqRanked`, чтобы получить массив, указывающий, для каждого элемента многомерного массива, какое место он занимает среди элементов одного и того же значения. Для первой строки переданного массива, `[1,2,3]`, соответствующий результат — это `[1,1,1]`, что указывает на то, что это первый раз, когда встречаются `1`, `2` и `3`. Для второй строки переданного массива, `[2,2,1]`, соответствующий результат — это `[2,3,3]`, что указывает на то, что `2` встречается во второй и третий раз, а `1` встречается во второй раз. Точно так же, для третьей строки переданного массива `[3]`, соответствующий результат — это `[2]`, что указывает на то, что `3` встречается во второй раз. 

Запрос:

```sql
SELECT arrayEnumerateUniqRanked(2, [[1,2,3],[2,2,1],[3]], 2);
```

Результат:

```text
[[1,1,1],[1,2,1],[1]]
```
## arrayPopBack {#arraypopback}

Удаляет последний элемент из массива.

```sql
arrayPopBack(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

```sql
SELECT arrayPopBack([1, 2, 3]) AS res;
```

```text
┌─res───┐
│ [1,2] │
└───────┘
```
## arrayPopFront {#arraypopfront}

Удаляет первый элемент из массива.

```sql
arrayPopFront(array)
```

**Аргументы**

- `array` – Массив.

**Пример**

```sql
SELECT arrayPopFront([1, 2, 3]) AS res;
```

```text
┌─res───┐
│ [2,3] │
└───────┘
```
## arrayPushBack {#arraypushback}

Добавляет один элемент в конец массива.

```sql
arrayPushBack(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Единственное значение. В массив с числами можно добавить только числа, а в массив строк — только строки. При добавлении чисел ClickHouse автоматически устанавливает тип `single_value` для типа данных массива. Для получения дополнительной информации о типах данных в ClickHouse смотрите "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

```sql
SELECT arrayPushBack(['a'], 'b') AS res;
```

```text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayPushFront {#arraypushfront}

Добавляет один элемент в начало массива.

```sql
arrayPushFront(array, single_value)
```

**Аргументы**

- `array` – Массив.
- `single_value` – Единственное значение. В массив с числами можно добавить только числа, а в массив строк — только строки. При добавлении чисел ClickHouse автоматически устанавливает тип `single_value` для типа данных массива. Для получения дополнительной информации о типах данных в ClickHouse смотрите "[Типы данных](/sql-reference/data-types)". Может быть `NULL`. Функция добавляет элемент `NULL` в массив, и тип элементов массива преобразуется в `Nullable`.

**Пример**

```sql
SELECT arrayPushFront(['b'], 'a') AS res;
```

```text
┌─res───────┐
│ ['a','b'] │
└───────────┘
```
## arrayResize {#arrayresize}

Изменяет длину массива.

```sql
arrayResize(array, size[, extender])
```

**Аргументы:**

- `array` — Массив.
- `size` — Необходимая длина массива.
  - Если `size` меньше исходного размера массива, массив обрезается справа.
- Если `size` больше начального размера массива, массив расширяется вправо с помощью значений `extender` или значений по умолчанию для типа данных элементов массива.
- `extender` — Значение для расширения массива. Может быть `NULL`.

**Возвращаемое значение:**

Массив длиной `size`.

**Примеры вызовов**

```sql
SELECT arrayResize([1], 3);
```

```text
┌─arrayResize([1], 3)─┐
│ [1,0,0]             │
└─────────────────────┘
```

```sql
SELECT arrayResize([1], 3, NULL);
```

```text
┌─arrayResize([1], 3, NULL)─┐
│ [1,NULL,NULL]             │
└───────────────────────────┘
```
## arraySlice {#arrayslice}

Возвращает срез массива.

```sql
arraySlice(array, offset[, length])
```

**Аргументы**

- `array` – Массив данных.
- `offset` – Смещение от края массива. Положительное значение указывает на смещение слева, а отрицательное — на смещение справа. Нумерация элементов массива начинается с 1.
- `length` – Длина необходимого среза. Если вы укажете отрицательное значение, функция вернет открытый срез `[offset, array_length - length]`. Если вы опустите значение, функция вернет срез `[offset, the_end_of_array]`.

**Пример**

```sql
SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
```

```text
┌─res────────┐
│ [2,NULL,4] │
└────────────┘
```

Элементы массива, установленные на `NULL`, обрабатываются как обычные значения.
## arrayShingles {#arrayshingles}

Генерирует массив "шинглов", т.е. последовательных подмассивов заданной длины из входного массива.

**Синтаксис**

```sql
arrayShingles(array, length)
```

**Аргументы**

- `array` — Входной массив [Array](/sql-reference/data-types/array).
- `length` — Длина каждого шингла.

**Возвращаемое значение**

- Массив сгенерированных шинглов. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShingles([1,2,3,4], 3) as res;
```

Результат:

```text
┌─res───────────────┐
│ [[1,2,3],[2,3,4]] │
└───────────────────┘
```
```yaml
title: 'arraySort'
sidebar_label: 'arraySort'
keywords: ['array', 'sort', 'function']
description: 'Сортирует элементы массива в порядке возрастания.'
```

## arraySort(\[func,\] arr, ...) {#sort}

Сортирует элементы массива `arr` в порядке возрастания. Если функция `func` указана, порядок сортировки определяется результатом функции `func`, примененной к элементам массива. Если `func` принимает несколько аргументов, функции `arraySort` передается несколько массивов, соответствующих аргументам `func`. Подробные примеры приведены в конце описания `arraySort`.

Пример сортировки целочисленных значений:

```sql
SELECT arraySort([1, 3, 3, 0]);
```

```text
┌─arraySort([1, 3, 3, 0])─┐
│ [0,1,3,3]               │
└─────────────────────────┘
```

Пример сортировки строковых значений:

```sql
SELECT arraySort(['hello', 'world', '!']);
```

```text
┌─arraySort(['hello', 'world', '!'])─┐
│ ['!','hello','world']              │
└────────────────────────────────────┘
```

Рассмотрим следующий порядок сортировки для значений `NULL`, `NaN` и `Inf`:

```sql
SELECT arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]);
```

```text
┌─arraySort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf])─┐
│ [-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]                     │
└───────────────────────────────────────────────────────────┘
```

- Значения `-Inf` находятся в начале массива.
- Значения `NULL` находятся в конце массива.
- Значения `NaN` расположены непосредственно перед `NULL`.
- Значения `Inf` расположены непосредственно перед `NaN`.

Обратите внимание, что `arraySort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента. В этом случае порядок сортировки определяется результатом лямбда-функции, примененной к элементам массива.

Рассмотрим следующий пример:

```sql
SELECT arraySort((x) -> -x, [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [3,2,1] │
└─────────┘
```

Для каждого элемента исходного массива лямбда-функция возвращает ключ сортировки, то есть \[1 –\> -1, 2 –\> -2, 3 –\> -3\]. Поскольку функция `arraySort` сортирует ключи в порядке возрастания, результатом является \[3, 2, 1\]. Таким образом, лямбда-функция `(x) –> -x` устанавливает [порядок убывания](#arrayreversesort) в сортировке.

Лямбда-функция может принимать несколько аргументов. В этом случае необходимо передать функции `arraySort` несколько массивов одинаковой длины, которые будут соответствовать аргументам лямбда-функции. Результирующий массив будет состоять из элементов первого входного массива; элементы из последующих входных массивов указывают ключи сортировки. Например:

```sql
SELECT arraySort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

```text
┌─res────────────────┐
│ ['world', 'hello'] │
└────────────────────┘
```

Здесь элементы, переданные во втором массиве (\[2, 1\]), определяют ключ сортировки для соответствующего элемента из исходного массива (\['hello', 'world'\]), то есть \['hello' –\> 2, 'world' –\> 1\]. Поскольку лямбда-функция не использует `x`, фактические значения исходного массива не влияют на порядок в результате. Таким образом, 'hello' будет вторым элементом в результате, а 'world' — первым.

Другие примеры показаны ниже.

```sql
SELECT arraySort((x, y) -> y, [0, 1, 2], ['c', 'b', 'a']) as res;
```

```text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

```sql
SELECT arraySort((x, y) -> -y, [0, 1, 2], [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [2,1,0] │
└─────────┘
```

:::note
Для повышения эффективности сортировки используется [преобразование Шварца](https://en.wikipedia.org/wiki/Schwartzian_transform).
:::
## arrayPartialSort(\[func,\] limit, arr, ...) {#arraypartialsortfunc-limit-arr-}

То же, что и `arraySort`, с дополнительным аргументом `limit`, позволяющим выполнять частичную сортировку. Возвращает массив того же размера, что и оригинальный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке возрастания. Оставшиеся элементы `(limit..N]` будут содержать элементы в неопределенном порядке.

## arrayReverseSort {#arrayreversesort}

Сортирует элементы массива `arr` в порядке убывания. Если указана функция `func`, массив `arr` сортируется в соответствии с результатом функции `func`, примененной к элементам массива, а затем отсортированный массив разворачивается. Если `func` принимает несколько аргументов, функции `arrayReverseSort` передается несколько массивов, соответствующих аргументам `func`. Подробные примеры приведены в конце описания `arrayReverseSort`.

**Синтаксис**

```sql
arrayReverseSort([func,] arr, ...)
```
Пример сортировки целочисленных значений:

```sql
SELECT arrayReverseSort([1, 3, 3, 0]);
```

```text
┌─arrayReverseSort([1, 3, 3, 0])─┐
│ [3,3,1,0]                      │
└────────────────────────────────┘
```

Пример сортировки строковых значений:

```sql
SELECT arrayReverseSort(['hello', 'world', '!']);
```

```text
┌─arrayReverseSort(['hello', 'world', '!'])─┐
│ ['world','hello','!']                     │
└───────────────────────────────────────────┘
```

Рассмотрим следующий порядок сортировки для значений `NULL`, `NaN` и `Inf`:

```sql
SELECT arrayReverseSort([1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]) as res;
```

```text
┌─res───────────────────────────────────┐
│ [inf,3,2,1,-4,-inf,nan,nan,NULL,NULL] │
└───────────────────────────────────────┘
```

- Значения `Inf` находятся в начале массива.
- Значения `NULL` находятся в конце массива.
- Значения `NaN` расположены непосредственно перед `NULL`.
- Значения `-Inf` расположены непосредственно перед `NaN`.

Обратите внимание, что `arrayReverseSort` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента. Пример показан ниже.

```sql
SELECT arrayReverseSort((x) -> -x, [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [1,2,3] │
└─────────┘
```

Массив сортируется следующим образом:

1. Сначала исходный массив (\[1, 2, 3\]) сортируется в соответствии с результатом функции лямбда, примененной к элементам массива. Результат — массив \[3, 2, 1\].
2. Массив, полученный на предыдущем шаге, разворачивается. Таким образом, окончательный результат — \[1, 2, 3\].

Лямбда-функция может принимать несколько аргументов. В этом случае необходимо передать функции `arrayReverseSort` несколько массивов одинаковой длины, которые будут соответствовать аргументам лямбда-функции. Результирующий массив будет состоять из элементов первого входного массива; элементы из последующих входных массивов указывают ключи сортировки. Например:

```sql
SELECT arrayReverseSort((x, y) -> y, ['hello', 'world'], [2, 1]) as res;
```

```text
┌─res───────────────┐
│ ['hello','world'] │
└───────────────────┘
```

В этом примере массив сортируется следующим образом:

1. Сначала исходный массив (\['hello', 'world'\]) сортируется в соответствии с результатом функции лямбда, примененной к элементам массивов. Элементы, переданные во втором массиве (\[2, 1\]), определяют ключи сортировки для соответствующих элементов из исходного массива. Результат — массив \['world', 'hello'\].
2. Массив, который был отсортирован на предыдущем шаге, разворачивается. Таким образом, окончательный результат — \['hello', 'world'\].

Другие примеры показаны ниже.

```sql
SELECT arrayReverseSort((x, y) -> y, [4, 3, 5], ['a', 'b', 'c']) AS res;
```

```text
┌─res─────┐
│ [5,3,4] │
└─────────┘
```

```sql
SELECT arrayReverseSort((x, y) -> -y, [4, 3, 5], [1, 2, 3]) AS res;
```

```text
┌─res─────┐
│ [4,3,5] │
└─────────┘
```
## arrayPartialReverseSort(\[func,\] limit, arr, ...) {#arraypartialreversesortfunc-limit-arr-}

То же, что и `arrayReverseSort`, с дополнительным аргументом `limit`, позволяющим выполнять частичную сортировку. Возвращает массив того же размера, что и оригинальный массив, где элементы в диапазоне `[1..limit]` отсортированы в порядке убывания. Оставшиеся элементы `(limit..N]` будут содержать элементы в неопределенном порядке.

## arrayShuffle {#arrayshuffle}

Возвращает массив того же размера, что и оригинальный массив, содержащий элементы в случайном порядке.
Элементы перерассматриваются таким образом, чтобы каждая возможная перестановка этих элементов имела равную вероятность появления.

**Синтаксис**

```sql
arrayShuffle(arr[, seed])
```

**Параметры**

- `arr`: Массив для частичного перемешивания. [Array](/sql-reference/data-types/array).
- `seed` (необязательно): семя, которое будет использоваться для генерации случайных чисел. Если не предоставлено, используется случайное. [UInt или Int](../data-types/int-uint.md).

**Возвращаемое значение**

- Массив с перемешанными элементами.

**Детали реализации**

:::note 
Эта функция не будет материализовывать константы.
:::

**Примеры**

В этом примере `arrayShuffle` используется без предоставления `seed`, и, следовательно, будет генерировать его случайным образом. 

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4]);
```

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции.

Результат: 

```response
[1,4,2,3]
```

В этом примере `arrayShuffle` предоставляется `seed`, что позволит получить стабильные результаты.

Запрос:

```sql
SELECT arrayShuffle([1, 2, 3, 4], 41);
```

Результат: 

```response
[3,2,1,4]
```
## arrayPartialShuffle {#arraypartialshuffle}

Учитывая входной массив кардинальности `N`, возвращает массив размером N, где элементы в диапазоне `[1...limit]` перемешаны, а оставшиеся элементы в диапазоне `(limit...n]` не перемешаны.

**Синтаксис**

```sql
arrayPartialShuffle(arr[, limit[, seed]])
```

**Параметры**

- `arr`: Массив размером `N`, который нужно частично перемешать. [Array](/sql-reference/data-types/array).
- `limit` (необязательно): Число, ограничивающее количество обменов элементов в диапазоне `[1..N]`. [UInt или Int](../data-types/int-uint.md).
- `seed` (необязательно): Значение семени, которое будет использоваться для генерации случайных чисел. Если не предоставлено, используется случайное. [UInt или Int](../data-types/int-uint.md)

**Возвращаемое значение**

- Массив с частично перемешанными элементами.

**Детали реализации**

:::note 
Эта функция не будет материализовывать константы.

Значение `limit` должно находиться в диапазоне `[1..N]`. Значения за пределами этого диапазона эквивалентны выполнению полного [arrayShuffle](#arrayshuffle).
:::

**Примеры**

Примечание: при использовании [ClickHouse Fiddle](https://fiddle.clickhouse.com/) точный ответ может отличаться из-за случайного характера функции. 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)
```

Результат:

Порядок элементов сохраняется (`[2,3,4,5], [7,8,9,10]`) за исключением двух перемешанных элементов `[1, 6]`. Семя не предоставлено, поэтому функция выбирает его случайным образом.

```response
[6,2,3,4,5,1,7,8,9,10]
```

В этом примере `limit` увеличивается до `2`, и предоставляется значение `seed`. Порядок 

Запрос:

```sql
SELECT arrayPartialShuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2);
```

Порядок элементов сохраняется (`[4, 5, 6, 7, 8], [10]`) за исключением четырех перемешанных элементов `[1, 2, 3, 9]`.

Результат: 
```response
[3,9,1,4,5,6,7,8,2,10]
```
## arrayUniq(arr, ...) {#arrayuniqarr-}

Если передан один аргумент, он подсчитывает количество различных элементов в массиве.
Если передано несколько аргументов, он подсчитывает количество различных кортежей элементов по соответствующим позициям в нескольких массивах.

Если вы хотите получить список уникальных элементов в массиве, вы можете использовать arrayReduce('groupUniqArray', arr).
## arrayJoin(arr) {#arrayjoinarr}

Специальная функция. Смотрите раздел ["Функция ArrayJoin"](/sql-reference/functions/array-join).
## arrayDifference {#arraydifference}

Вычисляет массив разностей между соседними элементами массива. Первый элемент результирующего массива будет 0, второй — `a[1] - a[0]`, третий — `a[2] - a[1]` и так далее. Тип элементов в результирующем массиве определяется правилами вывода типов для вычитания (например, `UInt8` - `UInt8` = `Int16`).

**Синтаксис**

```sql
arrayDifference(array)
```

**Аргументы**

- `array` – [Array](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив разностей между соседними элементами массива. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float).

**Пример**

Запрос:

```sql
SELECT arrayDifference([1, 2, 3, 4]);
```

Результат:

```text
┌─arrayDifference([1, 2, 3, 4])─┐
│ [0,1,1,1]                     │
└───────────────────────────────┘
```

Пример переполнения из-за типа результата Int64:

Запрос:

```sql
SELECT arrayDifference([0, 10000000000000000000]);
```

Результат:

```text
┌─arrayDifference([0, 10000000000000000000])─┐
│ [0,-8446744073709551616]                   │
└────────────────────────────────────────────┘
```
## arrayDistinct {#arraydistinct}

Принимает массив, возвращает массив, содержащий только отличающиеся элементы.

**Синтаксис**

```sql
arrayDistinct(array)
```

**Аргументы**

- `array` – [Array](/sql-reference/data-types/array).

**Возвращаемые значения**

Возвращает массив, содержащий отличающиеся элементы.

**Пример**

Запрос:

```sql
SELECT arrayDistinct([1, 2, 2, 3, 1]);
```

Результат:

```text
┌─arrayDistinct([1, 2, 2, 3, 1])─┐
│ [1,2,3]                        │
└────────────────────────────────┘
```
## arrayEnumerateDense {#arrayenumeratedense}

Возвращает массив того же размера, что и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве.

**Синтаксис**

```sql
arrayEnumerateDense(arr)
```

**Пример**

Запрос:

```sql
SELECT arrayEnumerateDense([10, 20, 10, 30])
```

Результат:

```text
┌─arrayEnumerateDense([10, 20, 10, 30])─┐
│ [1,2,1,3]                             │
└───────────────────────────────────────┘
```
## arrayEnumerateDenseRanked {#arrayenumeratedenseranked}

Возвращает массив того же размера, что и исходный массив, указывая, где каждый элемент впервые появляется в исходном массиве. Позволяет перечислять многомерный массив с возможностью указать, насколько глубоко искать внутри массива.

**Синтаксис**

```sql
arrayEnumerateDenseRanked(clear_depth, arr, max_array_depth)
```

**Параметры**

- `clear_depth`: Перечислять элементы на указанном уровне отдельно. Положительное [целое число](../data-types/int-uint.md), меньшее или равное `max_arr_depth`.
- `arr`: N-мерный массив для перечисления. [Array](/sql-reference/data-types/array).
- `max_array_depth`: Максимальная эффективная глубина. Положительное [целое число](../data-types/int-uint.md), меньшее или равное глубине `arr`.

**Пример**

С `clear_depth=1` и `max_array_depth=1` результат идентичен тому, что дает [arrayEnumerateDense](#arrayenumeratedense).

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(1,[10, 20, 10, 30],1);
```

Результат:

```text
[1,2,1,3]
```

В этом примере `arrayEnumerateDenseRanked` используется для получения массива, указывающего, для каждого элемента многомерного массива, какова его позиция среди элементов одного и того же значения. Для первой строки переданного массива, ` [10, 10, 30, 20]`, соответствующая первая строка результата — `[1, 1, 2, 3]`, указывая, что `10` является первым встреченным числом на позициях 1 и 2, `30` — вторым встреченным числом на позиции 3, а `20` третьим встреченным числом на позиции 4. Для второй строки, `[40, 50, 10, 30]`, соответствующая вторая строка результата — `[4, 5, 1, 2]`, указывая, что `40` и `50` являются четвертым и пятым встреченными числами на позициях 1 и 2 этой строки, а другой `10` (первое встретившееся число) находится на позиции 3 и `30` (второе встреченное число) находится на последней позиции. 

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(1,[[10,10,30,20],[40,50,10,30]],2);
```

Результат:

```text
[[1,1,2,3],[4,5,1,2]]
```

Изменение `clear_depth=2` приводит к тому, что перечисление происходит отдельно для каждой строки заново.

Запрос:

```sql
SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);
```
Результат:

```text
[[1,1,2,3],[1,2,3,4]]
```
## arrayUnion {#arrayunion}

Принимает несколько массивов и возвращает массив, содержащий все элементы, которые присутствуют в одном из исходных массивов.
Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayUnion(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с отличающимися элементами из исходных массивов.

**Пример**

Запрос:

```sql
SELECT
    arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,
    arrayUnion(['hi'], [], ['hello', 'hi']) as str_example,
    arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example
```

Результат:

```text
┌─num_example─┬─str_example────┬─null_example─┐
│ [10,-2,1]   │ ['hello','hi'] │ [3,2,1,NULL] │
└─────────────┴────────────────┴──────────────┘
```
## arrayIntersect {#arrayintersect}

Принимает несколько массивов и возвращает массив с элементами, которые присутствуют во всех исходных массивах.
Результат содержит только уникальные значения.

**Синтаксис**

```sql
arrayIntersect(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с уникальными элементами, присутствующими во всех исходных массивах.

**Пример**

Запрос:

```sql
SELECT
    arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,
    arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection
```

Результат:

```text
┌─non_empty_intersection─┬─empty_intersection─┐
│ []                     │ [1]                │
└────────────────────────┴────────────────────┘
```
## arraySymmetricDifference {#arraysymmetricdifference}

Принимает несколько массивов и возвращает массив с элементами, которые отсутствуют во всех исходных массивах.
Результат содержит только уникальные значения.

:::note
Симметрическая разность _более чем двух множеств_ математически определена как множество всех входных элементов, которые возникают в нечетном числе входных множеств.
В отличие от этого, функция `arraySymmetricDifference` просто возвращает множество входных элементов, которые отсутствуют во всех входных множествах.
:::

**Синтаксис**

```sql
arraySymmetricDifference(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- [Array](/sql-reference/data-types/array) с уникальными элементами, отсутствующими во всех исходных массивах.

**Пример**

Запрос:

```sql
SELECT
    arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference,
    arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference,
```

Результат:

```text
┌─empty_symmetric_difference─┬─non_empty_symmetric_difference─┐
│ []                         │ [3]                            │
└────────────────────────────┴────────────────────────────────┘
```
## arrayJaccardIndex {#arrayjaccardindex}

Возвращает [индекс Жаккара](https://en.wikipedia.org/wiki/Jaccard_index) для двух массивов.

**Пример**

Запрос:
```sql
SELECT arrayJaccardIndex([1, 2], [2, 3]) AS res
```

Результат:
```text
┌─res────────────────┐
│ 0.3333333333333333 │
└────────────────────┘
```
## arrayReduce {#arrayreduce}

Применяет агрегатную функцию к элементам массива и возвращает ее результат. Имя агрегатной функции передается в виде строки в одинарных кавычках `'max'`, `'sum'`. При использовании параметрических агрегатных функций параметр указывается после имени функции в скобках `'uniqUpTo(6)'`.

**Синтаксис**

```sql
arrayReduce(agg_func, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — Имя агрегатной функции, которая должна быть константной [строкой](../data-types/string.md).
- `arr` — Любое количество [array](/sql-reference/data-types/array) столбцов, передаваемых в качестве параметров агрегатной функции.

**Возвращаемое значение**

**Пример**

Запрос:

```sql
SELECT arrayReduce('max', [1, 2, 3]);
```

Результат:

```text
┌─arrayReduce('max', [1, 2, 3])─┐
│                             3 │
└───────────────────────────────┘
```

Если агрегатная функция принимает несколько аргументов, тогда эта функция должна применяться к нескольким массивам одинакового размера.

Запрос:

```sql
SELECT arrayReduce('maxIf', [3, 5], [1, 0]);
```

Результат:

```text
┌─arrayReduce('maxIf', [3, 5], [1, 0])─┐
│                                    3 │
└──────────────────────────────────────┘
```

Пример с параметрической агрегатной функцией:

Запрос:

```sql
SELECT arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
```

Результат:

```text
┌─arrayReduce('uniqUpTo(3)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])─┐
│                                                           4 │
└─────────────────────────────────────────────────────────────┘
```

**Смотрите также**

- [arrayFold](#arrayfold)
## arrayReduceInRanges {#arrayreduceinranges}

Применяет агрегатную функцию к элементам массива в заданных диапазонах и возвращает массив, содержащий результат для каждого диапазона. Функция вернет такой же результат, как и несколько `arrayReduce(agg_func, arraySlice(arr1, index, length), ...)`.

**Синтаксис**

```sql
arrayReduceInRanges(agg_func, ranges, arr1, arr2, ..., arrN)
```

**Аргументы**

- `agg_func` — Имя агрегатной функции, которая должна быть константной [строкой](../data-types/string.md).
- `ranges` — Диапазоны для агрегации, которые должны быть [массивом](/sql-reference/data-types/array) [кортежей](../data-types/tuple.md), содержащих индекс и длину каждого диапазона.
- `arr` — Любое количество [Array](/sql-reference/data-types/array) столбцов в качестве параметров агрегатной функции.

**Возвращаемое значение**

- Массив, содержащий результаты агрегатной функции по указанным диапазонам. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayReduceInRanges(
    'sum',
    [(1, 5), (2, 3), (3, 4), (4, 4)],
    [1000000, 200000, 30000, 4000, 500, 60, 7]
) AS res
```

Результат:

```text
┌─res─────────────────────────┐
│ [1234500,234000,34560,4567] │
└─────────────────────────────┘
```
## arrayFold {#arrayfold}

Применяет лямбда-функцию к одному или нескольким массивам одинакового размера и собирает результат в аккумулятор.

**Синтаксис**

```sql
arrayFold(lambda_function, arr1, arr2, ..., accumulator)
```

**Пример**

Запрос:

```sql
SELECT arrayFold( acc,x -> acc + x*2,  [1, 2, 3, 4], toInt64(3)) AS res;
```

Результат:

```text
┌─res─┐
│  23 │
└─────┘
```

**Пример с последовательностью Фибоначчи**

```sql
SELECT arrayFold( acc,x -> (acc.2, acc.2 + acc.1), range(number), (1::Int64, 0::Int64)).1 AS fibonacci
FROM numbers(1,10);

┌─fibonacci─┐
│         0 │
│         1 │
│         1 │
│         2 │
│         3 │
│         5 │
│         8 │
│        13 │
│        21 │
│        34 │
└───────────┘
```

**Смотрите также**

- [arrayReduce](#arrayreduce)
## arrayReverse {#arrayreverse}

Возвращает массив того же размера, что и оригинальный массив, содержащий элементы в обратном порядке.

**Синтаксис**

```sql
arrayReverse(arr)
```

Пример:

```sql
SELECT arrayReverse([1, 2, 3])
```

```text
┌─arrayReverse([1, 2, 3])─┐
│ [3,2,1]                 │
└─────────────────────────┘
```
## reverse(arr) {#reversearr}

Синоним для ["arrayReverse"](#arrayreverse)
## arrayFlatten {#arrayflatten}

Преобразует массив массивов в плоский массив.

Функция:

- Применяется к массивам любой глубины вложенности.
- Не изменяет массивы, которые уже плоские.

Плоский массив содержит все элементы из всех исходных массивов.

**Синтаксис**

```sql
flatten(array_of_arrays)
```

Псевдоним: `flatten`.

**Параметры**

- `array_of_arrays` — [Array](/sql-reference/data-types/array) массивов. Например, `[[1,2,3], [4,5]]`.

**Примеры**

```sql
SELECT flatten([[[1]], [[2], [3]]]);
```

```text
┌─flatten(array(array([1]), array([2], [3])))─┐
│ [1,2,3]                                     │
└─────────────────────────────────────────────┘
```
## arrayCompact {#arraycompact}

Удаляет последовательные дублирующиеся элементы из массива. Порядок значений в результате определяется порядком в исходном массиве.

**Синтаксис**

```sql
arrayCompact(arr)
```

**Аргументы**

`arr` — [array](/sql-reference/data-types/array), который нужно проверить.

**Возвращаемое значение**

Массив без дублирующихся значений. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayCompact([1, 1, nan, nan, 2, 3, 3, 3]);
```

Результат:

```text
┌─arrayCompact([1, 1, nan, nan, 2, 3, 3, 3])─┐
│ [1,nan,nan,2,3]                            │
└────────────────────────────────────────────┘
```
## arrayZip {#arrayzip}

Объединяет несколько массивов в один массив. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZip(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов. Все входные массивы должны иметь одинаковый размер.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже совпадают с типами входных массивов и находятся в том же порядке, в котором переданы массивы. [Array](/sql-reference/data-types/array).

**Пример**

Запрос:

```sql
SELECT arrayZip(['a', 'b', 'c'], [5, 2, 1]);
```

Результат:

```text
┌─arrayZip(['a', 'b', 'c'], [5, 2, 1])─┐
│ [('a',5),('b',2),('c',1)]            │
└──────────────────────────────────────┘
```
## arrayZipUnaligned {#arrayzipunaligned}

Объединяет несколько массивов в один массив, позволяя несогласованные массивы. Результирующий массив содержит соответствующие элементы исходных массивов, сгруппированные в кортежи в указанном порядке аргументов.

**Синтаксис**

```sql
arrayZipUnaligned(arr1, arr2, ..., arrN)
```

**Аргументы**

- `arrN` — [Array](/sql-reference/data-types/array).

Функция может принимать любое количество массивов разных типов.

**Возвращаемое значение**

- Массив с элементами из исходных массивов, сгруппированными в [кортежи](../data-types/tuple.md). Типы данных в кортеже совпадают с типами входных массивов и находятся в том же порядке, в котором переданы массивы. [Array](/sql-reference/data-types/array). Если массивы имеют разный размер, более короткие массивы будут дополнены значениями `null`.

**Пример**

Запрос:

```sql
SELECT arrayZipUnaligned(['a'], [1, 2, 3]);
```

Результат:

```text
┌─arrayZipUnaligned(['a'], [1, 2, 3])─┐
│ [('a',1),(NULL,2),(NULL,3)]         │
└─────────────────────────────────────┘
```
## arrayROCAUC {#arrayrocauc}

Вычисляет площадь под кривой характеристик получателя (ROC).
ROC-кривая создается путем построения графика доли истинных положительных результатов (TPR) по оси y и доли ложных положительных результатов (FPR) по оси x по всем порогам.
Результирующее значение варьируется от 0 до 1, при этом более высокое значение указывает на лучшую производительность модели.
ROC AUC (также известная просто как AUC) — это концепция в машинном обучении.
Для получения дополнительной информации смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayROCAUC(arr_scores, arr_labels[, scale[, arr_partial_offsets]])
```

Псевдоним: `arrayAUC`

**Аргументы**

- `arr_scores` — Оценки, которые модель предсказания дает. [Array](/sql-reference/data-types/array) целых чисел или [чисел с плавающей запятой](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Array](/sql-reference/data-types/array) целых чисел или [перечислений](../data-types/enum.md).
- `scale` — Определяет, возвращать ли нормализованную площадь. Если ложь, возвращает площадь под кривой TP (истинные положительные) x FP (ложные положительные) вместо этого. Значение по умолчанию: истина. [Bool](../data-types/boolean.md). Необязательный.
- `arr_partial_offsets` — Массив из четырех ненегативных целых чисел для вычисления частичной площади под кривой ROC (эквивалентной вертикальной полосе пространства ROC) вместо всей AUC. Эта опция полезна для распределенных вычислений ROC AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`, `total_negatives`]. [Array](/sql-reference/data-types/array) ненегативных [целых чисел](../data-types/int-uint.md). Необязательный.
    - `higher_partitions_tp`: Количество положительных меток в более высоких разделах.
    - `higher_partitions_fp`: Количество отрицательных меток в более высоких разделах.
    - `total_positives`: Общее количество положительных образцов в наборе данных.
    - `total_negatives`: Общее количество отрицательных образцов в наборе данных.

::::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны быть только частью всего набора данных, содержащей интервал оценок.
Набор данных должен делиться на смежные разделы, каждый из которых содержит подмножество данных, оценки которых находятся в определенном диапазоне.
Например:
- Один раздел может содержать все оценки в диапазоне [0, 0.5).
- Другой раздел может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой характеристик получателя (ROC). [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
select arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

```text
┌─arrayROCAUC([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                                             0.75 │
└──────────────────────────────────────────────────┘
```

## arrayAUCPR {#arrayaucpr}

Вызывает площадь под кривой precision-recall (PR).
Кривая точности-отзыва создается путем отображения точности по оси y и отзыва по оси x для всех порогов.
Результирующее значение варьируется от 0 до 1, где более высокое значение указывает на лучшую производительность модели.
PR AUC особенно полезен для несбалансированных наборов данных, предоставляя более четкое сравнение производительности по сравнению с ROC AUC в таких случаях.
Для получения более подробной информации, пожалуйста, смотрите [здесь](https://developers.google.com/machine-learning/glossary#pr-auc-area-under-the-pr-curve), [здесь](https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc#expandable-1) и [здесь](https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve).

**Синтаксис**

```sql
arrayAUCPR(arr_scores, arr_labels[, arr_partial_offsets])
```

Псевдоним: `arrayPRAUC`

**Аргументы**

- `arr_scores` — Оценки, которые возвращает модель предсказания. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Чисел с плавающей точкой](../data-types/float.md).
- `arr_labels` — Метки образцов, обычно 1 для положительного образца и 0 для отрицательного образца. [Массив](/sql-reference/data-types/array) [Целых чисел](../data-types/int-uint.md) или [Перечислений](../data-types/enum.md).
- `arr_partial_offsets` — Необязательный. [Массив](/sql-reference/data-types/array) из трех неотрицательных целых чисел для вычисления частичной площади под кривой PR (эквивалентно вертикальному диапазону пространства PR) вместо всей AUC. Эта опция полезна для распределенного вычисления PR AUC. Массив должен содержать следующие элементы [`higher_partitions_tp`, `higher_partitions_fp`, `total_positives`]. [Массив](/sql-reference/data-types/array) неотрицательных [Целых чисел](../data-types/int-uint.md). Необязательный.
    - `higher_partitions_tp`: Количество положительных меток в разделах с более высокими оценками.
    - `higher_partitions_fp`: Количество отрицательных меток в разделах с более высокими оценками.
    - `total_positives`: Общее количество положительных образцов в целом наборе данных.

::::note
Когда используется `arr_partial_offsets`, `arr_scores` и `arr_labels` должны быть только частью всего набора данных, содержащей интервал оценок.
Набор данных должен быть разделен на смежные разделы, где каждый раздел содержит подмножество данных, оценки которого находятся в пределах конкретного диапазона.
Например:
- Один раздел может содержать все оценки в диапазоне [0, 0.5).
- Другой раздел может содержать оценки в диапазоне [0.5, 1.0].
::::

**Возвращаемое значение**

Возвращает площадь под кривой точности-отзыва (PR). [Float64](../data-types/float.md).

**Пример**

Запрос:

```sql
select arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1]);
```

Результат:

```text
┌─arrayAUCPR([0.1, 0.4, 0.35, 0.8], [0, 0, 1, 1])─┐
│                              0.8333333333333333 │
└─────────────────────────────────────────────────┘
```

## arrayMap(func, arr1, ...) {#arraymapfunc-arr1-}

Возвращает массив, полученный из исходных массивов путем применения `func(arr1[i], ..., arrN[i])` для каждого элемента. Массивы `arr1` ... `arrN` должны иметь одинаковое количество элементов.

Примеры:

```sql
SELECT arrayMap(x -> (x + 2), [1, 2, 3]) as res;
```

```text
┌─res─────┐
│ [3,4,5] │
└─────────┘
```

Следующий пример показывает, как создать кортеж элементов из разных массивов:

```sql
SELECT arrayMap((x, y) -> (x, y), [1, 2, 3], [4, 5, 6]) AS res
```

```text
┌─res─────────────────┐
│ [(1,4),(2,5),(3,6)] │
└─────────────────────┘
```

Обратите внимание, что `arrayMap` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayFilter(func, arr1, ...) {#arrayfilterfunc-arr1-}

Возвращает массив, содержащий только элементы в `arr1`, для которых `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Примеры:

```sql
SELECT arrayFilter(x -> x LIKE '%World%', ['Hello', 'abc World']) AS res
```

```text
┌─res───────────┐
│ ['abc World'] │
└───────────────┘
```

```sql
SELECT
    arrayFilter(
        (i, x) -> x LIKE '%World%',
        arrayEnumerate(arr),
        ['Hello', 'abc World'] AS arr)
    AS res
```

```text
┌─res─┐
│ [2] │
└─────┘
```

Обратите внимание, что `arrayFilter` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayFill(func, arr1, ...) {#arrayfillfunc-arr1-}

Сканирует `arr1` от первого элемента до последнего и заменяет `arr1[i]` на `arr1[i - 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Первый элемент `arr1` заменяться не будет.

Примеры:

```sql
SELECT arrayFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

```text
┌─res──────────────────────────────┐
│ [1,1,3,11,12,12,12,5,6,14,14,14] │
└──────────────────────────────────┘
```

Обратите внимание, что `arrayFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayReverseFill(func, arr1, ...) {#arrayreversefillfunc-arr1-}

Сканирует `arr1` от последнего элемента до первого и заменяет `arr1[i]` на `arr1[i + 1]`, если `func(arr1[i], ..., arrN[i])` возвращает 0. Последний элемент `arr1` заменяться не будет.

Примеры:

```sql
SELECT arrayReverseFill(x -> not isNull(x), [1, null, 3, 11, 12, null, null, 5, 6, 14, null, null]) AS res
```

```text
┌─res────────────────────────────────┐
│ [1,3,3,11,12,5,5,5,6,14,NULL,NULL] │
└────────────────────────────────────┘
```

Обратите внимание, что `arrayReverseFill` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arraySplit(func, arr1, ...) {#arraysplitfunc-arr1-}

Разделяет `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, массив будет разделен с левой стороны элемента. Массив не будет разделен перед первым элементом.

Примеры:

```sql
SELECT arraySplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```text
┌─res─────────────┐
│ [[1,2,3],[4,5]] │
└─────────────────┘
```

Обратите внимание, что `arraySplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayReverseSplit(func, arr1, ...) {#arrayreversesplitfunc-arr1-}

Разделяет `arr1` на несколько массивов. Когда `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, массив будет разделен с правой стороны элемента. Массив не будет разделен после последнего элемента.

Примеры:

```sql
SELECT arrayReverseSplit((x, y) -> y, [1, 2, 3, 4, 5], [1, 0, 0, 1, 0]) AS res
```

```text
┌─res───────────────┐
│ [[1],[2,3,4],[5]] │
└───────────────────┘
```

Обратите внимание, что `arrayReverseSplit` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayExists(\[func,\] arr1, ...) {#arrayexistsfunc-arr1-}

Возвращает 1, если в `arr` есть по крайней мере один элемент, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0. В противном случае возвращает 0.

Обратите внимание, что `arrayExists` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayAll(\[func,\] arr1, ...) {#arrayallfunc-arr1-}

Возвращает 1, если `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, для всех элементов массивов. В противном случае возвращает 0.

Обратите внимание, что `arrayAll` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayFirst(func, arr1, ...) {#arrayfirstfunc-arr1-}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.
## arrayFirstOrNull {#arrayfirstornull}

Возвращает первый элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, иначе возвращает `NULL`.

**Синтаксис**

```sql
arrayFirstOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Первый элемент в переданном массиве.
- В противном случае возвращает `NULL`

**Детали реализации**

Обратите внимание, что `arrayFirstOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.

**Пример**

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
2
```

Запрос:

```sql
SELECT arrayFirstOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```

Запрос:

```sql
SELECT arrayLastOrNull((x,f) -> f, [1,2,3,NULL], [0,1,0,1]);
```

Результат:

```response
\N
```
## arrayLast(func, arr1, ...) {#arraylastfunc-arr1-}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Обратите внимание, что `arrayLast` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayLastOrNull {#arraylastornull}

Возвращает последний элемент в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0, иначе возвращает `NULL`.

**Синтаксис**

```sql
arrayLastOrNull(func, arr1, ...)
```

**Параметры**

- `func`: Лямбда-функция. [Лямбда-функция](/sql-reference/functions/overview#higher-order-functions).
- `arr1`: Массив для обработки. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Последний элемент в переданном массиве.
- В противном случае возвращает `NULL`

**Детали реализации**

Обратите внимание, что `arrayLastOrNull` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.

**Пример**

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, [1, 2, 3]);
```

Результат:

```response
3
```

Запрос:

```sql
SELECT arrayLastOrNull(x -> x >= 2, emptyArrayUInt8());
```

Результат:

```response
\N
```
## arrayFirstIndex(func, arr1, ...) {#arrayfirstindexfunc-arr1-}

Возвращает индекс первого элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Обратите внимание, что `arrayFirstIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayLastIndex(func, arr1, ...) {#arraylastindexfunc-arr1-}

Возвращает индекс последнего элемента в массиве `arr1`, для которого `func(arr1[i], ..., arrN[i])` возвращает что-то, отличное от 0.

Обратите внимание, что `arrayLastIndex` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы должны передать ей лямбда-функцию в качестве первого аргумента, и ее нельзя опустить.
## arrayMin {#arraymin}

Возвращает минимум элементов в исходном массиве.

Если указана функция `func`, возвращает минимум элементов, преобразованных этой функцией.

Обратите внимание, что `arrayMin` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayMin([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Минимум значений функции (или минимум массива).

:::note
Если указана `func`, тогда возвращаемый тип соответствует типу возвращаемого значения `func`, в противном случае он соответствует типу элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMin([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   1 │
└─────┘
```

Запрос:

```sql
SELECT arrayMin(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -4 │
└─────┘
```
## arrayMax {#arraymax}

Возвращает максимум элементов в исходном массиве.

Если указана функция `func`, возвращает максимум элементов, преобразованных этой функцией.

Обратите внимание, что `arrayMax` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayMax([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Максимум значений функции (или максимум массива).

:::note
Если указана `func`, тогда возвращаемый тип соответствует типу возвращаемого значения `func`, в противном случае он соответствует типу элементов массива.
:::

**Примеры**

Запрос:

```sql
SELECT arrayMax([1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│   4 │
└─────┘
```

Запрос:

```sql
SELECT arrayMax(x -> (-x), [1, 2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  -1 │
└─────┘
```
## arraySum {#arraysum}

Возвращает сумму элементов в исходном массиве.

Если указана функция `func`, возвращает сумму элементов, преобразованных этой функции.

Обратите внимание, что `arraySum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arraySum([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Сумма значений функции (или сумма массива).

:::note
Тип возвращаемого значения:

- Для десятичных чисел в исходном массиве (или для преобразованных значений, если `func` указана) — [Decimal128](../data-types/decimal.md).
- Для чисел с плавающей точкой — [Float64](../data-types/float.md).
- Для беззнаковых чисел — [UInt64](../data-types/int-uint.md).
- Для знаковых чисел — [Int64](../data-types/int-uint.md).
:::

**Примеры**

Запрос:

```sql
SELECT arraySum([2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│   5 │
└─────┘
```

Запрос:

```sql
SELECT arraySum(x -> x*x, [2, 3]) AS res;
```

Результат:

```text
┌─res─┐
│  13 │
└─────┘
```
## arrayAvg {#arrayavg}

Возвращает среднее значение элементов в исходном массиве.

Если указана функция `func`, возвращает среднее значение элементов, преобразованных этой функцией.

Обратите внимание, что `arrayAvg` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.

**Синтаксис**

```sql
arrayAvg([func,] arr)
```

**Аргументы**

- `func` — Функция. [Выражение](../data-types/special-data-types/expression.md).
- `arr` — Массив. [Массив](/sql-reference/data-types/array).

**Возвращаемое значение**

- Среднее значение функций (или среднее значение массива). [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayAvg([1, 2, 4]) AS res;
```

Результат:

```text
┌────────────────res─┐
│ 2.3333333333333335 │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayAvg(x -> (x * x), [2, 4]) AS res;
```

Результат:

```text
┌─res─┐
│  10 │
└─────┘
```
## arrayCumSum(\[func,\] arr1, ...) {#arraycumsumfunc-arr1-}

Возвращает массив частичных (накопительных) сумм элементов в исходном массиве `arr1`. Если указана `func`, тогда сумма вычисляется с помощью применения `func` к `arr1`, `arr2`, ..., `arrN`, т.е. `func(arr1[i], ..., arrN[i])`.

**Синтаксис**

```sql
arrayCumSum(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив частичных сумм элементов в исходном массиве. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float/).

Пример:

```sql
SELECT arrayCumSum([1, 1, 1, 1]) AS res
```

```text
┌─res──────────┐
│ [1, 2, 3, 4] │
└──────────────┘
```

Обратите внимание, что `arrayCumSum` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayCumSumNonNegative(\[func,\] arr1, ...) {#arraycumsumnonnegativefunc-arr1-}

То же самое, что и `arrayCumSum`, возвращает массив частичных (накопительных) сумм элементов в исходном массиве. Если указана `func`, тогда сумма вычисляется с помощью применения `func` к `arr1`, `arr2`, ..., `arrN`, т.е. `func(arr1[i], ..., arrN[i])`. В отличие от `arrayCumSum`, если текущая накопительная сумма меньше 0, она заменяется на 0.

**Синтаксис**

```sql
arrayCumSumNonNegative(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Возвращает массив неотрицательных частичных сумм элементов в исходном массиве. [UInt*](/sql-reference/data-types/int-uint#integer-ranges), [Int*](/sql-reference/data-types/int-uint#integer-ranges), [Float*](/sql-reference/data-types/float/).

```sql
SELECT arrayCumSumNonNegative([1, 1, -4, 1]) AS res
```

```text
┌─res───────┐
│ [1,2,0,1] │
└───────────┘
```

Обратите внимание, что `arraySumNonNegative` является [функцией высшего порядка](/sql-reference/functions/overview#higher-order-functions). Вы можете передать ей лямбда-функцию в качестве первого аргумента.
## arrayProduct {#arrayproduct}

Умножает элементы [массива](/sql-reference/data-types/array).

**Синтаксис**

```sql
arrayProduct(arr)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array) числовых значений.

**Возвращаемое значение**

- Произведение элементов массива. [Float64](../data-types/float.md).

**Примеры**

Запрос:

```sql
SELECT arrayProduct([1,2,3,4,5,6]) as res;
```

Результат:

```text
┌─res───┐
│ 720   │
└───────┘
```

Запрос:

```sql
SELECT arrayProduct([toDecimal64(1,8), toDecimal64(2,8), toDecimal64(3,8)]) as res, toTypeName(res);
```

Тип возвращаемого значения всегда [Float64](../data-types/float.md). Результат:

```text
┌─res─┬─toTypeName(arrayProduct(array(toDecimal64(1, 8), toDecimal64(2, 8), toDecimal64(3, 8))))─┐
│ 6   │ Float64                                                                                  │
└─────┴──────────────────────────────────────────────────────────────────────────────────────────┘
```
## arrayRotateLeft {#arrayrotateleft}

Поворачивает [массив](/sql-reference/data-types/array) влево на указанное количество элементов.
Если количество элементов отрицательное, массив поворачивается вправо.

**Синтаксис**

```sql
arrayRotateLeft(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для поворота.

**Возвращаемое значение**

- Массив, повёрнутый влево на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRotateLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateLeft(['a','b','c','d','e'], 3) as res;
```

Результат:

```text
┌─res───────────────────┐
│ ['d','e','a','b','c'] │
└───────────────────────┘
```
## arrayRotateRight {#arrayrotateright}

Поворачивает [массив](/sql-reference/data-types/array) вправо на указанное количество элементов.
Если количество элементов отрицательное, массив поворачивается влево.

**Синтаксис**

```sql
arrayRotateRight(arr, n)
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для поворота.

**Возвращаемое значение**

- Массив, повёрнутый вправо на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRotateRight([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [5,6,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateRight([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,1,2] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRotateRight(['a','b','c','d','e'], 3) as res;
```

Результат:

```text
┌─res───────────────────┐
│ ['c','d','e','a','b'] │
└───────────────────────┘
```
## arrayShiftLeft {#arrayshiftleft}

Сдвигает [массив](/sql-reference/data-types/array) влево на указанное количество элементов.
Новые элементы заполняются предоставленным аргументом или значением по умолчанию для типа элемента массива.
Если количество элементов отрицательное, массив сдвигается вправо.

**Синтаксис**

```sql
arrayShiftLeft(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательный. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый влево на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

```text
┌─res─────────────┐
│ [3,4,5,6,42,42] │
└─────────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

```text
┌─res─────────────────────────────┐
│ ['d','e','f','foo','foo','foo'] │
└─────────────────────────────────┘
```

Запрос:

```sql
SELECT arrayShiftLeft([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

```text
┌─res─────────────────┐
│ [3,4,5,6,4242,4242] │
└─────────────────────┘
```
## arrayShiftRight {#arrayshiftright}

Сдвигает [массив](/sql-reference/data-types/array) вправо на указанное количество элементов.
Новые элементы заполняются предоставленным аргументом или значением по умолчанию для типа элемента массива.
Если количество элементов отрицательное, массив сдвигается влево.

**Синтаксис**

```sql
arrayShiftRight(arr, n[, default])
```

**Аргументы**

- `arr` — [Массив](/sql-reference/data-types/array).
- `n` — Количество элементов для сдвига.
- `default` — Необязательный. Значение по умолчанию для новых элементов.

**Возвращаемое значение**

- Массив, сдвинутый вправо на указанное количество элементов. [Массив](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2) as res;
```

Результат:

```text
┌─res───────────┐
│ [0,0,1,2,3,4] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], -2) as res;
```

Результат:

```text
┌─res───────────┐
│ [3,4,5,6,0,0] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6], 2, 42) as res;
```

Результат:

```text
┌─res─────────────┐
│ [42,42,1,2,3,4] │
└─────────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight(['a','b','c','d','e','f'], 3, 'foo') as res;
```

Результат:

```text
┌─res─────────────────────────────┐
│ ['foo','foo','foo','a','b','c'] │
└─────────────────────────────────┘
```

Запрос:

```sql
SELECT arrayShiftRight([1,2,3,4,5,6] :: Array(UInt16), 2, 4242) as res;
```

Результат:

```text
┌─res─────────────────┐
│ [4242,4242,1,2,3,4] │
└─────────────────────┘
```
## arrayRandomSample {#arrayrandomsample}

Функция `arrayRandomSample` возвращает подмассив с `samples`-количеством случайных элементов из входного массива. Если `samples` превышает размер входного массива, размер выборки ограничивается размером массива, т.е. возвращаются все элементы массива, но их порядок не гарантируется. Функция может обрабатывать как плоские массивы, так и вложенные массивы.

**Синтаксис**

```sql
arrayRandomSample(arr, samples)
```

**Аргументы**

- `arr` — Входной массив, из которого нужно выбрать элементы. ([Array(T)](/sql-reference/data-types/array))
- `samples` — Количество элементов, которые нужно включить в случайную выборку ([UInt*](../data-types/int-uint.md))

**Возвращаемое значение**

- Массив, содержащий случайную выборку элементов из входного массива. [Array](/sql-reference/data-types/array).

**Примеры**

Запрос:

```sql
SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;
```

Результат:

```response
┌─res────────────────┐
│ ['cherry','apple'] │
└────────────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;
```

Результат:

```response
┌─res───────────┐
│ [[3,4],[5,6]] │
└───────────────┘
```

Запрос:

```sql
SELECT arrayRandomSample([1, 2, 3], 5) as res;
```

Результат:

```response
┌─res─────┐
│ [3,1,2] │
└─────────┘
```
## arrayNormalizedGini {#arraynormalizedgini}

Вычисляет нормализованный коэффициент Джини.

**Синтаксис**

```sql
arrayNormalizedGini(predicted, label)
```

**Аргументы**

- `predicted` — Предсказанные значения ([Array(T)](/sql-reference/data-types/array))
- `label` — Фактические значения ([Array(T)](/sql-reference/data-types/array))

**Возвращаемое значение**

- Кортеж, содержащий коэффициенты Джини предсказанных значений, коэффициент Джини нормализованных значений и нормализованный коэффициент Джини (= отношение первых двух коэффициентов Джини).

**Примеры**

Запрос:

```sql
SELECT arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2]);
```

Результат:

```response
┌─arrayNormalizedGini([0.9, 0.3, 0.8, 0.7], [6, 1, 0, 2])──────────┐
│ (0.18055555555555558,0.2638888888888889,0.6842105263157896) │
└─────────────────────────────────────────────────────────────┘
```
## arrayLevenshteinDistance {#arraylevenshteindistance}

Вычисляет расстояние Левенштейна для двух массивов.

**Синтаксис**

```sql
arrayLevenshteinDistance(from, to)
```

**Аргументы**

- `from` — первый массив
- `to` — второй массив

**Возвращаемое значение**

- Расстояние Левенштейна между первым и вторым массивами

**Примеры**

Запрос:

```sql
SELECT arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])
```

Результат:

```text

┌─arrayLevenshteinDistance([1, 2, 4], [1, 2, 3])─┐
│                                              1 │
└────────────────────────────────────────────────┘

```
## arrayLevenshteinDistanceWeighted {#arraylevenshteindistanceweighted}

Вычисляет расстояние Левенштейна для двух массивов с пользовательскими весами для каждого элемента. Количество элементов массива и его веса должны совпадать.

**Синтаксис**

```sql
arrayLevenshteinDistanceWeighted(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив
- `to` — второй массив
- `from_weights` — веса для первого массива
- `to_weights` — веса для второго массива

**Возвращаемое значение**

- Расстояние Левенштейна между первым и вторым массивами с пользовательскими весами для каждого элемента

**Примеры**

Запрос:

```sql
SELECT arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

Результат:

```text

┌─arrayLevenshteinDistanceWeighted(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])─┐
│                                                                                           14 │
└──────────────────────────────────────────────────────────────────────────────────────────────┘

```
## arraySimilarity {#arraysimilarity}

Вычисляет сходство массивов от 0 до 1 на основе взвешенного расстояния Левенштейна. Принимает те же аргументы, что и функция `arrayLevenshteinDistanceWeighted`.

**Синтаксис**

```sql
arraySimilarity(from, to, from_weights, to_weights)
```

**Аргументы**

- `from` — первый массив
- `to` — второй массив
- `from_weights` — веса для первого массива
- `to_weights` — веса для второго массива

**Возвращаемое значение**

- Сходство двух массивов на основе взвешенного расстояния Левенштейна

**Примеры**

Запрос:

```sql
SELECT arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])
```

Результат:

```text

┌─arraySimilarity(['A', 'B', 'C'], ['A', 'K', 'L'], [1.0, 2, 3], [3.0, 4, 5])─┐
│                                                          0.2222222222222222 │
└─────────────────────────────────────────────────────────────────────────────┘

```
## Distance functions {#distance-functions}

Все поддерживаемые функции описаны в [документации по функции расстояния](../../sql-reference/functions/distance-functions.md).
