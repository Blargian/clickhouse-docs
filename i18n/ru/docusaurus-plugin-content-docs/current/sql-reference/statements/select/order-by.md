---
description: 'Документация для оператора ORDER BY'
sidebar_label: 'ORDER BY'
slug: /sql-reference/statements/select/order-by
title: 'Оператор ORDER BY'
---


# Оператор ORDER BY

Оператор `ORDER BY` содержит

- список выражений, например, `ORDER BY visits, search_phrase`,
- список чисел, относящихся к колонкам в операторе `SELECT`, например, `ORDER BY 2, 1`, или
- `ALL`, который означает все колонки оператора `SELECT`, например, `ORDER BY ALL`.

Чтобы отключить сортировку по номерам колонок, установите настройку [enable_positional_arguments](/operations/settings/settings#enable_positional_arguments) = 0.
Чтобы отключить сортировку по `ALL`, установите настройку [enable_order_by_all](/operations/settings/settings#enable_order_by_all) = 0.

Оператор `ORDER BY` может быть атрибутирован модификатором `DESC` (по убыванию) или `ASC` (по возрастанию), который определяет направление сортировки.
Если явный порядок сортировки не указан, по умолчанию используется `ASC`.
Направление сортировки применяется к одному выражению, а не ко всему списку, например, `ORDER BY Visits DESC, SearchPhrase`.
Также сортировка выполняется с учетом регистра.

Строки с одинаковыми значениями для выражений сортировки возвращаются в произвольном и недетерминированном порядке.
Если оператор `ORDER BY` опущен в операторе `SELECT`, порядок строк также произвольный и недетерминированный.

## Сортировка специальных значений {#sorting-of-special-values}

Существует два подхода к порядку сортировки `NaN` и `NULL`:

- По умолчанию или с модификатором `NULLS LAST`: сначала значения, затем `NaN`, затем `NULL`.
- С модификатором `NULLS FIRST`: сначала `NULL`, затем `NaN`, затем другие значения.

### Пример {#example}

Для таблицы

```text
┌─x─┬────y─┐
│ 1 │ ᴺᵁᴸᴸ │
│ 2 │    2 │
│ 1 │  nan │
│ 2 │    2 │
│ 3 │    4 │
│ 5 │    6 │
│ 6 │  nan │
│ 7 │ ᴺᵁᴸᴸ │
│ 6 │    7 │
│ 8 │    9 │
└───┴──────┘
```

Запустите запрос `SELECT * FROM t_null_nan ORDER BY y NULLS FIRST`, чтобы получить:

```text
┌─x─┬────y─┐
│ 1 │ ᴺᵁᴸᴸ │
│ 7 │ ᴺᵁᴸᴸ │
│ 1 │  nan │
│ 6 │  nan │
│ 2 │    2 │
│ 2 │    2 │
│ 3 │    4 │
│ 5 │    6 │
│ 6 │    7 │
│ 8 │    9 │
└───┴──────┘
```

При сортировке чисел с плавающей запятой `NaN` отделены от других значений. Независимо от порядка сортировки, `NaN` располагаются в конце. Иными словами, для сортировки по возрастанию они размещены так, как будто они больше всех остальных чисел, в то время как для сортировки по убыванию они размещены так, как будто они меньше остальных.

## Поддержка сортировки {#collation-support}

Для сортировки по значениям [String](../../../sql-reference/data-types/string.md) вы можете указать коллицию (сравнение). Пример: `ORDER BY SearchPhrase COLLATE 'tr'` - для сортировки по ключевым словам в порядке возрастания, используя турецкий алфавит, без учета регистра, предполагая, что строки закодированы в UTF-8. `COLLATE` может быть указан или не указан для каждого выражения в ORDER BY независимо. Если указан `ASC` или `DESC`, `COLLATE` указывается после него. При использовании `COLLATE` сортировка всегда нечувствительна к регистру.

Поддержка коллиции имеется в [LowCardinality](../../../sql-reference/data-types/lowcardinality.md), [Nullable](../../../sql-reference/data-types/nullable.md), [Array](../../../sql-reference/data-types/array.md) и [Tuple](../../../sql-reference/data-types/tuple.md).

Мы рекомендуем использовать `COLLATE` только для окончательной сортировки небольшого числа строк, так как сортировка с помощью `COLLATE` менее эффективна, чем обычная сортировка по байтам.

## Примеры коллиции {#collation-examples}

Пример только с значениями [String](../../../sql-reference/data-types/string.md):

Исходная таблица:

```text
┌─x─┬─s────┐
│ 1 │ bca  │
│ 2 │ ABC  │
│ 3 │ 123a │
│ 4 │ abc  │
│ 5 │ BCA  │
└───┴──────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```text
┌─x─┬─s────┐
│ 3 │ 123a │
│ 4 │ abc  │
│ 2 │ ABC  │
│ 1 │ bca  │
│ 5 │ BCA  │
└───┴──────┘
```

Пример с [Nullable](../../../sql-reference/data-types/nullable.md):

Исходная таблица:

```text
┌─x─┬─s────┐
│ 1 │ bca  │
│ 2 │ ᴺᵁᴸᴸ │
│ 3 │ ABC  │
│ 4 │ 123a │
│ 5 │ abc  │
│ 6 │ ᴺᵁᴸᴸ │
│ 7 │ BCA  │
└───┴──────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```text
┌─x─┬─s────┐
│ 4 │ 123a │
│ 5 │ abc  │
│ 3 │ ABC  │
│ 1 │ bca  │
│ 7 │ BCA  │
│ 6 │ ᴺᵁᴸᴸ │
│ 2 │ ᴺᵁᴸᴸ │
└───┴──────┘
```

Пример с [Array](../../../sql-reference/data-types/array.md):

Исходная таблица:

```text
┌─x─┬─s─────────────┐
│ 1 │ ['Z']         │
│ 2 │ ['z']         │
│ 3 │ ['a']         │
│ 4 │ ['A']         │
│ 5 │ ['z','a']     │
│ 6 │ ['z','a','a'] │
│ 7 │ ['']          │
└───┴───────────────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```text
┌─x─┬─s─────────────┐
│ 7 │ ['']          │
│ 3 │ ['a']         │
│ 4 │ ['A']         │
│ 2 │ ['z']         │
│ 5 │ ['z','a']     │
│ 6 │ ['z','a','a'] │
│ 1 │ ['Z']         │
└───┴───────────────┘
```

Пример со строкой [LowCardinality](../../../sql-reference/data-types/lowcardinality.md):

Исходная таблица:

```response
┌─x─┬─s───┐
│ 1 │ Z   │
│ 2 │ z   │
│ 3 │ a   │
│ 4 │ A   │
│ 5 │ za  │
│ 6 │ zaa │
│ 7 │     │
└───┴─────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```response
┌─x─┬─s───┐
│ 7 │     │
│ 3 │ a   │
│ 4 │ A   │
│ 2 │ z   │
│ 1 │ Z   │
│ 5 │ za  │
│ 6 │ zaa │
└───┴─────┘
```

Пример с [Tuple](../../../sql-reference/data-types/tuple.md):

```response
┌─x─┬─s───────┐
│ 1 │ (1,'Z') │
│ 2 │ (1,'z') │
│ 3 │ (1,'a') │
│ 4 │ (2,'z') │
│ 5 │ (1,'A') │
│ 6 │ (2,'Z') │
│ 7 │ (2,'A') │
└───┴─────────┘
```

Запрос:

```sql
SELECT * FROM collate_test ORDER BY s ASC COLLATE 'en';
```

Результат:

```response
┌─x─┬─s───────┐
│ 3 │ (1,'a') │
│ 5 │ (1,'A') │
│ 2 │ (1,'z') │
│ 1 │ (1,'Z') │
│ 7 │ (2,'A') │
│ 4 │ (2,'z') │
│ 6 │ (2,'Z') │
└───┴─────────┘
```

## Детали реализации {#implementation-details}

Используется меньше оперативной памяти, если указано достаточно маленькое значение [LIMIT](../../../sql-reference/statements/select/limit.md) наряду с `ORDER BY`. В противном случае количество используемой памяти пропорционально объему данных для сортировки. При распределенной обработке запросов, если [GROUP BY](/sql-reference/statements/select/group-by) опущен, сортировка частично выполняется на удаленных серверах, а результаты объединяются на сервере, который обрабатывает запрос. Это означает, что для распределенной сортировки объем данных для сортировки может превышать количество памяти на одном сервере.

Если оперативной памяти недостаточно, возможно выполнение сортировки во внешней памяти (создание временных файлов на диске). Используйте настройку `max_bytes_before_external_sort` для этой цели. Если она установлена в 0 (по умолчанию), внешняя сортировка отключена. Если она включена, когда объем данных для сортировки достигает указанного числа байтов, собранные данные сортируются и выгружаются во временный файл. После того как все данные прочитаны, все отсортированные файлы объединяются и результаты выводятся. Файлы записываются в каталог `/var/lib/clickhouse/tmp/` в конфигурации (по умолчанию, но вы можете использовать параметр `tmp_path`, чтобы изменить эту настройку).

Запуск запроса может использовать больше памяти, чем `max_bytes_before_external_sort`. По этой причине это значение должно быть значительно меньше, чем `max_memory_usage`. Например, если на вашем сервере 128 ГБ ОЗУ и вам нужно запустить один запрос, установите `max_memory_usage` на 100 ГБ, а `max_bytes_before_external_sort` на 80 ГБ.

Внешняя сортировка работает значительно менее эффективно, чем сортировка в оперативной памяти.

## Оптимизация чтения данных {#optimization-of-data-reading}

Если выражение `ORDER BY` имеет префикс, совпадающий с ключом сортировки таблицы, вы можете оптимизировать запрос с помощью настройки [optimize_read_in_order](../../../operations/settings/settings.md#optimize_read_in_order).

Когда настройка `optimize_read_in_order` включена, сервер ClickHouse использует индекс таблицы и читает данные в порядке ключа `ORDER BY`. Это позволяет избежать чтения всех данных в случае указанного [LIMIT](../../../sql-reference/statements/select/limit.md). Таким образом, запросы на больших данных с небольшим лимитом обрабатываются быстрее.

Оптимизация работает как с `ASC`, так и с `DESC` и не работает совместно с оператором [GROUP BY](/sql-reference/statements/select/group-by) и модификатором [FINAL](/sql-reference/statements/select/from#final-modifier).

Когда настройка `optimize_read_in_order` отключена, сервер ClickHouse не использует индекс таблицы при обработке запросов `SELECT`.

Рекомендуется отключить `optimize_read_in_order` вручную при выполнении запросов с оператором `ORDER BY`, большим значением `LIMIT` и условием [WHERE](../../../sql-reference/statements/select/where.md), которое требует чтения огромного количества записей до того, как будут найдены запрашиваемые данные.

Оптимизация поддерживается в следующих движках таблиц:

- [MergeTree](../../../engines/table-engines/mergetree-family/mergetree.md) (включая [материализованные представления](/sql-reference/statements/create/view#materialized-view)),
- [Merge](../../../engines/table-engines/special/merge.md),
- [Buffer](../../../engines/table-engines/special/buffer.md)

В таблицах движка `MaterializedView` оптимизация работает с представлениями, такими как `SELECT ... FROM merge_tree_table ORDER BY pk`. Но она не поддерживается в запросах, таких как `SELECT ... FROM view ORDER BY pk`, если запрос представления не содержит оператора `ORDER BY`.

## Модификатор ORDER BY Expr WITH FILL {#order-by-expr-with-fill-modifier}

Этот модификатор также можно комбинировать с [LIMIT ... WITH TIES modifier](/sql-reference/statements/select/limit#limit--with-ties-modifier).

Модификатор `WITH FILL` может быть установлен после `ORDER BY expr` с необязательными параметрами `FROM expr`, `TO expr` и `STEP expr`.
Все пропущенные значения в колонке `expr` будут заполнены последовательно, а другие колонки будут заполнены по умолчанию.

Чтобы заполнить несколько колонок, добавьте модификатор `WITH FILL` с необязательными параметрами после каждого имени поля в разделе `ORDER BY`.

```sql
ORDER BY expr [WITH FILL] [FROM const_expr] [TO const_expr] [STEP const_numeric_expr] [STALENESS const_numeric_expr], ... exprN [WITH FILL] [FROM expr] [TO expr] [STEP numeric_expr] [STALENESS numeric_expr]
[INTERPOLATE [(col [AS expr], ... colN [AS exprN])]]
```

`WITH FILL` можно применять к полям с числовыми типами (всем типам float, decimal, int) или типами Date/DateTime. Когда применяется к полям типа `String`, пропущенные значения заполняются пустыми строками.
Когда `FROM const_expr` не определен, последовательность заполнения использует минимальное значение поля `expr` из `ORDER BY`.
Когда `TO const_expr` не определен, последовательность заполнения использует максимальное значение поля `expr` из `ORDER BY`.
Когда `STEP const_numeric_expr` определено, то `const_numeric_expr` интерпретируется как таковое для числовых типов, как `дни` для типов Date, как `секунды` для типов DateTime. Также поддерживается тип данных [INTERVAL](/sql-reference/data-types/special-data-types/interval/), представляющий временные и датированные интервалы.
Когда `STEP const_numeric_expr` опущен, последовательность заполнения использует `1.0` для числового типа, `1 day` для типа Date и `1 second` для типа DateTime.
Когда `STALENESS const_numeric_expr` определен, запрос будет генерировать строки, пока разница между предыдущей строкой в оригинальных данных не превысит `const_numeric_expr`.
`INTERPOLATE` можно применять к колонкам, не участвующим в `ORDER BY WITH FILL`. Такие колонки заполняются на основе значений предыдущих полей с применением `expr`. Если `expr` отсутствует, будет повторено предыдущее значение. Опущенный список приведет к включению всех разрешенных колонок.

Пример запроса без `WITH FILL`:

```sql
SELECT n, source FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n;
```

Результат:

```text
┌─n─┬─source───┐
│ 1 │ original │
│ 4 │ original │
│ 7 │ original │
└───┴──────────┘
```

Тот же запрос после применения модификатора `WITH FILL`:

```sql
SELECT n, source FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;
```

Результат:

```text
┌───n─┬─source───┐
│   0 │          │
│ 0.5 │          │
│   1 │ original │
│ 1.5 │          │
│   2 │          │
│ 2.5 │          │
│   3 │          │
│ 3.5 │          │
│   4 │ original │
│ 4.5 │          │
│   5 │          │
│ 5.5 │          │
│   7 │ original │
└─────┴──────────┘
```

В случае с несколькими полями `ORDER BY field2 WITH FILL, field1 WITH FILL` порядок заполнения будет следовать порядку полей в операторе `ORDER BY`.

Пример:

```sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d2 WITH FILL,
    d1 WITH FILL STEP 5;
```

Результат:

```text
┌───d1───────┬───d2───────┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-01 │ 1970-01-03 │          │
│ 1970-01-01 │ 1970-01-04 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-01-01 │ 1970-01-06 │          │
│ 1970-01-01 │ 1970-01-07 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Поле `d1` не заполняется и использует значение по умолчанию, так как у нас нет повторяющихся значений для значения `d2`, и последовательность для `d1` не может быть правильно рассчитана.

Следующий запрос с изменением поля в `ORDER BY`:

```sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d1 WITH FILL STEP 5,
    d2 WITH FILL;
```

Результат:

```text
┌───d1───────┬───d2───────┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-16 │ 1970-01-01 │          │
│ 1970-01-21 │ 1970-01-01 │          │
│ 1970-01-26 │ 1970-01-01 │          │
│ 1970-01-31 │ 1970-01-01 │          │
│ 1970-02-05 │ 1970-01-01 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
│ 1970-02-15 │ 1970-01-01 │          │
│ 1970-02-20 │ 1970-01-01 │          │
│ 1970-02-25 │ 1970-01-01 │          │
│ 1970-03-02 │ 1970-01-01 │          │
│ 1970-03-07 │ 1970-01-01 │          │
│ 1970-03-12 │ 1970-01-08 │ original │
└────────────┴────────────┴──────────┘
```

Следующий запрос использует тип данных `INTERVAL` на 1 день для каждого заполненного значения в колонке `d1`:

```sql
SELECT
    toDate((number * 10) * 86400) AS d1,
    toDate(number * 86400) AS d2,
    'original' AS source
FROM numbers(10)
WHERE (number % 3) = 1
ORDER BY
    d1 WITH FILL STEP INTERVAL 1 DAY,
    d2 WITH FILL;
```

Результат:
```response
┌─────────d1─┬─────────d2─┬─source───┐
│ 1970-01-11 │ 1970-01-02 │ original │
│ 1970-01-12 │ 1970-01-01 │          │
│ 1970-01-13 │ 1970-01-01 │          │
│ 1970-01-14 │ 1970-01-01 │          │
│ 1970-01-15 │ 1970-01-01 │          │
│ 1970-01-16 │ 1970-01-01 │          │
│ 1970-01-17 │ 1970-01-01 │          │
│ 1970-01-18 │ 1970-01-01 │          │
│ 1970-01-19 │ 1970-01-01 │          │
│ 1970-01-20 │ 1970-01-01 │          │
│ 1970-01-21 │ 1970-01-01 │          │
│ 1970-01-22 │ 1970-01-01 │          │
│ 1970-01-23 │ 1970-01-01 │          │
│ 1970-01-24 │ 1970-01-01 │          │
│ 1970-01-25 │ 1970-01-01 │          │
│ 1970-01-26 │ 1970-01-01 │          │
│ 1970-01-27 │ 1970-01-01 │          │
│ 1970-01-28 │ 1970-01-01 │          │
│ 1970-01-29 │ 1970-01-01 │          │
│ 1970-01-30 │ 1970-01-01 │          │
│ 1970-01-31 │ 1970-01-01 │          │
│ 1970-02-01 │ 1970-01-01 │          │
│ 1970-02-02 │ 1970-01-01 │          │
│ 1970-02-03 │ 1970-01-01 │          │
│ 1970-02-04 │ 1970-01-01 │          │
│ 1970-02-05 │ 1970-01-01 │          │
│ 1970-02-06 │ 1970-01-01 │          │
│ 1970-02-07 │ 1970-01-01 │          │
│ 1970-02-08 │ 1970-01-01 │          │
│ 1970-02-09 │ 1970-01-01 │          │
│ 1970-02-10 │ 1970-01-05 │ original │
└────────────┴────────────┴──────────┘
```

Пример запроса без `STALENESS`:

```sql
SELECT number as key, 5 * number value, 'original' AS source
FROM numbers(16) WHERE key % 5 == 0
ORDER BY key WITH FILL;
```

Результат:

```text
    ┌─key─┬─value─┬─source───┐
 1. │   0 │     0 │ original │
 2. │   1 │     0 │          │
 3. │   2 │     0 │          │
 4. │   3 │     0 │          │
 5. │   4 │     0 │          │
 6. │   5 │    25 │ original │
 7. │   6 │     0 │          │
 8. │   7 │     0 │          │
 9. │   8 │     0 │          │
10. │   9 │     0 │          │
11. │  10 │    50 │ original │
12. │  11 │     0 │          │
13. │  12 │     0 │          │
14. │  13 │     0 │          │
15. │  14 │     0 │          │
16. │  15 │    75 │ original │
    └─────┴───────┴──────────┘
```

Тот же запрос после применения `STALENESS 3`:

```sql
SELECT number as key, 5 * number value, 'original' AS source
FROM numbers(16) WHERE key % 5 == 0
ORDER BY key WITH FILL STALENESS 3;
```

Результат:

```text
    ┌─key─┬─value─┬─source───┐
 1. │   0 │     0 │ original │
 2. │   1 │     0 │          │
 3. │   2 │     0 │          │
 4. │   5 │    25 │ original │
 5. │   6 │     0 │          │
 6. │   7 │     0 │          │
 7. │  10 │    50 │ original │
 8. │  11 │     0 │          │
 9. │  12 │     0 │          │
10. │  15 │    75 │ original │
11. │  16 │     0 │          │
12. │  17 │     0 │          │
    └─────┴───────┴──────────┘
```

Пример запроса без `INTERPOLATE`:

```sql
SELECT n, source, inter FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5;
```

Результат:

```text
┌───n─┬─source───┬─inter─┐
│   0 │          │     0 │
│ 0.5 │          │     0 │
│   1 │ original │     1 │
│ 1.5 │          │     0 │
│   2 │          │     0 │
│ 2.5 │          │     0 │
│   3 │          │     0 │
│ 3.5 │          │     0 │
│   4 │ original │     4 │
│ 4.5 │          │     0 │
│   5 │          │     0 │
│ 5.5 │          │     0 │
│   7 │ original │     7 │
└─────┴──────────┴───────┘
```

Тот же запрос после применения `INTERPOLATE`:

```sql
SELECT n, source, inter FROM (
   SELECT toFloat32(number % 10) AS n, 'original' AS source, number as inter
   FROM numbers(10) WHERE number % 3 = 1
) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1);
```

Результат:

```text
┌───n─┬─source───┬─inter─┐
│   0 │          │     0 │
│ 0.5 │          │     0 │
│   1 │ original │     1 │
│ 1.5 │          │     2 │
│   2 │          │     3 │
│ 2.5 │          │     4 │
│   3 │          │     5 │
│ 3.5 │          │     6 │
│   4 │ original │     4 │
│ 4.5 │          │     5 │
│   5 │          │     6 │
│ 5.5 │          │     7 │
│   7 │ original │     7 │
└─────┴──────────┴───────┘
```

## Заполнение, сгруппированное по префиксу сортировки {#filling-grouped-by-sorting-prefix}

Полезно заполнять строки, которые имеют одинаковые значения в определенных колонках независимо, - хороший пример - заполнение недостающих значений в временных рядах.
Предположим, существует следующая таблица временных рядов:
```sql
CREATE TABLE timeseries
(
    `sensor_id` UInt64,
    `timestamp` DateTime64(3, 'UTC'),
    `value` Float64
)
ENGINE = Memory;

SELECT * FROM timeseries;

┌─sensor_id─┬───────────────timestamp─┬─value─┐
│       234 │ 2021-12-01 00:00:03.000 │     3 │
│       432 │ 2021-12-01 00:00:01.000 │     1 │
│       234 │ 2021-12-01 00:00:07.000 │     7 │
│       432 │ 2021-12-01 00:00:05.000 │     5 │
└───────────┴─────────────────────────┴───────┘
```
И нам хотелось бы заполнить недостающие значения для каждого датчика независимо с интервалом в 1 секунду.
Способ, которым можно достигнуть этого, - использовать колонку `sensor_id` как префикс сортировки для заполнения колонки `timestamp`:
```sql
SELECT *
FROM timeseries
ORDER BY
    sensor_id,
    timestamp WITH FILL
INTERPOLATE ( value AS 9999 )

┌─sensor_id─┬───────────────timestamp─┬─value─┐
│       234 │ 2021-12-01 00:00:03.000 │     3 │
│       234 │ 2021-12-01 00:00:04.000 │  9999 │
│       234 │ 2021-12-01 00:00:05.000 │  9999 │
│       234 │ 2021-12-01 00:00:06.000 │  9999 │
│       234 │ 2021-12-01 00:00:07.000 │     7 │
│       432 │ 2021-12-01 00:00:01.000 │     1 │
│       432 │ 2021-12-01 00:00:02.000 │  9999 │
│       432 │ 2021-12-01 00:00:03.000 │  9999 │
│       432 │ 2021-12-01 00:00:04.000 │  9999 │
│       432 │ 2021-12-01 00:00:05.000 │     5 │
└───────────┴─────────────────────────┴───────┘
```
Здесь колонка `value` была интерполирована значением `9999`, чтобы заполненные строки были более заметными.
Это поведение контролируется настройкой `use_with_fill_by_sorting_prefix` (включено по умолчанию).

## Связанный контент {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
