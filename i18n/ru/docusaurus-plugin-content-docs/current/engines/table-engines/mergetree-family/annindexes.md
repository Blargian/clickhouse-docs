description: 'Документация по поиску ближайших соседей с помощью индексов векторного сходства'
keywords: ['векторный поиск', 'поиск по тексту', 'ann', 'индексы', 'индекс', 'ближайший сосед']
sidebar_label: 'Индексы векторного сходства'
slug: /engines/table-engines/mergetree-family/annindexes
title: 'Поиск ближайших соседей с помощью индексов векторного сходства'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import PrivatePreviewBadge from '@theme/badges/PrivatePreviewBadge';


# Поиск ближайших соседей с помощью индексов векторного сходства

<ExperimentalBadge/>
<PrivatePreviewBadge/>

Поиск ближайших соседей — это задача нахождения M ближайших векторов к заданному вектору в N-мерном векторном пространстве. Самый
простой способ решить эту задачу — это исчерпывающий (грубой) поиск, который вычисляет расстояние между опорным
вектором и всеми другими точками в векторном пространстве. Хотя этот метод гарантирует идеально точный результат, он обычно слишком медленный для
практического применения. В качестве альтернативы [аппроксимативные алгоритмы](https://github.com/erikbern/ann-benchmarks) используют жадные эвристики для
гораздо более быстрого нахождения M ближайших векторов. Это позволяет выполнять семантический поиск изображений, песен, текстов
[встраиваний](https://cloud.google.com/architecture/overview-extracting-and-serving-feature-embeddings-for-machine-learning) за миллисекунды.

Блоги:
- [Векторный поиск с ClickHouse - Часть 1](https://clickhouse.com/blog/vector-search-clickhouse-p1)
- [Векторный поиск с ClickHouse - Часть 2](https://clickhouse.com/blog/vector-search-clickhouse-p2)

С точки зрения SQL, поиск ближайших соседей можно выразить следующим образом:

```sql
SELECT [...]
FROM table, [...]
ORDER BY DistanceFunction(vectors, reference_vector)
LIMIT N
```

где
- `DistanceFunction` вычисляет расстояние между двумя векторами (например, 
  [L2Distance](/sql-reference/functions/distance-functions#l2distance) или 
  [cosineDistance](/sql-reference/functions/distance-functions#cosinedistance),
- `vectors` — это столбец типа [Array(Float64)](../../../sql-reference/data-types/array.md) или 
  [Array(Float32)](../../../sql-reference/data-types/array.md), или [Array(BFloat16)](../../../sql-reference/data-types/array.md), который обычно 
  хранит встраивания,
- `reference_vector` — это литерал типа [Array(Float64)](../../../sql-reference/data-types/array.md) или 
  [Array(Float32)](../../../sql-reference/data-types/array.md), или [Array(BFloat16)](../../../sql-reference/data-types/array.md), и
- `N` — это целое число, ограничающее количество возвращаемых результатов.

Запрос возвращает `N` ближайших точек в `vectors` к `reference_vector`.

Исчерпывающий поиск вычисляет расстояние между `reference_vector` и всеми векторами в `vectors`. Таким образом, его время выполнения линейно по
количеству хранимых векторов. Аппроксимационный поиск основывается на специальных структурах данных (например, графах, случайных лесах и т.д.), которые позволяют быстро (т.е. за подлинейное время) находить
ближайшие векторы к данному опорному вектору. ClickHouse предоставляет такую структуру данных в виде
"индексов векторного сходства", типа [индекса пропуска данных](mergetree.md#table_engine-mergetree-data_skipping-indexes).


# Создание и использование индексов векторного сходства

Синтаксис для создания индекса векторного сходства

```sql
CREATE TABLE table
(
  id Int64,
  vectors Array(Float32),
  INDEX index_name vectors TYPE vector_similarity(method, distance_function[, quantization, hnsw_max_connections_per_layer, hnsw_candidate_list_size_for_construction]) [GRANULARITY N]
)
ENGINE = MergeTree
ORDER BY id;
```

:::note
Индексы USearch в настоящее время являются экспериментальными, чтобы использовать их, вам сначала нужно выполнить `SET allow_experimental_vector_similarity_index = 1`.
:::

Индекс можно создавать на столбцах типа [Array(Float64)](../../../sql-reference/data-types/array.md) или
[Array(Float32)](../../../sql-reference/data-types/array.md).

Параметры индекса:
- `method`: В настоящее время поддерживается только `hnsw`.
- `distance_function`: либо `L2Distance` ( [евклидово расстояние](https://en.wikipedia.org/wiki/Euclidean_distance): длина линии
  между двумя точками в евклидова пространстве), либо `cosineDistance` ( [косинусное
  расстояние](https://en.wikipedia.org/wiki/Cosine_similarity#Cosine_distance): угол между двумя ненулевыми векторами).
- `quantization`: либо `f64`, `f32`, `f16`, `bf16`, или `i8` для хранения векторов с уменьшенной точностью (необязательно, по умолчанию: `bf16`)
- `hnsw_max_connections_per_layer`: количество соседей на узел графа HNSW, также известное как `M` в [статье HNSW](https://doi.org/10.1109/TPAMI.2018.2889473). Необязательно, по умолчанию: `32`. Значение `0` означает использование значения по умолчанию.
- `hnsw_candidate_list_size_for_construction`: размер динамического списка кандидатов при построении графа HNSW, также известный как `ef_construction` в оригинальной [статье HNSW](https://doi.org/10.1109/TPAMI.2018.2889473). Необязательно, по умолчанию: `128`. Значение 0 означает использование значения по умолчанию.

Для нормализованных данных `L2Distance` обычно является наилучшим выбором, в противном случае рекомендуется использовать `cosineDistance`, чтобы компенсировать масштаб.

Пример:

```sql
CREATE TABLE table
(
  id Int64,
  vectors Array(Float32),
  INDEX idx vectors TYPE vector_similarity('hnsw', 'L2Distance') -- Альтернативный синтаксис: TYPE vector_similarity(hnsw, L2Distance)
)
ENGINE = MergeTree
ORDER BY id;
```

Все массивы должны иметь одинаковую длину. Чтобы избежать ошибок, вы можете использовать
[CONSTRAINT](/sql-reference/statements/create/table.md#constraints), например, `CONSTRAINT constraint_name_1 CHECK
length(vectors) = 256`. Пустые `Arrays` и неопределенные значения `Array` в операторах INSERT (т.е. значения по умолчанию) также не поддерживаются.

Индексы векторного сходства основаны на [библиотеке USearch](https://github.com/unum-cloud/usearch), которая реализует [алгоритм HNSW](https://arxiv.org/abs/1603.09320), т.е. иерархический граф, где каждая вершина представляет собой вектор, а ребра между узлами представляют собой сходство. Такие иерархические структуры могут быть очень эффективны для больших коллекций. Они могут часто извлекать 0.05% или меньше данных от общего набора данных, при этом обеспечивая 99% реколл. Это особенно полезно при работе с векторами высокой размерности, которые дорого загружать и сравнивать. USearch также использует SIMD для ускорения вычислений расстояния на современных процессорах x86 (AVX2 и AVX-512) и ARM (NEON и SVE).

Индексы векторного сходства создаются во время вставки столбца и слияния. Известно, что алгоритм HNSW предоставляет медленные вставки. В результате операторы `INSERT` и `OPTIMIZE` на таблицах с индексом векторного сходства будут медленнее, чем для обычных таблиц. Индексы векторного сходства рекомендуется использовать только с неизменяемыми или редко изменяемыми данными, когда гораздо больше запросов на чтение, чем записей. Рекомендуются три дополнительные техники для ускорения создания индекса:
- Создание индексов может быть параллелизовано. Максимальное количество потоков можно настроить с помощью настройки сервера
  [max_build_vector_similarity_index_thread_pool_size](../../../operations/server-configuration-parameters/settings.md#server_configuration_parameters_max_build_vector_similarity_index_thread_pool_size).
  Рекомендуется настроить настройку на количество ядер CPU машины.
- Создание индекса на новых вставленных частях может быть отключено с помощью настройки сессии
  [`materialize_skip_indexes_on_insert`](../../../operations/settings/settings.md). Поиски на таких частях будут возвращаться к точному поиску, но так как вставленные части обычно малы по сравнению с общим размером таблицы, ожидается, что влияние на производительность будет незначительным.
- ClickHouse объединяет несколько частей поэтапно в фоновом режиме в большие части. Эти новые части могут быть объединены позже в еще большие части ("амортизация записи"). Каждое слияние воссоздает индекс векторного сходства выходной части с нуля (так же, как и другие индексы пропуска), что означает, что индексы векторного сходства могут создаваться ненужным образом. Чтобы избежать этого, можно подавить создание индексов векторного сходства во время слияния, используя настройку дерева слияния
  [materialize_skip_indexes_on_merge](../../../operations/settings/merge-tree-settings.md#materialize_skip_indexes_on_merge). Это, в сочетании с оператором [ALTER TABLE \[...\] MATERIALIZE INDEX
  \[...\]](../../../sql-reference/statements/alter/skipping-index.md#materialize-index), предоставляет явное управление жизненным циклом
  индексов векторного сходства. Например, создание индекса можно отложить до периодов низкой загрузки (например, на выходных) или после больших объемов
  приема данных.

Индексы векторного сходства поддерживают этот тип запроса:

```sql
WITH [...] AS reference_vector
SELECT *
FROM table
WHERE ...                       -- Условие WHERE является необязательным
ORDER BY Distance(vectors, reference_vector)
LIMIT N
```

Чтобы выполнить поиск с использованием другого значения параметра HNSW `hnsw_candidate_list_size_for_search` (по умолчанию: 256), также известного как `ef_search` в оригинальной [статье HNSW](https://doi.org/10.1109/TPAMI.2018.2889473), выполните запрос `SELECT` с `SETTINGS hnsw_candidate_list_size_for_search = <value>`.

Повторные чтения из индекса векторного сходства извлекают выгоду от большого кэша индекса векторного сходства. Максимальный размер кэша можно настроить с помощью
настройки сервера
[vector_similarity_index_cache_size](../../../operations/server-configuration-parameters/settings.md#vector_similarity_index_cache_size). По умолчанию он настроен на максимальный размер 5 ГБ.

**Ограничения**: Аппроксимационные алгоритмы векторного поиска требуют ограничения, таким образом, запросы без условия `LIMIT` не могут использовать индексы векторного сходства. Ограничение также должно быть меньше, чем настройка `max_limit_for_ann_queries` (по умолчанию: 100).

**Различия с обычными индексами пропуска** Похожим образом, как и обычные [индексы пропуска](/optimize/skipping-indexes), индексы векторного сходства строятся на основе гранул, и каждый индексированный блок состоит из `GRANULARITY = [N]` гранул (`[N]` = 1 по умолчанию для обычных индексов пропуска). Например, если первичная гранулярность индекса таблицы равна 8192 (настройка `index_granularity = 8192`) и `GRANULARITY = 2`, то каждый индексированный блок будет содержать 16384 строки. Однако структуры данных и алгоритмы для поиска ближайших соседей по своей природе ориентированы на строки. Они хранят компактное представление набора строк и также возвращают строки для запросов векторного поиска.
Это вызывает некоторые довольно неинтуитивные различия в поведении индексов векторного сходства по сравнению с обычными индексами пропуска.

Когда пользователь определяет индекс векторного сходства на столбце, ClickHouse внутренне создает "суб-индекс" векторного сходства для каждого индексированного блока. Суб-индекс является "локальным" в том смысле, что он знает только о строках своего содержащего индексного блока. В предыдущем примере при условии, что столбец имеет 65536 строк, мы получаем четыре индексированных блока (охватывающих восемь гранул) и суб-индекс векторного сходства для каждого индексированного блока. Суб-индекс теоретически способен вернуть строки с N ближайшими точками внутри своего индексированного блока непосредственно. Однако, поскольку ClickHouse загружает данные с диска в память с гранулярностью гранул, суб-индексы экстраполируют совпадающие строки до гранулярности гранул. Это отличается от обычных индексов пропуска, которые пропускают данные с гранулярностью индексированных блоков.

Параметр `GRANULARITY` определяет, сколько суб-индексов векторного сходства будет создано. Более крупные значения `GRANULARITY` означают меньше, но крупнее суб-индексов векторного сходства, до такой степени, что у столбца (или части данных столбца) есть только один суб-индекс. В этом случае суб-индекс имеет "глобальный" взгляд на все строки столбца и может непосредственно вернуть все гранулы столбца (части) с соответствующими строками (таких гранул будет не более `LIMIT [N]`). На втором этапе ClickHouse загрузит эти гранулы и определит фактические наилучшие строки, выполнив расчет расстояния методом грубой силы по всем строкам гранул. При небольшом значении `GRANULARITY` каждый из суб-индексов возвращает до `LIMIT N` гранул. В результате требуется загрузить больше гранул и выполнить последующую фильтрацию. Обратите внимание, что точность поиска в обоих случаях одинаково хороша, только производительность обработки различается. Обычно рекомендуется использовать большое значение `GRANULARITY` для индексов векторного сходства и прибегать к меньшим значениям `GRANULARITY` только в случае возникновения проблем, таких как чрезмерное потребление памяти структур векторного сходства. Если для индексов векторного сходства не было указано значение `GRANULARITY`, значением по умолчанию является 100 миллионов.
