---
slug: /best-practices/minimize-optimize-joins
sidebar_position: 10
sidebar_label: 'JOINsの最小化と最適化'
title: 'JOINsの最小化と最適化'
description: 'JOINsに関するベストプラクティスを説明するページ'
---

import Image from '@theme/IdealImage';
import joins from '@site/static/images/bestpractices/joins-speed-memory.png';



ClickHouseは多様なJOINタイプとアルゴリズムをサポートしており、JOINのパフォーマンスは最近のリリースで大幅に改善されています。しかし、JOINは本質的に単一の非正規化されたテーブルからのクエリよりもコストが高くなります。非正規化は、クエリ時の計算処理を、挿入または事前処理時間にシフトし、実行時のレイテンシを大幅に低下させることがよくあります。リアルタイムまたはレイテンシに敏感な分析クエリに対しては、**非正規化が強く推奨されます**。

一般的に、以下のような場合に非正規化を行います：

- テーブルがほとんど変更されず、バッチリフレッシュが許容される場合。
- リレーションシップが多対多でない、または高いカーディナリティでない場合。
- クエリされるカラムのサブセットが限られている場合、すなわち特定のカラムは非正規化から除外可能である場合。
- ClickHouseから上流システム（例えばFlink）に処理をシフトする能力があり、リアルタイムの強化またはフラット化を管理できる場合。

すべてのデータが非正規化される必要があるわけではありません - よくクエリされる特性に焦点を当ててください。また、全体のサブテーブルを複製するのではなく、集計を段階的に計算するために[マテリアライズドビュー](/best-practices/use-materialized-views)を検討してください。スキーマの更新がまれであり、レイテンシが重要な場合、非正規化は最適なパフォーマンスのトレードオフを提供します。

ClickHouseにおけるデータの非正規化に関する完全なガイドは[こちら](/data-modeling/denormalization)をご覧ください。

## JOINsが必要な場合 {#when-joins-are-required}

JOINsが必要な場合は、**少なくともバージョン24.12以上、できれば最新バージョンを使用するようにしてください**。JOINのパフォーマンスは新しいリリースごとに改善され続けています。ClickHouse 24.12から、クエリプランナーは最適なパフォーマンスのために、JOINの右側に小さいテーブルを自動的に配置します - これは以前は手動で行う必要がありました。さらに、より積極的なフィルタープッシュダウンや複数のJOINの自動再順序付けなど、さらなる改善が間もなく登場します。

JOINのパフォーマンスを改善するために、以下のベストプラクティスに従ってください：

* **デカルト積を避ける**：左側の値が右側の複数の値と一致する場合、JOINは複数の行を返します - いわゆるデカルト積です。右側のすべての一致が必要ない場合、単一の一致だけが必要な場合は、`ANY` JOIN（例： `LEFT ANY JOIN`）を使用できます。これにより、通常のJOINよりも高速でメモリ使用量が少なくなります。
* **JOINされたテーブルのサイズを減らす**：JOINの実行時間とメモリ消費は、左側と右側のテーブルのサイズに比例して増加します。JOINによって処理されるデータの量を減らすために、クエリの`WHERE`や`JOIN ON`の句に追加のフィルター条件を加えてください。ClickHouseはフィルター条件をクエリプランの可能な限り深く押し下げ、通常はJOINの前に配置します。フィルターが自動的に押し下げられない場合（何らかの理由で）、JOINの片側をサブクエリとして書き換えてプッシュダウンを強制してください。
* **適切な場合は辞書経由の直接JOINを使用する**：ClickHouseの標準JOINは、右側を走査してハッシュテーブルを構築するビルドフェーズと、左側を走査してハッシュテーブルのルックアップを行うプローブフェーズの2つのフェーズで実行されます。右側が[辞書](/dictionary)またはキー-バリュー特性を持つ他のテーブルエンジン（例：[EmbeddedRocksDB](/engines/table-engines/integrations/embedded-rocksdb)や[Joinテーブルエンジン](/engines/table-engines/special/join)）である場合、ClickHouseは「直接」JOINアルゴリズムを使用でき、これによりハッシュテーブルを構築する必要がなくなり、クエリ処理が高速化します。これは`INNER`および`LEFT OUTER` JOINで機能し、リアルタイムの分析ワークロードに最適です。
* **JOINのためのテーブルソートを利用する**：ClickHouseの各テーブルは、テーブルの主キーのカラムでソートされています。テーブルのソートを悪用するために、`full_sorting_merge`や`partial_merge`のようなソートマージJOINアルゴリズムがあります。標準のハッシュテーブルに基づくJOINアルゴリズム（後述の`parallel_hash`、`hash`、`grace_hash`など）とは異なり、ソートマージJOINアルゴリズムはまずソートし、その後両方のテーブルをマージします。クエリがそれぞれの主キーのカラムで両方のテーブルをJOINする場合、ソートステップを省略する最適化があり、処理時間とオーバーヘッドを節約できます。
* **ディスクスピリングJOINを避ける**：JOINの中間状態（例：ハッシュテーブル）が大きすぎて主メモリに収まらなくなることがあります。この状況では、ClickHouseはデフォルトでメモリエラーを返します。一部のJOINアルゴリズム（以下を参照）、たとえば[`grace_hash`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-hash-joins-part2)、[`partial_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)、および[`full_sorting_merge`](https://clickhouse.com/blog/clickhouse-fully-supports-joins-full-sort-partial-merge-part3)は中間状態をディスクにスピルし、クエリ実行を継続することができます。ただし、ディスクアクセスがJOIN処理を大幅に遅くする可能性があるため、これらのJOINアルゴリズムは注意して使用する必要があります。代わりに、中間状態のサイズを減らすためにJOINクエリを他の方法で最適化することをお勧めします。
* **外部JOINでのデフォルト値を非一致マーカーとして使用**：左/右/フル外部JOINは、左/右/両方のテーブルからすべての値を含みます。他のテーブルで一致するJOINパートナーが見つからない場合、ClickHouseはJOINパートナーを特別なマーカーで置き換えます。SQL標準では、データベースがNULLをそのようなマーカーとして使用することが義務付けられています。ClickHouseでは、結果のカラムをNullableでラップする必要があり、追加のメモリとパフォーマンスオーバーヘッドが発生します。代わりに、設定`join_use_nulls = 0`を構成し、結果のカラムデータ型のデフォルト値をマーカーとして使用できます。


:::note 辞書の使用に関する注意
ClickHouseでJOINに辞書を使用する際は、辞書は設計上、重複するキーを許可しないことを理解することが重要です。データ読み込み中に、重複するキーは静かに重複排除され、与えられたキーに対して最後に読み込まれた値のみが保持されます。この動作により、辞書は最近のまたは権威ある値のみが必要な一対一または多対一のリレーションシップに最適です。しかし、一対多または多対多のリレーションシップ（例：役者に複数の役割を持たせる）に辞書を使用すると、すべての一致する行のうち1つを除いて静かにデータが失われます。そのため、辞書は複数の一致に対して完全なリレーショナル忠実度を要求されるシナリオには適していません。
:::

## 適切なJOINアルゴリズムの選択 {#choosing-the-right-join-algorithm}

ClickHouseは、スピードとメモリのトレードオフを行ういくつかのJOINアルゴリズムをサポートしています：

* **パラレルハッシュJOIN（デフォルト）：** メモリに収まる小中規模の右側テーブルには高速です。
* **直接JOIN：** `INNER`または`LEFT ANY JOIN`で辞書（またはキー-バリュー特性を持つ他のテーブルエンジン）を使用する場合に最適 - ハッシュテーブルの構築が不要なので、ポイントルックアップには最も速い方法です。
* **フルソートマージJOIN：** 両方のテーブルがJOINキーでソートされている場合に効率的です。
* **部分マージJOIN：** メモリを最小限に抑えますが、遅くなります - 大きなテーブルを限られたメモリでJOINするのに最適です。
* **グレースハッシュJOIN：** 柔軟でメモリ調整可能、大規模データセットに適し、調整可能なパフォーマンス特性を持ちます。

<Image img={joins} size="md" alt="Joins - speed vs memory"/>

:::note
各アルゴリズムはJOINタイプに対するサポートが異なります。各アルゴリズムのサポートされているJOINタイプの全リストは[こちら](/guides/joining-tables#choosing-a-join-algorithm)で確認できます。
:::

`join_algorithm = 'auto'`（デフォルト）を設定することでClickHouseに最適なアルゴリズムを選択させることができますが、ワークロードに基づいて明示的に制御することもできます。パフォーマンスやメモリオーバーヘッドを最適化するためにJOINアルゴリズムを選択する必要がある場合は、[このガイド](/guides/joining-tables#choosing-a-join-algorithm)をお勧めします。

最適なパフォーマンスのためには：

* 高性能のワークロードではJOINを最小限に抑えてください。
* クエリごとに3〜4のJOINを超えないようにしてください。
* 実データで異なるアルゴリズムをベンチマークしてください - パフォーマンスはJOINキーの分布やデータサイズによって異なります。

JOIN最適化戦略、JOINアルゴリズム、およびそれらの調整方法については、[ClickHouseドキュメント](/guides/joining-tables)およびこの[ブログシリーズ](https://clickhouse.com/blog/clickhouse-fully-supports-joins-part1)を参照してください。
