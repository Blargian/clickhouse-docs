---
description: 'Документация по CREATE VIEW'
sidebar_label: 'VIEW'
sidebar_position: 37
slug: /sql-reference/statements/create/view
title: 'CREATE VIEW'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import DeprecatedBadge from '@theme/badges/DeprecatedBadge';
import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';


# CREATE VIEW

Создаёт новое представление. Представления могут быть [normal](#normal-view), [materialized](#materialized-view), [refreshable materialized](#refreshable-materialized-view) и [window](/sql-reference/statements/create/view#window-view) (обновляемое материализованное представление и window-представление являются экспериментальными функциями).

## Обычное представление {#normal-view}

Синтаксис:

```sql
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [(alias1 [, alias2 ...])] [ON CLUSTER cluster_name]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

Обычные представления не хранят никаких данных. Они просто выполняют чтение из другой таблицы при каждом доступе. Другими словами, обычное представление — это не что иное, как сохранённый запрос. При чтении из представления этот сохранённый запрос используется как подзапрос в разделе [FROM](../../../sql-reference/statements/select/from.md).

Например, предположим, что вы создали представление:

```sql
CREATE VIEW view AS SELECT ...
```

и написали запрос:

```sql
SELECT a, b, c FROM view
```

Этот запрос полностью эквивалентен использованию подзапроса:

```sql
SELECT a, b, c FROM (SELECT ...)
```

## Параметризированное представление {#parameterized-view}

Параметризированные представления аналогичны обычным представлениям, но могут быть созданы с параметрами, которые не решаются сразу. Эти представления можно использовать с табличными функциями, которые указывают имя представления как имя функции, а значения параметров как его аргументы.

```sql
CREATE VIEW view AS SELECT * FROM TABLE WHERE Column1={column1:datatype1} and Column2={column2:datatype2} ...
```
Выше создаётся представление для таблицы, которое может использоваться как табличная функция с подстановкой параметров, как показано ниже.

```sql
SELECT * FROM view(column1=value1, column2=value2 ...)
```

## Материализованное представление {#materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster_name] [TO[db.]name [(columns)]] [ENGINE = engine] [POPULATE]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

:::tip
Вот пошаговое руководство по использованию [материализованных представлений](/guides/developer/cascading-materialized-views.md).
:::

Материализованные представления хранят данные, преобразованные соответствующим [SELECT](../../../sql-reference/statements/select/index.md) запросом.

При создании материализованного представления без `TO [db].[table]`, необходимо указать `ENGINE` – движок таблицы для хранения данных.

Если создаётся материализованное представление с `TO [db].[table]`, вы не можете использовать `POPULATE`.

Материализованное представление выполняется следующим образом: при вставке данных в таблицу, указанную в `SELECT`, часть вставленных данных преобразуется этим запросом `SELECT`, а результат вставляется в представление.

:::note
Материализованные представления в ClickHouse используют **имена столбцов** вместо порядка столбцов во время вставки в целевую таблицу. Если некоторые имена столбцов отсутствуют в результате запроса `SELECT`, ClickHouse использует значение по умолчанию, даже если столбец не является [Nullable](../../data-types/nullable.md). Безопасной практикой было бы добавлять псевдонимы для каждого столбца при использовании материализованных представлений.

Материализованные представления в ClickHouse реализованы больше как триггеры вставки. Если в запросе представления есть агрегация, она применяется только к партии только что вставленных данных. Любые изменения существующих данных исходной таблицы (например, обновление, удаление, удаление раздела и т. д.) не изменяют материализованное представление.

Материализованные представления в ClickHouse не имеют детерминированного поведения в случае ошибок. Это означает, что блоки, которые уже были записаны, будут сохранены в целевой таблице, но все блоки после ошибки не будут.

По умолчанию, если вставка в одно из представлений не удалась, то запрос INSERT также завершится с ошибкой, и некоторые блоки могут не быть записаны в целевую таблицу. Это можно изменить, используя настройку `materialized_views_ignore_errors` (её следует установить для запроса `INSERT`), если вы установите `materialized_views_ignore_errors=true`, тогда любые ошибки при вставке в представления будут игнорироваться, и все блоки будут записаны в целевую таблицу.

Также обратите внимание, что `materialized_views_ignore_errors` по умолчанию установлено в `true` для таблиц `system.*_log`.
:::

Если вы укажете `POPULATE`, существующие данные таблицы будут вставлены в представление при его создании, как будто выполняется `CREATE TABLE ... AS SELECT ...`. В противном случае в запросе содержатся только данные, вставленные в таблицу после создания представления. Мы **не рекомендуем** использовать `POPULATE`, так как данные, вставленные в таблицу во время создания представления, не будут в него вставлены.

:::note
Учитывая, что `POPULATE` работает как `CREATE TABLE ... AS SELECT ...`, у него есть ограничения:
- Он не поддерживается с реплицируемыми базами данных
- Он не поддерживается в ClickHouse cloud

Вместо этого можно использовать отдельный `INSERT ... SELECT`.
:::

Запрос `SELECT` может содержать `DISTINCT`, `GROUP BY`, `ORDER BY`, `LIMIT`. Обратите внимание, что соответствующие преобразования выполняются независимо в каждом блоке вставленных данных. Например, если указан `GROUP BY`, данные агрегируются во время вставки, но только в пределах одного пакета вставленных данных. Данные не будут дополнительно агрегироваться. Исключением является использование `ENGINE`, который независимо выполняет агрегацию данных, как `SummingMergeTree`.

Выполнение запросов [ALTER](/sql-reference/statements/alter/view.md) на материализованных представлениях имеет ограничения, например, нельзя обновить запрос `SELECT`, что может быть неудобно. Если материализованное представление использует конструкцию `TO [db.]name`, вы можете `DETACH` представление, выполнить `ALTER` для целевой таблицы, а затем `ATTACH` ранее отключенное (`DETACH`) представление.

Обратите внимание, что на материализованное представление влияет настройка [optimize_on_insert](/operations/settings/settings#optimize_on_insert). Данные объединяются перед вставкой в представление.

Представления выглядят так же, как обычные таблицы. Например, они перечислены в результате запроса `SHOW TABLES`.

Чтобы удалить представление, используйте [DROP VIEW](../../../sql-reference/statements/drop.md#drop-view). Хотя `DROP TABLE` работает и для VIEW.

## SQL безопасность {#sql_security}

`DEFINER` и `SQL SECURITY` позволяют указать, какого пользователя ClickHouse использовать при выполнении базового запроса представления.
`SQL SECURITY` имеет три допустимых значения: `DEFINER`, `INVOKER` или `NONE`. Вы можете указать любого существующего пользователя или `CURRENT_USER` в предложении `DEFINER`.

Следующая таблица объяснит, какие права требуются для какого пользователя, чтобы выбрать из представления.
Обратите внимание, что независимо от опции SQL безопасности, в любом случае по-прежнему требуется иметь `GRANT SELECT ON <view>`, чтобы прочитать из него.

| Опция безопасности SQL | Представление                                                       | Материализованное представление                                                                                              |
|------------------------|---------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| `DEFINER alice`        | `alice` должна иметь право `SELECT` для исходной таблицы представления. | `alice` должна иметь право `SELECT` для исходной таблицы представления и право `INSERT` для целевой таблицы представления. |
| `INVOKER`              | Пользователь должен иметь право `SELECT` для исходной таблицы представления.     | Нельзя указать `SQL SECURITY INVOKER` для материализованных представлений.                                                |
| `NONE`                 | -                                                                   | -                                                                                                                           |

:::note
`SQL SECURITY NONE` — это устаревшая опция. Любой пользователь с правами на создание представлений с `SQL SECURITY NONE` сможет выполнить любой произвольный запрос.
Таким образом, необходимо иметь `GRANT ALLOW SQL SECURITY NONE TO <user>`, чтобы создать представление с этой опцией.
:::

Если `DEFINER`/`SQL SECURITY` не указаны, используются значения по умолчанию:
- `SQL SECURITY`: `INVOKER` для обычных представлений и `DEFINER` для материализованных представлений ([настраивается в настройках](../../../operations/settings/settings.md#default_normal_view_sql_security))
- `DEFINER`: `CURRENT_USER` ([настраивается в настройках](../../../operations/settings/settings.md#default_view_definer))

Если представление подключено без указания `DEFINER`/`SQL SECURITY`, по умолчанию используется `SQL SECURITY NONE` для материализованного представления и `SQL SECURITY INVOKER` для обычного представления.

Чтобы изменить SQL безопасность для существующего представления, используйте
```sql
ALTER TABLE MODIFY SQL SECURITY { DEFINER | INVOKER | NONE } [DEFINER = { user | CURRENT_USER }]
```

### Примеры {#examples}
```sql
CREATE VIEW test_view
DEFINER = alice SQL SECURITY DEFINER
AS SELECT ...
```

```sql
CREATE VIEW test_view
SQL SECURITY INVOKER
AS SELECT ...
```

## Live-представление {#live-view}

<DeprecatedBadge/>

Эта функция устарела и будет удалена в будущем.

Для вашего удобства старую документацию можно найти [здесь](https://pastila.nl/?00f32652/fdf07272a7b54bda7e13b919264e449f.md)

## Обновляемое материализованное представление {#refreshable-materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
REFRESH EVERY|AFTER interval [OFFSET interval]
[RANDOMIZE FOR interval]
[DEPENDS ON [db.]name [, [db.]name [, ...]]]
[SETTINGS name = value [, name = value [, ...]]]
[APPEND]
[TO[db.]name] [(columns)] [ENGINE = engine]
[EMPTY]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```
где `interval` — это последовательность простых интервалов:
```sql
number SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR
```

Периодически выполняет соответствующий запрос и сохраняет его результат в таблице.
 * Если запрос содержит `APPEND`, каждая обновление вставляет строки в таблицу без удаления существующих строк. Вставка не является атомарной, как и обычная INSERT SELECT.
 * В противном случае каждое обновление атомарно заменяет предыдущие содержимое таблицы.

Отличия от обычных необновляемых материализованных представлений:
 * Нет триггера вставки. То есть, когда новые данные вставляются в таблицу, указанную в SELECT, они *не* автоматически помещаются в обновляемое материализованное представление. Периодическая обновление выполняет весь запрос.
 * Нет ограничений на запрос `SELECT`. Табличные функции (например, `url()`), представления, UNION, JOIN все разрешены.

:::note
Настройки в части `REFRESH ... SETTINGS` запроса являются настройками обновления (например, `refresh_retries`), отличными от обычных настроек (например, `max_threads`). Обычные настройки можно указать, используя `SETTINGS` в конце запроса.
:::

### График обновления {#refresh-schedule}

Примеры графика обновления:
```sql
REFRESH EVERY 1 DAY -- каждый день в полночь (UTC)
REFRESH EVERY 1 MONTH -- в первый день каждого месяца, в полночь
REFRESH EVERY 1 MONTH OFFSET 5 DAY 2 HOUR -- на шестой день каждого месяца, в 02:00
REFRESH EVERY 2 WEEK OFFSET 5 DAY 15 HOUR 10 MINUTE -- каждые две недели, в субботу, в 15:10
REFRESH EVERY 30 MINUTE -- в 00:00, 00:30, 01:00, 01:30 и так далее
REFRESH AFTER 30 MINUTE -- через 30 минут после завершения предыдущего обновления, без синхронизации с временем суток
-- REFRESH AFTER 1 HOUR OFFSET 1 MINUTE -- ошибка синтаксиса, OFFSET не допускается с AFTER
REFRESH EVERY 1 WEEK 2 DAYS -- каждые 9 дней, не в какой-то конкретный день недели или месяца;
                            -- конкретно, когда номер дня (с 1969-12-29) делится на 9
REFRESH EVERY 5 MONTHS -- каждые 5 месяцев, разные месяцы каждый год (так как 12 не делится на 5);
                       -- конкретно, когда номер месяца (с 1970-01) делится на 5
```

`RANDOMIZE FOR` случайным образом корректирует время каждого обновления, например:
```sql
REFRESH EVERY 1 DAY OFFSET 2 HOUR RANDOMIZE FOR 1 HOUR -- каждый день в случайное время с 01:30 до 02:30
```

В каждый момент времени может выполняться не более одного обновления для данного представления. Например, если представление с `REFRESH EVERY 1 MINUTE` обновляется за 2 минуты, оно будет обновляться каждые 2 минуты. Если оно затем станет быстрее и начнёт обновляться за 10 секунд, оно вернётся к обновлению каждую минуту. (В частности, оно не будет обновляться каждые 10 секунд, чтобы наверстать пропущенные обновления — такой очереди нет.)

Кроме того, обновление запускается сразу после создания материализованного представления, если в запросе создания не указано `EMPTY`. Если `EMPTY` указано, первое обновление происходит по расписанию.

### В реплицируемой БД {#in-replicated-db}

Если обновляемое материализованное представление находится в [реплицируемой базе данных](../../../engines/database-engines/replicated.md), реплики координируются друг с другом, так что только одна реплика выполняет обновление в каждый запланированный момент времени. Требуется использование движка таблицы [ReplicatedMergeTree](../../../engines/table-engines/mergetree-family/replication.md), чтобы все реплики видели данные, создаваемые обновлением.

В режиме `APPEND`, координацию можно отключить, используя `SETTINGS all_replicas = 1`. Это заставляет реплики выполнять обновления независимо друг от друга. В этом случае ReplicatedMergeTree не требуется.

В не-`APPEND` режиме поддерживается только координированное обновление. Для некординированного обновления используйте атомарные базы данных и запрос `CREATE ... ON CLUSTER`, чтобы создать обновляемые материализованные представления на всех репликах.

Координация осуществляется через Keeper. Путь znode определяется настройкой сервера [default_replica_path](../../../operations/server-configuration-parameters/settings.md#default_replica_path).

### Зависимости {#refresh-dependencies}

`DEPENDS ON` синхронизирует обновления разных таблиц. Например, предположим, что есть цепочка из двух обновляемых материализованных представлений:
```sql
CREATE MATERIALIZED VIEW source REFRESH EVERY 1 DAY AS SELECT * FROM url(...)
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY AS SELECT ... FROM source
```
Без `DEPENDS ON` оба представления начнут обновляться в полночь, и `destination` обычно будет видеть вчерашние данные в `source`. Если мы добавим зависимость:
```sql
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY DEPENDS ON source AS SELECT ... FROM source
```
то обновление `destination` начнётся только после завершения обновления `source` за этот день, так что `destination` будет основан на свежих данных.

Альтернативно, тот же результат можно достичь с:
```sql
CREATE MATERIALIZED VIEW destination REFRESH AFTER 1 HOUR DEPENDS ON source AS SELECT ... FROM source
```
где `1 HOUR` может быть любой продолжительностью, меньшей, чем период обновления `source`. Зависимая таблица не будет обновляться чаще, чем любая из её зависимостей. Это допустимый способ настроить цепочку обновляемых представлений без указания фактического периода обновления более одного раза.

Ещё несколько примеров:
 * `REFRESH EVERY 1 DAY OFFSET 10 MINUTE` (`destination`) зависит от `REFRESH EVERY 1 DAY` (`source`)<br/>
   Если обновление `source` занимает более 10 минут, `destination` будет ждать его.
 * `REFRESH EVERY 1 DAY OFFSET 1 HOUR` зависит от `REFRESH EVERY 1 DAY OFFSET 23 HOUR`<br/>
   Аналогично вышеприведенному, даже если соответствующие обновления происходят в разные календарные дни.
   Обновление `destination` на день X+1 будет ждать обновления `source` на день X (если оно занимает более 2 часов).
 * `REFRESH EVERY 2 HOUR` зависит от `REFRESH EVERY 1 HOUR`<br/>
   2-часовое обновление происходит после каждого другого часового обновления, например, после обновления в полночь, затем после обновления в 2 часа ночи и т. д.
 * `REFRESH EVERY 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH AFTER 2 HOUR`<br/>
   `destination` обновляется один раз после каждого обновления `source`, то есть каждые 2 часа. `1 MINUTE` фактически игнорируется.
 * `REFRESH AFTER 1 HOUR` зависит от `REFRESH AFTER 1 HOUR`<br/>
   В настоящее время это не рекомендуется.

:::note
`DEPENDS ON` работает только между обновляемыми материализованными представлениями. Указание обычной таблицы в списке `DEPENDS ON` предотвратит обновление представления (зависимости могут быть удалены с помощью `ALTER`, см. ниже).
:::

### Настройки {#settings}

Доступные параметры обновления:
 * `refresh_retries` — сколько раз повторить попытку, если обновление завершилось исключением. Если все повторы не удались, перейдите к следующему запланированному времени обновления. 0 означает отсутствие повторов, -1 означает бесконечные повторы. По умолчанию: 0.
 * `refresh_retry_initial_backoff_ms` — Задержка перед первой повторной попыткой, если `refresh_retries` не является равным нулю. Каждая последующая попытка удваивает задержку, вплоть до `refresh_retry_max_backoff_ms`. По умолчанию: 100 мс.
 * `refresh_retry_max_backoff_ms` — Предел на экспоненциальный рост задержки между попытками обновления. По умолчанию: 60000 мс (1 минута).

### Изменение параметров обновления {#changing-refresh-parameters}

Чтобы изменить параметры обновления:
```sql
ALTER TABLE [db.]name MODIFY REFRESH EVERY|AFTER ... [RANDOMIZE FOR ...] [DEPENDS ON ...] [SETTINGS ...]
```

:::note
Это заменяет *все* параметры обновления разом: расписание, зависимости, настройки и APPEND-ность. Например, если у таблицы была `DEPENDS ON`, выполнение `MODIFY REFRESH` без `DEPENDS ON` удалит зависимости.
:::

### Прочие операции {#other-operations}

Статус всех обновляемых материализованных представлений доступен в таблице [`system.view_refreshes`](../../../operations/system-tables/view_refreshes.md). В частности, она содержит прогресс обновления (если выполняется), время последнего и следующего обновления, сообщение об исключении, если обновление завершилось неудачно.

Чтобы вручную остановить, запустить, инициировать или отменить обновления, используйте [`SYSTEM STOP|START|REFRESH|WAIT|CANCEL VIEW`](../system.md#refreshable-materialized-views).

Чтобы дождаться завершения обновления, используйте [`SYSTEM WAIT VIEW`](../system.md#refreshable-materialized-views). Особенно полезно, чтобы дождаться первоначального обновления после создания представления.

:::note
Интересный факт: запрос на обновление может читать из представления, которое обновляется, видя предыдущее состояние данных. Это означает, что вы можете реализовать игру "Жизнь": https://pastila.nl/?00021a4b/d6156ff819c83d490ad2dcec05676865#O0LGWTO7maUQIA4AcGUtlA==
:::

## Window-представление {#window-view}

<ExperimentalBadge/>
<CloudNotSupportedBadge/>

:::info
Это экспериментальная функция, которая в будущих версиях может измениться с нарушением обратной совместимости. Включите использование window-представлений и `WATCH` запроса, используя настройку [allow_experimental_window_view](/operations/settings/settings#allow_experimental_window_view). Введите команду `set allow_experimental_window_view = 1`.
:::

```sql
CREATE WINDOW VIEW [IF NOT EXISTS] [db.]table_name [TO [db.]table_name] [INNER ENGINE engine] [ENGINE engine] [WATERMARK strategy] [ALLOWED_LATENESS interval_function] [POPULATE]
AS SELECT ...
GROUP BY time_window_function
[COMMENT 'comment']
```

Window-представление может агрегировать данные по временным окнам и выводить результаты, когда окно готово к срабатыванию. Оно хранит результаты частичной агрегации во внутренней (или указанной) таблице для уменьшения задержки и может отправлять результаты обработки в указанную таблицу или отправлять уведомления с помощью запроса WATCH.

Создание window-представления похоже на создание `MATERIALIZED VIEW`. Window-представление нуждается во внутреннем механизме хранения для хранения промежуточных данных. Внутреннее хранилище можно указать, используя предложение `INNER ENGINE`, в качестве внутреннего движка window-представление будет использовать `AggregatingMergeTree` по умолчанию.

При создании window-представления без `TO [db].[table]`, вы должны указать `ENGINE` – движок таблицы для хранения данных.

### Функции временных окон {#time-window-functions}

[Функции временных окон](../../functions/time-window-functions.md) используются для получения нижней и верхней границы окон для записей. Window-представление должно использоваться с функцией временного окна.

### Временные атрибуты {#time-attributes}

Window-представление поддерживает обработку **времени обработки** и **времени события**.

**Время обработки** позволяет window-представлению выводить результаты, основываясь на времени на локальной машине и используется по умолчанию. Это самое простое представление времени, но оно не обеспечивает детерминизма. Атрибут времени обработки можно определить, установив параметр `time_attr` функции временного окна на столбец таблицы или используя функцию `now()`. Следующий запрос создаёт window-представление с временем обработки.

```sql
CREATE WINDOW VIEW wv AS SELECT count(number), tumbleStart(w_id) as w_start from date GROUP BY tumble(now(), INTERVAL '5' SECOND) as w_id
```

**Время события** — это время, когда каждое отдельное событие произошло на устройстве, его создающем. Это время обычно встраивается в записи при их создании. Обработка времени события позволяет получить согласованные результаты даже в случае событий, пришедших не в том порядке или с опозданием. Window-представление поддерживает обработку времени события с помощью синтаксиса `WATERMARK`.

Window-представление предоставляет три стратегии для меток времени:

* `STRICTLY_ASCENDING`: Выпускает метку времени, равную максимальному наблюдаемому временному штампу на данный момент. Строки, у которых временной штамп меньше максимального, не опаздывают.
* `ASCENDING`: Выпускает метку времени, равную максимальному наблюдаемому временному штампу на данный момент минус 1. Строки, у которых временной штамп отличается не больше чем на 1, не опаздывают.
* `BOUNDED`: WATERMARK=INTERVAL. Выпускает метки времени, которые равны максимальному наблюдаемому временному штампу минус указанная задержка.

Следующие запросы являются примерами создания window-представления с `WATERMARK`:

```sql
CREATE WINDOW VIEW wv WATERMARK=STRICTLY_ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=INTERVAL '3' SECOND AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
```

По умолчанию окно срабатывает, когда приходит метка времени, и элементы, пришедшие после метки времени, будут отброшены. Window-представление поддерживает обработку событий с задержкой, установив `ALLOWED_LATENESS=INTERVAL`. Пример обработки задержек:

```sql
CREATE WINDOW VIEW test.wv TO test.dst WATERMARK=ASCENDING ALLOWED_LATENESS=INTERVAL '2' SECOND AS SELECT count(a) AS count, tumbleEnd(wid) AS w_end FROM test.mt GROUP BY tumble(timestamp, INTERVAL '5' SECOND) AS wid;
```

Учтите, что элементы, выпускаемые при позднем срабатывании, должны рассматриваться как обновлённые результаты предыдущего вычисления. Вместо срабатывания в конце окон, window-представление сработает немедленно при поступлении события с задержкой. Таким образом, это приведёт к нескольким выводам для одного и того же окна. Пользователям необходимо учитывать эти дублированные результаты или выполнять их дедупликацию.

Вы можете изменить запрос `SELECT`, указанный в window-представлении, с помощью оператора `ALTER TABLE ... MODIFY QUERY`. Структура данных, полученная из нового запроса `SELECT`, должна совпадать с оригинальным запросом `SELECT` как с предложением `TO [db.]name`, так и без него. Обратите внимание, что данные в текущем окне будут потеряны, так как промежуточное состояние не может быть повторно использовано.

### Мониторинг новых окон {#monitoring-new-windows}

Window-представление поддерживает запрос [WATCH](../../../sql-reference/statements/watch.md) для мониторинга изменений или использование синтаксиса `TO` для вывода результатов в таблицу.

```sql
WATCH [db.]window_view
[EVENTS]
[LIMIT n]
[FORMAT format]
```

Запрос `WATCH` действует так же, как и в `LIVE VIEW`. Можно указать `LIMIT`, чтобы установить количество обновлений, которые необходимо получить, прежде чем завершить запрос. Оператор `EVENTS` может быть использован для получения короткой формы запроса `WATCH`, в котором вы получите только последнюю метку времени запроса вместо его результата.

### Настройки {#settings-1}

- `window_view_clean_interval`: Интервал очистки window-представления в секундах для освобождения устаревших данных. Система сохранит окна, которые не были полностью обработаны в соответствии с системным временем или конфигурацией `WATERMARK`, и другие данные будут удалены.
- `window_view_heartbeat_interval`: Интервал сердцебиения в секундах, чтобы показать, что запрос на просмотр изменений `WATCH` активен.
- `wait_for_window_view_fire_signal_timeout`: Тайм-аут ожидания сигнала срабатывания окна в процессе обработки времени события.

### Пример {#example}

Предположим, что нам нужно подсчитать количество журналов кликов каждые 10 секунд в таблице журналов, называемой `data`, а ее структура таблицы:

```sql
CREATE TABLE data ( `id` UInt64, `timestamp` DateTime) ENGINE = Memory;
```

Сначала мы создаем window-представление с работающим окном на интервале 10 секунд:

```sql
CREATE WINDOW VIEW wv as select count(id), tumbleStart(w_id) as window_start from data group by tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Затем мы используем запрос `WATCH` для получения результатов.

```sql
WATCH wv
```

Когда журналы вставляются в таблицу `data`,

```sql
INSERT INTO data VALUES(1,now())
```

Запрос `WATCH` должен вывести результаты, как показано ниже:

```text
┌─count(id)─┬────────window_start─┐
│         1 │ 2020-01-14 16:56:40 │
└───────────┴─────────────────────┘
```

Альтернативно, мы можем прикрепить вывод к другой таблице, используя синтаксис `TO`.

```sql
CREATE WINDOW VIEW wv TO dst AS SELECT count(id), tumbleStart(w_id) as window_start FROM data GROUP BY tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Дополнительные примеры можно найти среди стоимостных тестов ClickHouse (их названия содержат `*window_view*`).

### Использование window-представления {#window-view-usage}

Window-представление полезно в следующих сценариях:

* **Мониторинг**: Агрегировать и вычислять метрики журналов по времени и выводить результаты в целевую таблицу. Панель мониторинга может использовать целевую таблицу как исходную таблицу.
* **Анализ**: Автоматически агрегировать и предварительно обрабатывать данные во временном окне. Это может быть полезно при анализе большого количества журналов. Предварительная обработка устраняет повторные вычисления в нескольких запросах и уменьшает задержку запросов.

## Связанные материалы {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
- Блог: [Построение системы наблюдаемости с ClickHouse - Часть 2 - Трейсы](https://clickhouse.com/blog/storing-traces-and-spans-open-telemetry-in-clickhouse)
