---
description: 'Документация по CREATE VIEW'
sidebar_label: 'VIEW'
sidebar_position: 37
slug: /sql-reference/statements/create/view
title: 'CREATE VIEW'
---

import ExperimentalBadge from '@theme/badges/ExperimentalBadge';
import DeprecatedBadge from '@theme/badges/DeprecatedBadge';
import CloudNotSupportedBadge from '@theme/badges/CloudNotSupportedBadge';


# CREATE VIEW

Создает новое представление. Представления могут быть [обычными](#normal-view), [материализованными](#materialized-view), [обновляемыми материализованными](#refreshable-materialized-view) и [окнами](/sql-reference/statements/create/view#window-view) (обновляемое материализованное представление и оконное представление являются экспериментальными функциями).

## Normal View {#normal-view}

Синтаксис:

```sql
CREATE [OR REPLACE] VIEW [IF NOT EXISTS] [db.]table_name [(alias1 [, alias2 ...])] [ON CLUSTER cluster_name]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | INVOKER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

Обычные представления не хранят никаких данных. Они просто выполняют чтение из другой таблицы при каждом доступе. Другими словами, обычное представление — это ничто иное, как сохраненный запрос. При чтении из представления этот сохраненный запрос используется как подзапрос в условии [FROM](../../../sql-reference/statements/select/from.md).

В качестве примера предположим, что вы создали представление:

```sql
CREATE VIEW view AS SELECT ...
```

и написали запрос:

```sql
SELECT a, b, c FROM view
```

Этот запрос полностью эквивалентен использованию подзапроса:

```sql
SELECT a, b, c FROM (SELECT ...)
```

## Parameterized View {#parameterized-view}

Параметризованные представления аналогичны обычным представлениям, но могут быть созданы с параметрами, которые не разрешаются мгновенно. Эти представления могут быть использованы с табличными функциями, которые указывают имя представления как имя функции и значения параметров как ее аргументы.

```sql
CREATE VIEW view AS SELECT * FROM TABLE WHERE Column1={column1:datatype1} and Column2={column2:datatype2} ...
```
Выше создается представление для таблицы, которое может быть использовано как табличная функция, подставляя параметры, как показано ниже.

```sql
SELECT * FROM view(column1=value1, column2=value2 ...)
```

## Materialized View {#materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster_name] [TO[db.]name [(columns)]] [ENGINE = engine] [POPULATE]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```

:::tip
Вот пошаговое руководство по использованию [материализованных представлений](/guides/developer/cascading-materialized-views.md).
:::

Материализованные представления хранят данные, преобразованные с помощью соответствующего запроса [SELECT](../../../sql-reference/statements/select/index.md).

При создании материализованного представления без `TO [db].[table]` вы должны указать `ENGINE` – движок таблицы для хранения данных.

При создании материализованного представления с `TO [db].[table]` вы не можете также использовать `POPULATE`.

Материализованное представление реализовано следующим образом: при вставке данных в таблицу, указанную в `SELECT`, часть вставленных данных преобразуется с помощью этого запроса `SELECT`, а результат вставляется в представление.

:::note
Материализованные представления в ClickHouse используют **имена столбцов** вместо порядка столбцов при вставке в целевую таблицу. Если некоторые имена столбцов отсутствуют в результате запроса `SELECT`, ClickHouse использует значение по умолчанию, даже если столбец не является [Nullable](../../data-types/nullable.md). Безопасной практикой будет добавление псевдонимов для каждого столбца при использовании материализованных представлений.

Материализованные представления в ClickHouse реализованы более как триггеры вставки. Если в запросе представления есть некоторая агрегация, она применяется только к пакету вновь вставленных данных. Любые изменения существующих данных исходной таблицы (например, обновление, удаление, удаление раздела и т.д.) не изменяют материализованное представление.

Материализованные представления в ClickHouse не имеют детерминированного поведения в случае ошибок. Это означает, что блоки, которые уже были записаны, будут сохранены в целевой таблице, но все блоки после ошибки не будут.

По умолчанию, если отправка в одно из представлений не удалась, тогда запрос INSERT также выполнится с ошибкой, и некоторые блоки могут не быть записаны в целевую таблицу. Это можно изменить с помощью настройки `materialized_views_ignore_errors` (вы должны установить ее для запроса `INSERT`), если вы установите `materialized_views_ignore_errors=true`, то любые ошибки при отправке в представления будут игнорироваться, и все блоки будут записаны в целевую таблицу.

Также обратите внимание, что `materialized_views_ignore_errors` по умолчанию установлено в `true` для таблиц `system.*_log`.
:::

Если вы укажете `POPULATE`, данные существующей таблицы будут вставлены в представление при его создании, как если бы вы выполняли `CREATE TABLE ... AS SELECT ...`. В противном случае запрос будет содержать только данные, вставленные в таблицу после создания представления. Мы **не рекомендуем** использовать `POPULATE`, так как данные, вставленные в таблицу во время создания представления, не будут в него вставлены.

:::note
Учитывая, что `POPULATE` работает как `CREATE TABLE ... AS SELECT ...`, у него есть ограничения:
- Не поддерживается с реплицированными базами данных
- Не поддерживается в ClickHouse cloud

Вместо этого можно использовать отдельный `INSERT ... SELECT`.
:::

Запрос `SELECT` может содержать `DISTINCT`, `GROUP BY`, `ORDER BY`, `LIMIT`. Обратите внимание, что соответствующие преобразования выполняются независимо для каждого блока вставленных данных. Например, если установлен `GROUP BY`, данные агрегируются во время вставки, но только в пределах одного пакета вставленных данных. Данные не будут дополнительно агрегированы. Исключением является использование `ENGINE`, который независимо выполняет агрегацию данных, такой как `SummingMergeTree`.

Выполнение запросов [ALTER](/sql-reference/statements/alter/view.md) на материализованных представлениях имеет ограничения, например, вы не можете обновить запрос `SELECT`, поэтому это может быть неудобно. Если материализованное представление использует конструкцию `TO [db.]name`, вы можете `DETACH` представление, выполнить `ALTER` для целевой таблицы, а затем `ATTACH` ранее отсоединенное (`DETACH`) представление.

Обратите внимание, что материализованное представление подвержено влиянию настройки [optimize_on_insert](/operations/settings/settings#optimize_on_insert). Данные объединяются перед вставкой в представление.

Представления выглядят так же, как обычные таблицы. Например, они перечислены в результате запроса `SHOW TABLES`.

Чтобы удалить представление, используйте [DROP VIEW](../../../sql-reference/statements/drop.md#drop-view). Хотя `DROP TABLE` также работает для VIEW.

## SQL security {#sql_security}

`DEFINER` и `SQL SECURITY` позволяют вам указать, какого пользователя ClickHouse использовать при выполнении основного запроса представления.
`SQL SECURITY` имеет три допустимых значения: `DEFINER`, `INVOKER` или `NONE`. Вы можете указать любого существующего пользователя или `CURRENT_USER` в условии `DEFINER`.

Следующая таблица объясняет, какие права требуются для какого пользователя для выбора из представления.
Обратите внимание, что независимо от параметра безопасности SQL, в любом случае требуется иметь `GRANT SELECT ON <view>`, чтобы читать его.

| Параметр безопасности SQL | Представление                                                         | Материализованное представление                                                                                     |
|-----------------------------|-----------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| `DEFINER alice`             | `alice` должна иметь разрешение `SELECT` на исходную таблицу представления. | `alice` должна иметь разрешение `SELECT` на исходную таблицу представления и разрешение `INSERT` на целевую таблицу представления. |
| `INVOKER`                   | Пользователь должен иметь разрешение `SELECT` на исходную таблицу представления. | `SQL SECURITY INVOKER` не может быть указан для материализованных представлений.                                     |
| `NONE`                      | -                                                                     | -                                                                                                                    |

:::note
`SQL SECURITY NONE` является устаревшей опцией. Любой пользователь, имеющий права на создание представлений с `SQL SECURITY NONE`, сможет выполнять любой произвольный запрос.
Таким образом, для создания представления с этой опцией необходимо иметь `GRANT ALLOW SQL SECURITY NONE TO <user>`.
:::

Если `DEFINER`/`SQL SECURITY` не указаны, используются значения по умолчанию:
- `SQL SECURITY`: `INVOKER` для обычных представлений и `DEFINER` для материализованных представлений ([настраиваемо с помощью настроек](../../../operations/settings/settings.md#default_normal_view_sql_security))
- `DEFINER`: `CURRENT_USER` ([настраиваемо с помощью настроек](../../../operations/settings/settings.md#default_view_definer))

Если представление присоединено без указанных `DEFINER`/`SQL SECURITY`, значением по умолчанию является `SQL SECURITY NONE` для материализованного представления и `SQL SECURITY INVOKER` для обычного представления.

Чтобы изменить безопасность SQL для существующего представления, используйте
```sql
ALTER TABLE MODIFY SQL SECURITY { DEFINER | INVOKER | NONE } [DEFINER = { user | CURRENT_USER }]
```

### Examples {#examples}
```sql
CREATE VIEW test_view
DEFINER = alice SQL SECURITY DEFINER
AS SELECT ...
```

```sql
CREATE VIEW test_view
SQL SECURITY INVOKER
AS SELECT ...
```

## Live View {#live-view}

<DeprecatedBadge/>

Эта функция устарела и будет удалена в будущем.

Для вашего удобства старая документация находится [здесь](https://pastila.nl/?00f32652/fdf07272a7b54bda7e13b919264e449f.md)

## Refreshable Materialized View {#refreshable-materialized-view}

```sql
CREATE MATERIALIZED VIEW [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
REFRESH EVERY|AFTER interval [OFFSET interval]
[RANDOMIZE FOR interval]
[DEPENDS ON [db.]name [, [db.]name [, ...]]]
[SETTINGS name = value [, name = value [, ...]]]
[APPEND]
[TO[db.]name] [(columns)] [ENGINE = engine]
[EMPTY]
[DEFINER = { user | CURRENT_USER }] [SQL SECURITY { DEFINER | NONE }]
AS SELECT ...
[COMMENT 'comment']
```
где `interval` является последовательностью простых интервалов:
```sql
number SECOND|MINUTE|HOUR|DAY|WEEK|MONTH|YEAR
```

Периодически выполняет соответствующий запрос и хранит его результат в таблице.
 * Если в запросе указано `APPEND`, каждое обновление вставляет строки в таблицу, не удаляя существующие строки. Вставка не является атомарной, как и обычный INSERT SELECT.
 * В противном случае каждое обновление атомарно заменяет предыдущие данные таблицы.

Различия от обычных необновляемых материализованных представлений:
 * Нет триггера вставки. То есть когда новые данные вставляются в таблицу, указанную в SELECT, они *не* автоматически отправляются в обновляемое материализованное представление. Периодическое обновление выполняет весь запрос.
 * Нет ограничений на запрос SELECT. Табличные функции (например, `url()`), представления, UNION, JOIN, все разрешены.

:::note
Настройки в части запроса `REFRESH ... SETTINGS` являются настройками обновления (например, `refresh_retries`), отличными от обычных настроек (например, `max_threads`). Обычные настройки могут быть указаны с помощью `SETTINGS` в конце запроса.
:::

### Refresh Schedule {#refresh-schedule}

Примеры графиков обновления:
```sql
REFRESH EVERY 1 DAY -- каждый день, полночь (UTC)
REFRESH EVERY 1 MONTH -- 1-е число каждого месяца, полночь
REFRESH EVERY 1 MONTH OFFSET 5 DAY 2 HOUR -- 6-е число каждого месяца, в 2:00
REFRESH EVERY 2 WEEK OFFSET 5 DAY 15 HOUR 10 MINUTE -- каждую вторую субботу, в 15:10
REFRESH EVERY 30 MINUTE -- в 00:00, 00:30, 01:00, 01:30 и т.д.
REFRESH AFTER 30 MINUTE -- 30 минут после завершения предыдущего обновления, без привязки к времени дня
-- REFRESH AFTER 1 HOUR OFFSET 1 MINUTE -- синтаксическая ошибка, OFFSET не разрешен с AFTER
REFRESH EVERY 1 WEEK 2 DAYS -- каждые 9 дней, не в какой-либо конкретный день недели или месяца;
                            -- конкретно, когда номер дня (с 1969-12-29) делится на 9
REFRESH EVERY 5 MONTHS -- каждые 5 месяцев, разные месяцы каждый год (так как 12 не делится на 5);
                       -- конкретно, когда номер месяца (с 1970-01) делится на 5
```

`RANDOMIZE FOR` случайным образом корректирует время каждого обновления, например:
```sql
REFRESH EVERY 1 DAY OFFSET 2 HOUR RANDOMIZE FOR 1 HOUR -- каждый день в случайное время между 01:30 и 02:30
```

Не более одного обновления может выполняться одновременно для данного представления. Например, если представление с `REFRESH EVERY 1 MINUTE` требует 2 минуты на обновление, оно будет обновляться каждый раз через 2 минуты. Если оно затем станет быстрее и начнет обновляться за 10 секунд, оно вернется к обновлению каждые минуту. (В частности, оно не будет обновляться каждые 10 секунд, чтобы наверстать упущенные обновления - такого запаса не существует.)

Дополнительно, обновление начинается немедленно после создания материализованного представления, если `EMPTY` не указано в запросе `CREATE`. Если указано `EMPTY`, первое обновление происходит по расписанию.

### In Replicated DB {#in-replicated-db}

Если обновляемое материализованное представление находится в [реплицированной базе данных](../../../engines/database-engines/replicated.md), реплики координируют друг с другом так, что только одна реплика выполняет обновление в каждое запланированное время. Требуется движок таблиц [ReplicatedMergeTree](../../../engines/table-engines/mergetree-family/replication.md), чтобы все реплики видели данные, произведенные обновлением.

В режиме `APPEND` координацию можно отключить с помощью `SETTINGS all_replicas = 1`. Это позволяет репликам выполнять обновления независимо друг от друга. В этом случае ReplicatedMergeTree не требуется.

В не `APPEND` режиме поддерживается только совместное обновление. Для несогласованного используйте атомарную базу данных и запрос `CREATE ... ON CLUSTER`, чтобы создать обновляемые материализованные представления на всех репликах.

Координация осуществляется через Keeper. Путь znode определяется серверной настройкой [default_replica_path](../../../operations/server-configuration-parameters/settings.md#default_replica_path).

### Dependencies {#refresh-dependencies}

`DEPENDS ON` синхронизирует обновления различных таблиц. К примеру, предположим, что есть цепочка из двух обновляемых материализованных представлений:
```sql
CREATE MATERIALIZED VIEW source REFRESH EVERY 1 DAY AS SELECT * FROM url(...)
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY AS SELECT ... FROM source
```
Без `DEPENDS ON` оба представления начнут обновление в полночь, и `destination` обычно увидит данные вчерашнего дня в `source`. Если мы добавим зависимость:
```sql
CREATE MATERIALIZED VIEW destination REFRESH EVERY 1 DAY DEPENDS ON source AS SELECT ... FROM source
```
то обновление `destination` начнется только после завершения обновления `source` на этот день, так что `destination` будет основано на свежих данных.

В качестве альтернативы тот же результат можно достичь с помощью:
```sql
CREATE MATERIALIZED VIEW destination REFRESH AFTER 1 HOUR DEPENDS ON source AS SELECT ... FROM source
```
где `1 HOUR` может быть любой период, меньший, чем период обновления `source`. Зависимая таблица не будет обновляться чаще, чем любая из ее зависимостей. Это действительный способ создать цепочку обновляемых представлений, не указывая фактический период обновления более одного раза.

Вот еще несколько примеров:
 * `REFRESH EVERY 1 DAY OFFSET 10 MINUTE` (`destination`) зависит от `REFRESH EVERY 1 DAY` (`source`)<br/>
   Если обновление `source` занимает более 10 минут, `destination` будет ожидать его.
 * `REFRESH EVERY 1 DAY OFFSET 1 HOUR` зависит от `REFRESH EVERY 1 DAY OFFSET 23 HOUR`<br/>
   Похоже на вышеуказанное, несмотря на то, что соответствующие обновления происходят в разные календарные дни.
   Обновление `destination` в день X+1 будет ожидать обновления `source` в день X (если оно займет более 2 часов).
 * `REFRESH EVERY 2 HOUR` зависит от `REFRESH EVERY 1 HOUR`<br/>
   Обновление 2 HOUR происходит после обновления 1 HOUR через каждый другой час, например, после обновления в полночь,
   затем после обновления в 2:00 и т.д.
 * `REFRESH EVERY 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH EVERY 2 HOUR`<br/>
   `REFRESH AFTER 1 MINUTE` зависит от `REFRESH AFTER 2 HOUR`<br/>
   `destination` обновляется один раз после каждого обновления `source`, т.е. каждые 2 часа. `1 MINUTE` фактически игнорируется.
 * `REFRESH AFTER 1 HOUR` зависит от `REFRESH AFTER 1 HOUR`<br/>
   В настоящее время это не рекомендуется.

:::note
`DEPENDS ON` работает только между обновляемыми материализованными представлениями. Указание обычной таблицы в списке `DEPENDS ON` не позволит представлению когда-либо обновиться (зависимости могут быть удалены с помощью `ALTER`, см. ниже).
:::

### Settings {#settings}

Доступные настройки обновления:
 * `refresh_retries` - Сколько раз следует пытаться, если запрос на обновление закончился исключением. Если все попытки не удались, переходите к следующему запланированному времени обновления. 0 означает отсутствие повторных попыток, -1 означает бесконечные попытки. По умолчанию: 0.
 * `refresh_retry_initial_backoff_ms` - Задержка перед первой повторной попыткой, если `refresh_retries` не равно нулю. Каждая следующая попытка удваивает задержку, до `refresh_retry_max_backoff_ms`. По умолчанию: 100 мс.
 * `refresh_retry_max_backoff_ms` - Ограничение на экспоненциальный рост задержки между попытками обновления. По умолчанию: 60000 мс (1 минута).

### Changing Refresh Parameters {#changing-refresh-parameters}

Чтобы изменить параметры обновления:
```sql
ALTER TABLE [db.]name MODIFY REFRESH EVERY|AFTER ... [RANDOMIZE FOR ...] [DEPENDS ON ...] [SETTINGS ...]
```

:::note
Это заменяет *все* параметры обновления сразу: расписание, зависимости, настройки и APPEND-ность. Например, если у таблицы было `DEPENDS ON`, выполнение `MODIFY REFRESH` без `DEPENDS ON` удалит зависимости.
:::

### Other operations {#other-operations}

Статус всех обновляемых материализованных представлений доступен в таблице [`system.view_refreshes`](../../../operations/system-tables/view_refreshes.md). В частности, она содержит информацию об обновлении (если выполняется), последнее и следующее время обновления, сообщение об исключении, если обновление не удалось.

Чтобы вручную остановить, запустить, вызвать или отменить обновления, используйте [`SYSTEM STOP|START|REFRESH|WAIT|CANCEL VIEW`](../system.md#refreshable-materialized-views).

Чтобы дождаться завершения обновления, используйте [`SYSTEM WAIT VIEW`](../system.md#refreshable-materialized-views). В частности, полезно для ожидания начального обновления после создания представления.

:::note
Забавный факт: запрос на обновление может читать из представления, которое обновляется, видя версию данных до обновления. Это означает, что вы можете реализовать игру жизни Конвея: https://pastila.nl/?00021a4b/d6156ff819c83d490ad2dcec05676865#O0LGWTO7maUQIA4AcGUtlA==
:::

## Window View {#window-view}

<ExperimentalBadge/>
<CloudNotSupportedBadge/>

:::info
Это экспериментальная функция, которая может измениться в несовместимых с предыдущими версиями в будущих релизах. Включите использование оконных представлений и запроса `WATCH` с помощью настройки [allow_experimental_window_view](/operations/settings/settings#allow_experimental_window_view). Введите команду `set allow_experimental_window_view = 1`.
:::

```sql
CREATE WINDOW VIEW [IF NOT EXISTS] [db.]table_name [TO [db.]table_name] [INNER ENGINE engine] [ENGINE engine] [WATERMARK strategy] [ALLOWED_LATENESS interval_function] [POPULATE]
AS SELECT ...
GROUP BY time_window_function
[COMMENT 'comment']
```

Оконное представление может агрегировать данные по временным окнам и выводить результаты, когда окно готово к срабатыванию. Оно хранит частичные результаты агрегации во внутренней (или заданной) таблице, чтобы уменьшить задержку, и может отправить обработанные результаты в заданную таблицу или отправить уведомления с помощью запроса WATCH.

Создание оконного представления похоже на создание `MATERIALIZED VIEW`. Оконному представлению необходим движок внутреннего хранилища для хранения промежуточных данных. Внутреннее хранилище можно указать с помощью условия `INNER ENGINE`, по умолчанию оконное представление будет использовать `AggregatingMergeTree`.

При создании оконного представления без `TO [db].[table]` вы должны указать `ENGINE` – движок таблицы для хранения данных.

### Time Window Functions {#time-window-functions}

[Функции временного окна](../../functions/time-window-functions.md) используются для получения нижней и верхней границы окна записей. Оконное представление должно использоваться с функцией временного окна.

### TIME ATTRIBUTES {#time-attributes}

Оконное представление поддерживает **время обработки** и **время события**.

**Время обработки** позволяет оконному представлению выдавать результаты на основе времени локальной машины и используется по умолчанию. Это наиболее простое понятие времени, но не обеспечивает детерминированности. Атрибут времени обработки можно определить, установив `time_attr` функции временного окна в столбец таблицы или используя функцию `now()`. Следующий запрос создает оконное представление с временем обработки.

```sql
CREATE WINDOW VIEW wv AS SELECT count(number), tumbleStart(w_id) as w_start from date GROUP BY tumble(now(), INTERVAL '5' SECOND) as w_id
```

**Время события** – это время, когда каждое отдельное событие произошло на своем устройстве. Это время обычно встроено в записи, когда оно создается. Обработка времени события позволяет получать согласованные результаты, даже в случае неупорядоченных событий или поздних событий. Оконное представление поддерживает обработку по времени событий с помощью синтаксиса `WATERMARK`.

Оконное представление предоставляет три стратегии водяного знака:

* `STRICTLY_ASCENDING`: Выдает водяной знак максимальной наблюдаемой метки времени на данный момент. Строки с меткой времени, меньшей, чем максимальная метка времени, не считаются опоздавшими.
* `ASCENDING`: Выдает водяной знак максимальной наблюдаемой метки времени на данный момент минус 1. Строки с меткой времени, равной и меньшей максимальной метке времени, не считаются опоздавшими.
* `BOUNDED`: WATERMARK=INTERVAL. Выдает водяные знаки, которые являются максимальной наблюдаемой меткой времени минус указанная задержка.

Следующие запросы являются примерами создания оконного представления с использованием `WATERMARK`:

```sql
CREATE WINDOW VIEW wv WATERMARK=STRICTLY_ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=ASCENDING AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
CREATE WINDOW VIEW wv WATERMARK=INTERVAL '3' SECOND AS SELECT count(number) FROM date GROUP BY tumble(timestamp, INTERVAL '5' SECOND);
```

По умолчанию окно будет срабатывать, когда поступает водяной знак, и элементы, которые прибыли за водяным знаком, будут отброшены. Оконное представление поддерживает обработку поздних событий, устанавливая `ALLOWED_LATENESS=INTERVAL`. Пример обработки задержки:

```sql
CREATE WINDOW VIEW test.wv TO test.dst WATERMARK=ASCENDING ALLOWED_LATENESS=INTERVAL '2' SECOND AS SELECT count(a) AS count, tumbleEnd(wid) AS w_end FROM test.mt GROUP BY tumble(timestamp, INTERVAL '5' SECOND) AS wid;
```

Обратите внимание, что элементы, выданные за поздним срабатыванием, следует рассматривать как обновленные результаты предыдущего вычисления. Вместо того, чтобы срабатывать в конце окон, оконное представление будет срабатывать немедленно, когда поступает позднее событие. Таким образом, это приведет к нескольким результатам для одного и того же окна. Пользователям необходимо учитывать эти дублированные результаты или устранять их дублирование.

Вы можете изменить запрос `SELECT`, который был указан в оконном представлении, используя оператор `ALTER TABLE ... MODIFY QUERY`. Структура данных, получающаяся в результате нового запроса `SELECT`, должна соответствовать оригинальному запросу `SELECT`, независимо от наличия условий `TO [db.]name`. Обратите внимание, что данные в текущем окне будут утеряны, потому что промежуточное состояние не может быть переиспользовано.

### Monitoring New Windows {#monitoring-new-windows}

Оконное представление поддерживает запрос [WATCH](../../../sql-reference/statements/watch.md) для мониторинга изменений или использует синтаксис `TO` для вывода результатов в таблицу.

```sql
WATCH [db.]window_view
[EVENTS]
[LIMIT n]
[FORMAT format]
```

Запрос `WATCH` функционирует аналогично запросу в `LIVE VIEW`. Можно указать `LIMIT`, чтобы установить количество обновлений, которые нужно получить перед завершением запроса. Условие `EVENTS` можно использовать для получения короткой формы запроса `WATCH`, в которой вместо результата запроса вы получите только последнюю водяную метку запроса.

### Settings {#settings-1}

- `window_view_clean_interval`: Интервал очистки оконного представления в секундах для освобождения устаревших данных. Система сохранит окна, которые не были полностью активированы в соответствии с системным временем или конфигурацией `WATERMARK`, а другие данные будут удалены.
- `window_view_heartbeat_interval`: Интервал пульса в секундах для индикации жизни запроса WATCH.
- `wait_for_window_view_fire_signal_timeout`: Таймаут для ожидания сигнала активации оконного представления в обработке событий.

### Example {#example}

Предположим, нам нужно подсчитать количество журналов кликов каждые 10 секунд в таблице журналов под названием `data`, и ее структура таблицы следующая:

```sql
CREATE TABLE data ( `id` UInt64, `timestamp` DateTime) ENGINE = Memory;
```

Сначала создаем оконное представление с временным интервалом 10 секунд:

```sql
CREATE WINDOW VIEW wv as select count(id), tumbleStart(w_id) as window_start from data group by tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Затем используем запрос `WATCH`, чтобы получить результаты.

```sql
WATCH wv
```

Когда журналы вставляются в таблицу `data`,

```sql
INSERT INTO data VALUES(1,now())
```

Запрос `WATCH` должен выводить результаты следующим образом:

```text
┌─count(id)─┬────────window_start─┐
│         1 │ 2020-01-14 16:56:40 │
└───────────┴─────────────────────┘
```

В качестве альтернативы, мы можем прикрепить вывод к другой таблице, используя синтаксис `TO`.

```sql
CREATE WINDOW VIEW wv TO dst AS SELECT count(id), tumbleStart(w_id) as window_start FROM data GROUP BY tumble(timestamp, INTERVAL '10' SECOND) as w_id
```

Дополнительные примеры можно найти среди состояниевых тестов ClickHouse (они называются `*window_view*` там).

### Window View Usage {#window-view-usage}

Оконное представление полезно в следующих сценариях:

* **Мониторинг**: Агрегируйте и рассчитывайте метрики журналов по времени и выводите результаты в целевую таблицу. Панель управления может использовать целевую таблицу в качестве исходной таблицы.
* **Анализ**: Автоматически агрегируйте и предварительно обрабатывайте данные в временном окне. Это может быть полезным при анализе большого количества журналов. Предварительная обработка устраняет повторные вычисления в нескольких запросах и снижает задержку запросов.

## Related Content {#related-content}

- Блог: [Работа с данными временных рядов в ClickHouse](https://clickhouse.com/blog/working-with-time-series-data-and-functions-ClickHouse)
- Блог: [Создание решения по наблюдаемости с ClickHouse - Часть 2 - Трейсы](https://clickhouse.com/blog/storing-traces-and-spans-open-telemetry-in-clickhouse)
