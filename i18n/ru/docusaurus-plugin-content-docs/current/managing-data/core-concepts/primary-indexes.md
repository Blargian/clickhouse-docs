---
slug: /primary-indexes
title: 'Первичные индексы'
description: 'Как работает разреженный первичный индекс в ClickHouse'
keywords: ['разреженный первичный индекс', 'первичный индекс', 'индекс']
---


import visual01 from '@site/static/images/managing-data/core-concepts/primary-index-light_01.gif';
import visual02 from '@site/static/images/managing-data/core-concepts/primary-index-light_02.gif';
import visual03 from '@site/static/images/managing-data/core-concepts/primary-index-light_03.gif';

import Image from '@theme/IdealImage';


:::tip Ищете подробности об индексации?
Эта страница представляет разреженный первичный индекс ClickHouse, как он строится, как работает и как помогает ускорять запросы.

Для более продвинутых стратегий индексации и более глубоких технических деталей, смотрите [глубокое погружение в первичные индексы](/guides/best-practices/sparse-primary-indexes).
:::


## Как работает разреженный первичный индекс в ClickHouse? {#how-does-the-sparse-primary-index-work-in-clickHouse}

<br/>

Разреженный первичный индекс в ClickHouse помогает эффективно идентифицировать [гранулы](https://clickhouse.com/docs/guides/best-practices/sparse-primary-indexes#data-is-organized-into-granules-for-parallel-data-processing)—блоки строк, которые могут содержать данные, соответствующие условиям запроса по первичным ключевым колонкам таблицы. В следующем разделе мы объясним, как этот индекс строится из значений в этих колонках.

### Создание разреженного первичного индекса {#sparse-primary-index-creation}

Чтобы проиллюстрировать, как строится разреженный первичный индекс, мы используем таблицу [uk_price_paid_simple](https://clickhouse.com/docs/parts) вместе с некоторыми анимациями.

Как [напоминание](https://clickhouse.com/docs/parts), в нашей ① примерной таблице с первичным ключом (town, street), ② вставленные данные ③ хранятся на диске, отсортированные по значениям колонок первичного ключа и сжаты, в отдельных файлах для каждой колонки:

<Image img={visual01} size="lg"/>

<br/><br/>

Для обработки данные каждой колонки ④ логически делятся на гранулы — каждая из которых охватывает 8,192 строки — которые являются наименьшими единицами, с которыми работает механика обработки данных в ClickHouse.

Эта структура гранул также делает первичный индекс **разреженным**: вместо индексации каждой строки, ClickHouse хранит ⑤ значения первичного ключа только из одной строки на гранулу — а именно, из первой строки. Это приводит к тому, что на гранулу приходится одна запись индекса:

<Image img={visual02} size="lg"/>

<br/><br/>

Благодаря своему разрежению первичный индекс достаточно мал, чтобы полностью поместиться в памяти, что обеспечивает быстрое фильтрацию для запросов с предикатами по колонкам первичного ключа. В следующем разделе мы покажем, как он помогает ускорять такие запросы.


### Использование первичного индекса {#primary-index-usage}

Мы схематически покажем, как разреженный первичный индекс используется для ускорения запросов с помощью другой анимации:

<Image img={visual03} size="lg"/>

<br/><br/>

① Пример запроса включает предикат по обеим колонкам первичного ключа: `town = 'LONDON' AND street = 'OXFORD STREET'`.

② Чтобы ускорить запрос, ClickHouse загружает первичный индекс таблицы в память.

③ Затем он сканирует записи индекса, чтобы определить, какие гранулы могут содержать строки, соответствующие предикату, другими словами, какие гранулы нельзя пропустить.

④ Эти потенциально релевантные гранулы затем загружаются и [обрабатываются](/optimize/query-parallelism) в памяти, вместе с соответствующими гранулами из любых других колонок, необходимых для запроса.


## Мониторинг первичных индексов {#monitoring-primary-indexes}

Каждая [часть данных](/parts) в таблице имеет свой собственный первичный индекс. Мы можем просмотреть содержимое этих индексов, используя табличную функцию [mergeTreeIndex](/sql-reference/table-functions/mergeTreeIndex).

Следующий запрос перечисляет количество записей в первичном индексе для каждой части данных нашей примерной таблицы:

```sql
SELECT
    part_name,
    max(mark_number) as entries
FROM mergeTreeIndex('uk', 'uk_price_paid_simple')
GROUP BY part_name;
```


```txt
   ┌─part_name─┬─entries─┐
1. │ all_2_2_0 │     914 │
2. │ all_1_1_0 │    1343 │
3. │ all_0_0_0 │    1349 │
   └───────────┴─────────┘
```

Этот запрос показывает первые 10 записей из первичного индекса одной из текущих частей данных. Обратите внимание, что эти части постоянно [сливаются](/merges) в фоновом режиме в более крупные части:

```sql 
SELECT 
    mark_number + 1 as entry,
    town,
    street
FROM mergeTreeIndex('uk', 'uk_price_paid_simple')
WHERE part_name = (SELECT any(part_name) FROM mergeTreeIndex('uk', 'uk_price_paid_simple')) 
ORDER BY mark_number ASC
LIMIT 10;
```


```txt
    ┌─entry─┬─town───────────┬─street───────────┐
 1. │     1 │ ABBOTS LANGLEY │ ABBEY DRIVE      │
 2. │     2 │ ABERDARE       │ RICHARDS TERRACE │
 3. │     3 │ ABERGELE       │ PEN Y CAE        │
 4. │     4 │ ABINGDON       │ CHAMBRAI CLOSE   │
 5. │     5 │ ABINGDON       │ THORNLEY CLOSE   │
 6. │     6 │ ACCRINGTON     │ MAY HILL CLOSE   │
 7. │     7 │ ADDLESTONE     │ HARE HILL        │
 8. │     8 │ ALDEBURGH      │ LINDEN ROAD      │
 9. │     9 │ ALDERSHOT      │ HIGH STREET      │
10. │    10 │ ALFRETON       │ ALMA STREET      │
    └───────┴────────────────┴──────────────────┘
```

Наконец, мы используем оператор [EXPLAIN](/sql-reference/statements/explain), чтобы увидеть, как первичные индексы всех частей данных используются для пропуска гранул, которые не могут содержать строки, соответствующие предикатам примерного запроса. Эти гранулы исключаются из загрузки и обработки:
```sql
EXPLAIN indexes = 1
SELECT
    max(price)
FROM
    uk.uk_price_paid_simple
WHERE
    town = 'LONDON' AND street = 'OXFORD STREET';
```


```txt
    ┌─explain────────────────────────────────────────────────────────────────────────────────────────────────────┐
 1. │ Expression ((Project names + Projection))                                                                  │
 2. │   Aggregating                                                                                              │
 3. │     Expression (Before GROUP BY)                                                                           │
 4. │       Expression                                                                                           │
 5. │         ReadFromMergeTree (uk.uk_price_paid_simple)                                                        │
 6. │         Indexes:                                                                                           │
 7. │           PrimaryKey                                                                                       │
 8. │             Keys:                                                                                          │
 9. │               town                                                                                         │
10. │               street                                                                                       │
11. │             Condition: and((street in ['OXFORD STREET', 'OXFORD STREET']), (town in ['LONDON', 'LONDON'])) │
12. │             Parts: 3/3                                                                                     │
13. │             Granules: 3/3609                                                                               │
    └────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```


Обратите внимание, что строка 13 вывода EXPLAIN показывает, что только 3 из 3,609 гранул по всем частям данных были выбраны для обработки анализом первичного индекса. Оставшиеся гранулы были полностью пропущены.

Мы также можем наблюдать, что большая часть данных была пропущена, просто запустив запрос:
```sql 
SELECT max(price)
FROM uk.uk_price_paid_simple
WHERE (town = 'LONDON') AND (street = 'OXFORD STREET');
```


```txt
   ┌─max(price)─┐
1. │  263100000 │ -- 263.10 миллиона
   └────────────┘

1 row in set. Elapsed: 0.010 sec. Processed 24.58 thousand rows, 159.04 KB (2.53 million rows/s., 16.35 MB/s.)
Peak memory usage: 13.00 MiB.
```

Как показано выше, было обработано всего около 25,000 строк из примерно 30 миллионов строк в примерной таблице:
```sql 
SELECT count() FROM uk.uk_price_paid_simple;
```

```txt
   ┌──count()─┐
1. │ 29556244 │ -- 29.56 миллиона
   └──────────┘
```

## Основные выводы {#key-takeaways}

* **Разреженные первичные индексы** помогают ClickHouse пропускать ненужные данные, идентифицируя, какие гранулы могут содержать строки, соответствующие условиям запроса по первичным ключевым колонкам. 

* Каждый индекс хранит только значения первичного ключа из **первой строки каждой гранулы** (гранула по умолчанию содержит 8,192 строки), что делает его компактным и способным помещаться в памяти. 

* **Каждая часть данных** в таблице MergeTree имеет **свой собственный первичный индекс**, который используется независимо во время выполнения запроса. 

* Во время выполнения запросов индекс позволяет ClickHouse **пропускать гранулы**, снижая ввод-вывод и использование памяти, одновременно ускоряя производительность. 

* Вы можете **проверять содержимое индекса**, используя табличную функцию `mergeTreeIndex`, и контролировать использование индекса с помощью оператора `EXPLAIN`.


## Где найти дополнительную информацию {#where-to-find-more-information}

Для более глубокого ознакомления с тем, как работают разреженные первичные индексы в ClickHouse, включая то, как они отличаются от традиционных базовых индексов и лучшие практики их использования, ознакомьтесь с нашим подробным [глубоким погружением в индексацию](/guides/best-practices/sparse-primary-indexes).

Если вас интересует, как ClickHouse обрабатывает данные, выбранные с помощью сканирования первичного индекса, в высокопараллельном режиме, ознакомьтесь с руководством по параллелизму запросов [здесь](/optimize/query-parallelism).
