---
description: 'Документация для клауса GROUP BY'
sidebar_label: 'GROUP BY'
slug: /sql-reference/statements/select/group-by
title: 'Клаус GROUP BY'
---


# Клаус GROUP BY

Клаус `GROUP BY` переключает запрос `SELECT` в режим агрегации, который работает следующим образом:

- Клаус `GROUP BY` содержит список выражений (или одно выражение, которое считается списком длины один). Этот список действует как "ключ группировки", в то время как каждое отдельное выражение будет называться "ключевым выражением".
- Все выражения в [SELECT](/sql-reference/statements/select/index.md), [HAVING](/sql-reference/statements/select/having.md) и [ORDER BY](/sql-reference/statements/select/order-by.md) **должны** быть рассчитаны на основе ключевых выражений **или** использоваться в [агрегатных функциях](../../../sql-reference/aggregate-functions/index.md) для неключевых выражений (включая обычные колонки). Другими словами, каждая колонка, выбранная из таблицы, должна быть использована либо в ключевом выражении, либо внутри агрегатной функции, но не и в том, и в другом.
- Результат агрегирующего запроса `SELECT` будет содержать столько строк, сколько уникальных значений "ключа группировки" в исходной таблице. Обычно это значительно уменьшает количество строк, часто на порядок, но не обязательно: количество строк остается таким же, если все значения "ключа группировки" были различными.

Когда вы хотите группировать данные в таблице по номерам колонок вместо имен колонок, включите настройку [enable_positional_arguments](/operations/settings/settings#enable_positional_arguments).

:::note
Существует дополнительный способ выполнения агрегации по таблице. Если запрос содержит только колонки таблицы внутри агрегатных функций, клаус `GROUP BY` можно опустить, и агрегация по пустому набору ключей считается подразумеваемой. Такие запросы всегда возвращают ровно одну строку.
:::

## Обработка NULL {#null-processing}

Для группировки ClickHouse интерпретирует [NULL](/sql-reference/syntax#null) как значение, и `NULL==NULL`. Это отличается от обработки `NULL` в большинстве других контекстов.

Вот пример, чтобы показать, что это значит.

Предположим, у вас есть эта таблица:

```text
┌─x─┬────y─┐
│ 1 │    2 │
│ 2 │ ᴺᵁᴸᴸ │
│ 3 │    2 │
│ 3 │    3 │
│ 3 │ ᴺᵁᴸᴸ │
└───┴──────┘
```

Запрос `SELECT sum(x), y FROM t_null_big GROUP BY y` возвращает:

```text
┌─sum(x)─┬────y─┐
│      4 │    2 │
│      3 │    3 │
│      5 │ ᴺᵁᴸᴸ │
└────────┴──────┘
```

Вы можете видеть, что `GROUP BY` для `y = NULL` суммировал `x`, как будто `NULL` является этим значением.

Если вы передаете несколько ключей в `GROUP BY`, результат даст вам все комбинации выборки, как будто `NULL` было конкретным значением.

## Модификатор ROLLUP {#rollup-modifier}

Модификатор `ROLLUP` используется для вычисления промежуточных итогов для ключевых выражений, основываясь на их порядке в списке `GROUP BY`. Строки промежуточных итогов добавляются после результирующей таблицы.

Промежуточные итоги рассчитываются в обратном порядке: сначала промежуточные итоги рассчитываются для последнего ключевого выражения в списке, затем для предыдущего, и так далее до первого ключевого выражения.

В строках промежуточных итогов значения уже "группированных" ключевых выражений устанавливаются в `0` или пустую строку.

:::note
Имейте в виду, что клаус [HAVING](/sql-reference/statements/select/having.md) может повлиять на результаты промежуточных итогов.
:::

**Пример**

Рассмотрим таблицу t:

```text
┌─year─┬─month─┬─day─┐
│ 2019 │     1 │   5 │
│ 2019 │     1 │  15 │
│ 2020 │     1 │   5 │
│ 2020 │     1 │  15 │
│ 2020 │    10 │   5 │
│ 2020 │    10 │  15 │
└──────┴───────┴─────┘
```

Запрос:

```sql
SELECT year, month, day, count(*) FROM t GROUP BY ROLLUP(year, month, day);
```
Так как секция `GROUP BY` имеет три ключевых выражения, результат содержит четыре таблицы с промежуточными итогами, "свернутыми" справа налево:

- `GROUP BY year, month, day`;
- `GROUP BY year, month` (и колонка `day` заполнена нулями);
- `GROUP BY year` (теперь колонки `month` и `day` обе заполнены нулями);
- и итоги (и все три ключевых выражения имеют значение ноль).

```text
┌─year─┬─month─┬─day─┬─count()─┐
│ 2020 │    10 │  15 │       1 │
│ 2020 │     1 │   5 │       1 │
│ 2019 │     1 │   5 │       1 │
│ 2020 │     1 │  15 │       1 │
│ 2019 │     1 │  15 │       1 │
│ 2020 │    10 │   5 │       1 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│ 2019 │     1 │   0 │       2 │
│ 2020 │     1 │   0 │       2 │
│ 2020 │    10 │   0 │       2 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│ 2019 │     0 │   0 │       2 │
│ 2020 │     0 │   0 │       4 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│    0 │     0 │   0 │       6 │
└──────┴───────┴─────┴─────────┘
```
Тот же запрос также может быть записан с использованием ключевого слова `WITH`.
```sql
SELECT year, month, day, count(*) FROM t GROUP BY year, month, day WITH ROLLUP;
```

**Смотрите также**

- Настройка [group_by_use_nulls](/operations/settings/settings.md#group_by_use_nulls) для совместимости со стандартом SQL.

## Модификатор CUBE {#cube-modifier}

Модификатор `CUBE` используется для вычисления промежуточных итогов для каждой комбинации ключевых выражений в списке `GROUP BY`. Строки промежуточных итогов добавляются после результирующей таблицы.

В строках промежуточных итогов значения всех "группированных" ключевых выражений устанавливаются в `0` или пустую строку.

:::note
Имейте в виду, что клаус [HAVING](/sql-reference/statements/select/having.md) может повлиять на результаты промежуточных итогов.
:::

**Пример**

Рассмотрим таблицу t:

```text
┌─year─┬─month─┬─day─┐
│ 2019 │     1 │   5 │
│ 2019 │     1 │  15 │
│ 2020 │     1 │   5 │
│ 2020 │     1 │  15 │
│ 2020 │    10 │   5 │
│ 2020 │    10 │  15 │
└──────┴───────┴─────┘
```

Запрос:

```sql
SELECT year, month, day, count(*) FROM t GROUP BY CUBE(year, month, day);
```

Так как секция `GROUP BY` имеет три ключевых выражения, результат содержит восемь таблиц с промежуточными итогами для всех комбинаций ключевых выражений:

- `GROUP BY year, month, day`
- `GROUP BY year, month`
- `GROUP BY year, day`
- `GROUP BY year`
- `GROUP BY month, day`
- `GROUP BY month`
- `GROUP BY day`
- и итоги.

Колонки, исключенные из `GROUP BY`, заполняются нулями.

```text
┌─year─┬─month─┬─day─┬─count()─┐
│ 2020 │    10 │  15 │       1 │
│ 2020 │     1 │   5 │       1 │
│ 2019 │     1 │   5 │       1 │
│ 2020 │     1 │  15 │       1 │
│ 2019 │     1 │  15 │       1 │
│ 2020 │    10 │   5 │       1 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│ 2019 │     1 │   0 │       2 │
│ 2020 │     1 │   0 │       2 │
│ 2020 │    10 │   0 │       2 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│ 2020 │     0 │   5 │       2 │
│ 2019 │     0 │   5 │       1 │
│ 2020 │     0 │  15 │       2 │
│ 2019 │     0 │  15 │       1 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│ 2019 │     0 │   0 │       2 │
│ 2020 │     0 │   0 │       4 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│    0 │     1 │   5 │       2 │
│    0 │    10 │  15 │       1 │
│    0 │    10 │   5 │       1 │
│    0 │     1 │  15 │       2 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│    0 │     1 │   0 │       4 │
│    0 │    10 │   0 │       2 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│    0 │     0 │   5 │       3 │
│    0 │     0 │  15 │       3 │
└──────┴───────┴─────┴─────────┘
┌─year─┬─month─┬─day─┬─count()─┐
│    0 │     0 │   0 │       6 │
└──────┴───────┴─────┴─────────┘
```
Тот же запрос также может быть записан с использованием ключевого слова `WITH`.
```sql
SELECT year, month, day, count(*) FROM t GROUP BY year, month, day WITH CUBE;
```

**Смотрите также**

- Настройка [group_by_use_nulls](/operations/settings/settings.md#group_by_use_nulls) для совместимости со стандартом SQL.

## Модификатор WITH TOTALS {#with-totals-modifier}

Если специфицирован модификатор `WITH TOTALS`, будет рассчитана еще одна строка. Эта строка будет иметь ключевые колонки с содержащими значениями по умолчанию (нули или пустые строки), и колонки агрегатных функций с значениями, рассчитанными по всем строкам (значениями "итогов").

Эта дополнительная строка создается только в форматах `JSON*`, `TabSeparated*` и `Pretty*`, отдельно от других строк:

- В форматах `XML` и `JSON*` эта строка выводится как отдельное поле 'totals'.
- В `TabSeparated*`, `CSV*` и `Vertical` форматах, строка идет после основного результата, предваренная пустой строкой (после других данных).
- В `Pretty*` форматах, строка выводится как отдельная таблица после основного результата.
- В формате `Template` строка выводится в соответствии с указанным шаблоном.
- В других форматах она не доступна.

:::note
Итоги выводятся в результатах запросов `SELECT`, и не выводятся в `INSERT INTO ... SELECT`.
:::

`WITH TOTALS` может выполняться в разных вариантах, когда присутствует [HAVING](/sql-reference/statements/select/having.md). Поведение зависит от настройки `totals_mode`.

### Настройка обработки итогов {#configuring-totals-processing}

По умолчанию, `totals_mode = 'before_having'`. В этом случае, 'итоги' рассчитываются по всем строкам, включая те, которые не проходят через HAVING и `max_rows_to_group_by`.

Другие альтернативы включают только строки, которые проходят через HAVING в 'итогах', и ведут себя по-разному с настройкой `max_rows_to_group_by` и `group_by_overflow_mode = 'any'`.

`after_having_exclusive` – Не включать строки, которые не прошли через `max_rows_to_group_by`. Другими словами, 'итоги' будут иметь меньшее или такое же количество строк, как если бы `max_rows_to_group_by` был опущен.

`after_having_inclusive` – Включить все строки, которые не прошли через 'max_rows_to_group_by' в 'итоги'. Другими словами, 'итоги' будут иметь большее или такое же количество строк, как если бы `max_rows_to_group_by` был опущен.

`after_having_auto` – Подсчитать количество строк, которые прошли через HAVING. Если их больше определенного количества (по умолчанию, 50%), включить все строки, которые не прошли через 'max_rows_to_group_by' в 'итоги'. В противном случае, не включать их.

`totals_auto_threshold` – По умолчанию, 0.5. Коэффициент для `after_having_auto`.

Если `max_rows_to_group_by` и `group_by_overflow_mode = 'any'` не используются, все варианты `after_having` одинаковы, и вы можете использовать любой из них (например, `after_having_auto`).

Вы можете использовать `WITH TOTALS` в подзапросах, включая подзапросы в клаусе [JOIN](/sql-reference/statements/select/join.md) (в этом случае соответствующие итоговые значения комбинируются).

## GROUP BY ALL {#group-by-all}

`GROUP BY ALL` эквивалентно перечислению всех выражений SELECT, которые не являются агрегатными функциями.

Например:

```sql
SELECT
    a * 2,
    b,
    count(c),
FROM t
GROUP BY ALL
```

это то же самое, что и

```sql
SELECT
    a * 2,
    b,
    count(c),
FROM t
GROUP BY a * 2, b
```

Для специального случая, когда есть функция, имеющая как агрегатные функции, так и другие поля в качестве аргументов, ключи `GROUP BY` будут содержать максимальные неагрегатные поля, которые можно из этого извлечь.

Например:

```sql
SELECT
    substring(a, 4, 2),
    substring(substring(a, 1, 2), 1, count(b))
FROM t
GROUP BY ALL
```

это то же самое, что и

```sql
SELECT
    substring(a, 4, 2),
    substring(substring(a, 1, 2), 1, count(b))
FROM t
GROUP BY substring(a, 4, 2), substring(a, 1, 2)
```

## Примеры {#examples}

Пример:

```sql
SELECT
    count(),
    median(FetchTiming > 60 ? 60 : FetchTiming),
    count() - sum(Refresh)
FROM hits
```

В отличие от MySQL (и согласно стандарту SQL), вы не можете получить некоторое значение из колонки, которое не находится в ключе или агрегатной функции (кроме постоянных выражений). Чтобы обойти это, вы можете использовать агрегатную функцию 'any' (получить первое найденное значение) или 'min/max'.

Пример:

```sql
SELECT
    domainWithoutWWW(URL) AS domain,
    count(),
    any(Title) AS title -- получение первого заголовка страницы для каждого домена.
FROM hits
GROUP BY domain
```

Для каждого различного значения ключа, встречающегося, `GROUP BY` вычисляет набор значений агрегатной функции.

## Модификатор GROUPING SETS {#grouping-sets-modifier}

Это самый общий модификатор.
Этот модификатор позволяет вручную указывать несколько наборов ключей агрегации (группировки).
Агрегация выполняется отдельно для каждого набора группировки, а затем все результаты комбинируются.
Если колонка не представлена в наборе группировки, она заполняется значением по умолчанию.

Другими словами, модификаторы, описанные выше, могут быть представлены через `GROUPING SETS`.
Несмотря на то, что запросы с модификаторами `ROLLUP`, `CUBE` и `GROUPING SETS` синтаксически равны, они могут выполняться по-разному.
Когда `GROUPING SETS` пытается выполнить все параллельно, `ROLLUP` и `CUBE` выполняют финальную агрегацию в одном потоке.

В ситуации, когда исходные колонки содержат значения по умолчанию, может быть трудно определить, является ли строка частью агрегации, которая использует эти колонки как ключи, или нет.
Чтобы решить эту проблему, необходимо использовать функцию `GROUPING`.

**Пример**

Следующие два запроса эквивалентны.

```sql
-- Запрос 1
SELECT year, month, day, count(*) FROM t GROUP BY year, month, day WITH ROLLUP;

-- Запрос 2
SELECT year, month, day, count(*) FROM t GROUP BY
GROUPING SETS
(
    (year, month, day),
    (year, month),
    (year),
    ()
);
```

**Смотрите также**

- Настройка [group_by_use_nulls](/operations/settings/settings.md#group_by_use_nulls) для совместимости со стандартом SQL.

## Подробности реализации {#implementation-details}

Агрегация является одной из самых важных функций столбцовой СУБД, и, следовательно, ее реализация является одной из самых оптимизированных частей ClickHouse. По умолчанию агрегация выполняется в памяти с использованием хеш-таблицы. Она имеет более 40 специализаций, которые выбираются автоматически в зависимости от типов данных "ключа группировки".

### Оптимизация GROUP BY в зависимости от ключа сортировки таблицы {#group-by-optimization-depending-on-table-sorting-key}

Агрегацию можно выполнять более эффективно, если таблица отсортирована по какому-либо ключу, и выражение `GROUP BY` содержит по крайней мере префикс ключа сортировки или инъективные функции. В этом случае, когда новый ключ читается из таблицы, промежуточный результат агрегации может быть завершен и отправлен клиенту. Это поведение включается настройкой [optimize_aggregation_in_order](../../../operations/settings/settings.md#optimize_aggregation_in_order). Такая оптимизация снижает использование памяти во время агрегации, но в некоторых случаях может замедлить выполнение запроса.

### GROUP BY во внешней памяти {#group-by-in-external-memory}

Вы можете включить выгрузку временных данных на диск, чтобы ограничить использование памяти во время `GROUP BY`.
Настройка [max_bytes_before_external_group_by](/operations/settings/settings#max_bytes_before_external_group_by) определяет пороговое значение использования ОЗУ для выгрузки временных данных `GROUP BY` в файловую систему. Если установить значение 0 (по умолчанию), оно отключено.
Кроме того, вы можете установить [max_bytes_ratio_before_external_group_by](/operations/settings/settings.md#max_bytes_ratio_before_external_group_by), которая позволяет использовать `GROUP BY` во внешней памяти только после достижения запроса определенного порога использованной памяти.

При использовании `max_bytes_before_external_group_by` мы рекомендуем установить `max_memory_usage` примерно в два раза выше (или `max_bytes_ratio_before_external_group_by=0.5`). Это необходимо, поскольку агрегация проходит в два этапа: чтение данных и формирование промежуточных данных (1) и объединение промежуточных данных (2). Выгрузка данных в файловую систему может происходить только на этапе 1. Если временные данные не были выгружены, то этап 2 может потребовать столько же памяти, как на этапе 1.

Например, если [max_memory_usage](/operations/settings/settings.md#max_memory_usage) установлен на 10000000000 и вы хотите использовать внешнюю агрегацию, имеет смысл установить `max_bytes_before_external_group_by` на 10000000000, и `max_memory_usage` на 20000000000. Когда внешняя агрегация активируется (если была хотя бы одна выгрузка временных данных), максимальное потребление ОЗУ будет немного больше, чем `max_bytes_before_external_group_by`.

При распределенной обработке запросов внешняя агрегация выполняется на удаленных серверах. Чтобы сервер-запросчик использовал только небольшое количество ОЗУ, установите `distributed_aggregation_memory_efficient` в 1.

При объединении данных, выгруженных на диск, а также при объединении результатов с удаленных серверов, когда включена настройка `distributed_aggregation_memory_efficient`, используется до `1/256 * количество_потоков` от общего объема ОЗУ.

Когда включена внешняя агрегация, если данных было меньше, чем `max_bytes_before_external_group_by` (т.е. данные не были выгружены), запрос выполняется так же быстро, как без внешней агрегации. Если любые временные данные были выгружены, время выполнения будет в несколько раз дольше (приблизительно в три раза).

Если у вас есть [ORDER BY](/sql-reference/statements/select/order-by.md) с [LIMIT](/sql-reference/statements/select/limit.md) после `GROUP BY`, то количество используемой ОЗУ зависит от объема данных в `LIMIT`, а не от всей таблицы. Но если `ORDER BY` не имеет `LIMIT`, не забудьте включить внешнюю сортировку (`max_bytes_before_external_sort`).
