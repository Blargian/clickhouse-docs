---
description: 'Документация для CHECK TABLE'
sidebar_label: 'CHECK TABLE'
sidebar_position: 41
slug: /sql-reference/statements/check-table
title: 'Оператор CHECK TABLE'
---

Запрос `CHECK TABLE` в ClickHouse используется для выполнения проверки целостности конкретной таблицы или ее партиций. Он обеспечивает целостность данных, проверяя контрольные суммы и другие внутренние структуры данных.

В частности, он сравнивает фактические размеры файлов с ожидаемыми значениями, которые хранятся на сервере. Если размеры файлов не совпадают с хранящимися значениями, это означает, что данные повреждены. Это может быть вызвано, например, сбоем системы во время выполнения запроса.

:::note
Запрос `CHECK TABLE` может прочитать все данные в таблице и использовать некоторые ресурсы, что делает его ресурсоемким.
Учитывайте потенциальное влияние на производительность и использование ресурсов перед выполнением этого запроса.
:::

## Синтаксис {#syntax}

Базовый синтаксис запроса выглядит следующим образом:

```sql
CHECK TABLE table_name [PARTITION partition_expression | PART part_name] [FORMAT format] [SETTINGS check_query_single_value_result = (0|1) [, other_settings]]
```

- `table_name`: Указывает имя таблицы, которую вы хотите проверить.
- `partition_expression`: (Необязательно) Если вы хотите проверить конкретную партицию таблицы, вы можете использовать это выражение для указания партиции.
- `part_name`: (Необязательно) Если вы хотите проверить конкретную часть таблицы, вы можете добавить строковый литерал для указания имени части.
- `FORMAT format`: (Необязательно) Позволяет указать формат вывода результата.
- `SETTINGS`: (Необязательно) Позволяет задать дополнительные настройки.
    - **`check_query_single_value_result`**: (Необязательно) Эта настройка позволяет переключаться между детализированным результатом (`0`) или обобщенным результатом (`1`).
    - Можно применить и другие настройки. Если вам не требуется детерминированный порядок результатов, вы можете установить max_threads на значение больше единицы, чтобы ускорить выполнение запроса.

Ответ на запрос зависит от значения настройки `check_query_single_value_result`.
В случае `check_query_single_value_result = 1` возвращается только `result` колонка с одной строкой. Значение в этой строке равно `1`, если проверка целостности прошла успешно, и `0`, если данные повреждены.

При `check_query_single_value_result = 0` запрос возвращает следующие колонки:
    - `part_path`: Указывает путь к части данных или имя файла.
    - `is_passed`: Возвращает 1, если проверка для этой части прошла успешно, в противном случае 0.
    - `message`: Любые дополнительные сообщения, связанные с проверкой, такие как ошибки или сообщения об успешном выполнении.

Запрос `CHECK TABLE` поддерживает следующие движки таблиц:

- [Log](../../engines/table-engines/log-family/log.md)
- [TinyLog](../../engines/table-engines/log-family/tinylog.md)
- [StripeLog](../../engines/table-engines/log-family/stripelog.md)
- [MergeTree family](../../engines/table-engines/mergetree-family/mergetree.md)

Выполняться запрос `CHECK TABLE` над таблицами с другими движками таблиц вызывает исключение `NOT_IMPLEMENTED`.

Движки из семейства `*Log` не предоставляют автоматическое восстановление данных в случае сбоя. Используйте запрос `CHECK TABLE`, чтобы в своевременно отслеживать потерю данных.

## Примеры {#examples}

По умолчанию запрос `CHECK TABLE` показывает общий статус проверки таблицы:

```sql
CHECK TABLE test_table;
```

```text
┌─result─┐
│      1 │
└────────┘
```

Если вы хотите увидеть статус проверки для каждой отдельной части данных, вы можете использовать настройку `check_query_single_value_result`.

Также, для проверки конкретной партиции таблицы вы можете использовать ключевое слово `PARTITION`.

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
│ 201003_3_3_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Аналогично, вы можете проверить конкретную часть таблицы, используя ключевое слово `PART`.

```sql
CHECK TABLE t0 PART '201003_7_7_0'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message─┐
│ 201003_7_7_0 │         1 │         │
└──────────────┴───────────┴─────────┘
```

Обратите внимание, что когда часть не существует, запрос возвращает ошибку:

```sql
CHECK TABLE t0 PART '201003_111_222_0'
```

```text
DB::Exception: No such data part '201003_111_222_0' to check in table 'default.t0'. (NO_SUCH_DATA_PART)
```

### Получение результата 'Поврежден' {#receiving-a-corrupted-result}

:::warning
Отказ от ответственности: Процедура, описанная здесь, включая ручное изменение или удаление файлов непосредственно из каталога данных, предназначена только для экспериментальных или рабочих сред. Не пытайтесь выполнить это на производственном сервере, так как это может привести к потере данных или другим нежелательным последствиям.
:::

Удалите существующий файл контрольных сумм:

```bash
rm /var/lib/clickhouse-server/data/default/t0/201003_3_3_0/checksums.txt
```

```sql
CHECK TABLE t0 PARTITION ID '201003'
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

Вывод:

```text
┌─part_path────┬─is_passed─┬─message──────────────────────────────────┐
│ 201003_7_7_0 │         1 │                                          │
│ 201003_3_3_0 │         1 │ Контрольные суммы пересчитаны и записаны на диск. │
└──────────────┴───────────┴──────────────────────────────────────────┘
```

Если файл checksums.txt отсутствует, его можно восстановить. Он будет пересчитан и переписан во время выполнения команды CHECK TABLE для конкретной партиции, и статус будет по-прежнему сообщаться как 'is_passed = 1'.

Вы можете проверить все существующие `(Replicated)MergeTree` таблицы сразу, используя запрос `CHECK ALL TABLES`.

```sql
CHECK ALL TABLES
FORMAT PrettyCompactMonoBlock
SETTINGS check_query_single_value_result = 0
```

```text
┌─database─┬─table────┬─part_path───┬─is_passed─┬─message─┐
│ default  │ t2       │ all_1_95_3  │         1 │         │
│ db1      │ table_01 │ all_39_39_0 │         1 │         │
│ default  │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ t1       │ all_39_39_0 │         1 │         │
│ db1      │ table_01 │ all_1_6_1   │         1 │         │
│ default  │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ t1       │ all_1_6_1   │         1 │         │
│ db1      │ table_01 │ all_7_38_2  │         1 │         │
│ db1      │ t1       │ all_7_38_2  │         1 │         │
│ default  │ t1       │ all_7_38_2  │         1 │         │
└──────────┴──────────┴─────────────┴───────────┴─────────┘
```

## Если данные повреждены {#if-the-data-is-corrupted}

Если таблица повреждена, вы можете скопировать неповрежденные данные в другую таблицу. Для этого:

1.  Создайте новую таблицу с такой же структурой, что и поврежденная таблица. Для этого выполните запрос `CREATE TABLE <new_table_name> AS <damaged_table_name>`.
2.  Установите значение `max_threads` равным 1, чтобы обработать следующий запрос в одном потоке. Для этого выполните запрос `SET max_threads = 1`.
3.  Выполните запрос `INSERT INTO <new_table_name> SELECT * FROM <damaged_table_name>`. Этот запрос копирует неповрежденные данные из поврежденной таблицы в другую таблицу. Будут скопированы только данные до поврежденной части.
4.  Перезапустите `clickhouse-client`, чтобы сбросить значение `max_threads`.
